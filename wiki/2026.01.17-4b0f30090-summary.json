{
  "version": "2026.01.17-4b0f30090",
  "categories": {
    "asseteditor": [
      {
        "name": "SchemaFile",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "content",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SchemaFile\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String content;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SchemaFile deserialize(@Nonnull ByteBuf buf, int offset) {\n      SchemaFile obj = new SchemaFile();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int contentLen = VarInt.peek(buf, pos);\n         if (contentLen < 0) {\n            throw ProtocolException.negativeLength(\"Content\", contentLen);\n         }\n\n         if (contentLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Content\", contentLen, 4096000);\n         }\n\n         int contentVarLen = VarInt.length(buf, pos);\n         obj.content = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += contentVarLen + contentLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int contentLen = VarInt.peek(buffer, pos);\n            if (contentLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Content\");\n            }\n\n            if (contentLen > 4096000) {\n               return ValidationResult.error(\"Content exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += contentLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Content\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorPreviewCameraSettings",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "modelScale",
            "type": "float",
            "nullable": false
          },
          {
            "name": "cameraPosition",
            "type": "Vector3f",
            "nullable": true
          },
          {
            "name": "cameraOrientation",
            "type": "Vector3f",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorPreviewCameraSettings\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 29;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 29;\npublic static final int MAX_SIZE = 29;\n\n// === FIELDS ===\n@Nonnull float modelScale;\n@Nullable Vector3f cameraPosition;\n@Nullable Vector3f cameraOrientation;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorPreviewCameraSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorPreviewCameraSettings obj = new AssetEditorPreviewCameraSettings();\n      byte nullBits = buf.getByte(offset);\n      obj.modelScale = buf.getFloatLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.cameraPosition = Vector3f.deserialize(buf, offset + 5);\n      }\n\n      if ((nullBits & 2) != 0) {\n         obj.cameraOrientation = Vector3f.deserialize(buf, offset + 17);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorPreviewCameraSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorPreviewCameraSettings obj = new AssetEditorPreviewCameraSettings();\n      byte nullBits = buf.getByte(offset);\n      obj.modelScale = buf.getFloatLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.cameraPosition = Vector3f.deserialize(buf, offset + 5);\n      }\n\n      if ((nullBits & 2) != 0) {\n         obj.cameraOrientation = Vector3f.deserialize(buf, offset + 17);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 29;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 29 ? ValidationResult.error(\"Buffer too small: expected at least 29 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getFloatLE, Vector3f.deserialize\n// Types referenced: Vector3f\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetPath",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "pack",
            "type": "String",
            "nullable": true
          },
          {
            "name": "path",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetPath\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 32768019;\n\n// === FIELDS ===\n@Nullable String pack;\n@Nullable String path;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetPath deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetPath obj = new AssetPath();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int packLen = VarInt.peek(buf, varPos0);\n         if (packLen < 0) {\n            throw ProtocolException.negativeLength(\"Pack\", packLen);\n         }\n\n         if (packLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Pack\", packLen, 4096000);\n         }\n\n         obj.pack = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int pathLen = VarInt.peek(buf, varPos1);\n         if (pathLen < 0) {\n            throw ProtocolException.negativeLength(\"Path\", pathLen);\n         }\n\n         if (pathLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Path\", pathLen, 4096000);\n         }\n\n         obj.path = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int packOffset = buffer.getIntLE(offset + 1);\n            if (packOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Pack\");\n            }\n\n            int pos = offset + 9 + packOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Pack\");\n            }\n\n            int packLen = VarInt.peek(buffer, pos);\n            if (packLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Pack\");\n            }\n\n            if (packLen > 4096000) {\n               return ValidationResult.error(\"Pack exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += packLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Pack\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 5);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int posx = offset + 9 + pathOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            int pathLen = VarInt.peek(buffer, posx);\n            if (pathLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Path\");\n            }\n\n            if (pathLen > 4096000) {\n               return ValidationResult.error(\"Path exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += pathLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Path\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "JsonUpdateCommand",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "type",
            "type": "JsonUpdateType",
            "nullable": false
          },
          {
            "name": "path",
            "type": "String[]",
            "nullable": true
          },
          {
            "name": "value",
            "type": "String",
            "nullable": true
          },
          {
            "name": "previousValue",
            "type": "String",
            "nullable": true
          },
          {
            "name": "firstCreatedProperty",
            "type": "String[]",
            "nullable": true
          },
          {
            "name": "rebuildCaches",
            "type": "AssetEditorRebuildCaches",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: JsonUpdateCommand\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 7;\npublic static final int VARIABLE_FIELD_COUNT = 4;\npublic static final int VARIABLE_BLOCK_START = 23;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull JsonUpdateType type;\n@Nullable String[] path;\n@Nullable String value;\n@Nullable String previousValue;\n@Nullable String[] firstCreatedProperty;\n@Nullable AssetEditorRebuildCaches rebuildCaches;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static JsonUpdateCommand deserialize(@Nonnull ByteBuf buf, int offset) {\n      JsonUpdateCommand obj = new JsonUpdateCommand();\n      byte nullBits = buf.getByte(offset);\n      obj.type = JsonUpdateType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 16) != 0) {\n         obj.rebuildCaches = AssetEditorRebuildCaches.deserialize(buf, offset + 2);\n      }\n\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 23 + buf.getIntLE(offset + 7);\n         int pathCount = VarInt.peek(buf, varPos0);\n         if (pathCount < 0) {\n            throw ProtocolException.negativeLength(\"Path\", pathCount);\n         }\n\n         if (pathCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Path\", pathCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)pathCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Path\", varPos0 + varIntLen + pathCount * 1, buf.readableBytes());\n         }\n\n         obj.path = new String[pathCount];\n         int elemPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < pathCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"path[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"path[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.path[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 23 + buf.getIntLE(offset + 11);\n         int valueLen = VarInt.peek(buf, varPos1);\n         if (valueLen < 0) {\n            throw ProtocolException.negativeLength(\"Value\", valueLen);\n         }\n\n         if (valueLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Value\", valueLen, 4096000);\n         }\n\n         obj.value = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 23 + buf.getIntLE(offset + 15);\n         int previousValueLen = VarInt.peek(buf, varPos2);\n         if (previousValueLen < 0) {\n            throw ProtocolException.negativeLength(\"PreviousValue\", previousValueLen);\n         }\n\n         if (previousValueLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"PreviousValue\", previousValueLen, 4096000);\n         }\n\n         obj.previousValue = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 23 + buf.getIntLE(offset + 19);\n         int firstCreatedPropertyCount = VarInt.peek(buf, varPos3);\n         if (firstCreatedPropertyCount < 0) {\n            throw ProtocolException.negativeLength(\"FirstCreatedProperty\", firstCreatedPropertyCount);\n         }\n\n         if (firstCreatedPropertyCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"FirstCreatedProperty\", firstCreatedPropertyCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos3);\n         if ((long)(varPos3 + varIntLen) + (long)firstCreatedPropertyCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"FirstCreatedProperty\", varPos3 + varIntLen + firstCreatedPropertyCount * 1, buf.readableBytes());\n         }\n\n         obj.firstCreatedProperty = new String[firstCreatedPropertyCount];\n         int elemPos = varPos3 + varIntLen;\n\n         for (int i = 0; i < firstCreatedPropertyCount; i++) {\n            int strLenx = VarInt.peek(buf, elemPos);\n            if (strLenx < 0) {\n               throw ProtocolException.negativeLength(\"firstCreatedProperty[\" + i + \"]\", strLenx);\n            }\n\n            if (strLenx > 4096000) {\n               throw ProtocolException.stringTooLong(\"firstCreatedProperty[\" + i + \"]\", strLenx, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.firstCreatedProperty[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLenx;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static JsonUpdateCommand deserialize(@Nonnull ByteBuf buf, int offset) {\n      JsonUpdateCommand obj = new JsonUpdateCommand();\n      byte nullBits = buf.getByte(offset);\n      obj.type = JsonUpdateType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 16) != 0) {\n         obj.rebuildCaches = AssetEditorRebuildCaches.deserialize(buf, offset + 2);\n      }\n\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 23 + buf.getIntLE(offset + 7);\n         int pathCount = VarInt.peek(buf, varPos0);\n         if (pathCount < 0) {\n            throw ProtocolException.negativeLength(\"Path\", pathCount);\n         }\n\n         if (pathCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Path\", pathCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)pathCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Path\", varPos0 + varIntLen + pathCount * 1, buf.readableBytes());\n         }\n\n         obj.path = new String[pathCount];\n         int elemPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < pathCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"path[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"path[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.path[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 23 + buf.getIntLE(offset + 11);\n         int valueLen = VarInt.peek(buf, varPos1);\n         if (valueLen < 0) {\n            throw ProtocolException.negativeLength(\"Value\", valueLen);\n         }\n\n         if (valueLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Value\", valueLen, 4096000);\n         }\n\n         obj.value = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 23 + buf.getIntLE(offset + 15);\n         int previousValueLen = VarInt.peek(buf, varPos2);\n         if (previousValueLen < 0) {\n            throw ProtocolException.negativeLength(\"PreviousValue\", previousValueLen);\n         }\n\n         if (previousValueLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"PreviousValue\", previousValueLen, 4096000);\n         }\n\n         obj.previousValue = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 23 + buf.getIntLE(offset + 19);\n         int firstCreatedPropertyCount = VarInt.peek(buf, varPos3);\n         if (firstCreatedPropertyCount < 0) {\n            throw ProtocolException.negativeLength(\"FirstCreatedProperty\", firstCreatedPropertyCount);\n         }\n\n         if (firstCreatedPropertyCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"FirstCreatedProperty\", firstCreatedPropertyCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos3);\n         if ((long)(varPos3 + varIntLen) + (long)firstCreatedPropertyCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"FirstCreatedProperty\", varPos3 + varIntLen + firstCreatedPropertyCount * 1, buf.readableBytes());\n         }\n\n         obj.firstCreatedProperty = new String[firstCreatedPropertyCount];\n         int elemPos = varPos3 + varIntLen;\n\n         for (int i = 0; i < firstCreatedPropertyCount; i++) {\n            int strLenx = VarInt.peek(buf, elemPos);\n            if (strLenx < 0) {\n               throw ProtocolException.negativeLength(\"firstCreatedProperty[\" + i + \"]\", strLenx);\n            }\n\n            if (strLenx > 4096000) {\n               throw ProtocolException.stringTooLong(\"firstCreatedProperty[\" + i + \"]\", strLenx, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.firstCreatedProperty[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLenx;\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 23;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 7);\n         int pos0 = offset + 23 + fieldOffset0;\n         int arrLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos0);\n            pos0 += VarInt.length(buf, pos0) + sl;\n         }\n\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 11);\n         int pos1 = offset + 23 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 15);\n         int pos2 = offset + 23 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         int fieldOffset3 = buf.getIntLE(offset + 19);\n         int pos3 = offset + 23 + fieldOffset3;\n         int arrLen = VarInt.peek(buf, pos3);\n         pos3 += VarInt.length(buf, pos3);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos3);\n            pos3 += VarInt.length(buf, pos3) + sl;\n         }\n\n         if (pos3 - offset > maxEnd) {\n            maxEnd = pos3 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 23) {\n         return ValidationResult.error(\"Buffer too small: expected at least 23 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 7);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int pos = offset + 23 + pathOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            int pathCount = VarInt.peek(buffer, pos);\n            if (pathCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Path\");\n            }\n\n            if (pathCount > 4096000) {\n               return ValidationResult.error(\"Path exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < pathCount; i++) {\n               int strLen = VarInt.peek(buffer, pos);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in Path\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += strLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in Path\");\n               }\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int valueOffset = buffer.getIntLE(offset + 11);\n            if (valueOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Value\");\n            }\n\n            int posx = offset + 23 + valueOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Value\");\n            }\n\n            int valueLen = VarInt.peek(buffer, posx);\n            if (valueLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Value\");\n            }\n\n            if (valueLen > 4096000) {\n               return ValidationResult.error(\"Value exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += valueLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Value\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int previousValueOffset = buffer.getIntLE(offset + 15);\n            if (previousValueOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for PreviousValue\");\n            }\n\n            int posxx = offset + 23 + previousValueOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for PreviousValue\");\n            }\n\n            int previousValueLen = VarInt.peek(buffer, posxx);\n            if (previousValueLen < 0) {\n               return ValidationResult.error(\"Invalid string length for PreviousValue\");\n            }\n\n            if (previousValueLen > 4096000) {\n               return ValidationResult.error(\"PreviousValue exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += previousValueLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading PreviousValue\");\n            }\n         }\n\n         if ((nullBits & 8) != 0) {\n            int firstCreatedPropertyOffset = buffer.getIntLE(offset + 19);\n            if (firstCreatedPropertyOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for FirstCreatedProperty\");\n            }\n\n            int posxxx = offset + 23 + firstCreatedPropertyOffset;\n            if (posxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for FirstCreatedProperty\");\n            }\n\n            int firstCreatedPropertyCount = VarInt.peek(buffer, posxxx);\n            if (firstCreatedPropertyCount < 0) {\n               return ValidationResult.error(\"Invalid array count for FirstCreatedProperty\");\n            }\n\n            if (firstCreatedPropertyCount > 4096000) {\n               return ValidationResult.error(\"FirstCreatedProperty exceeds max length 4096000\");\n            }\n\n            posxxx += VarInt.length(buffer, posxxx);\n\n            for (int i = 0; i < firstCreatedPropertyCount; i++) {\n               int strLenx = VarInt.peek(buffer, posxxx);\n               if (strLenx < 0) {\n                  return ValidationResult.error(\"Invalid string length in FirstCreatedProperty\");\n               }\n\n               posxxx += VarInt.length(buffer, posxxx);\n               posxxx += strLenx;\n               if (posxxx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in FirstCreatedProperty\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, JsonUpdateType.fromValue, AssetEditorRebuildCaches.deserialize, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: JsonUpdateType, AssetEditorRebuildCaches\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetPackManifest",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "name",
            "type": "String",
            "nullable": true
          },
          {
            "name": "group",
            "type": "String",
            "nullable": true
          },
          {
            "name": "website",
            "type": "String",
            "nullable": true
          },
          {
            "name": "description",
            "type": "String",
            "nullable": true
          },
          {
            "name": "version",
            "type": "String",
            "nullable": true
          },
          {
            "name": "authors",
            "type": "AuthorInfo[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetPackManifest\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 6;\npublic static final int VARIABLE_BLOCK_START = 25;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable String name;\n@Nullable String group;\n@Nullable String website;\n@Nullable String description;\n@Nullable String version;\n@Nullable AuthorInfo[] authors;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetPackManifest deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetPackManifest obj = new AssetPackManifest();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 25 + buf.getIntLE(offset + 1);\n         int nameLen = VarInt.peek(buf, varPos0);\n         if (nameLen < 0) {\n            throw ProtocolException.negativeLength(\"Name\", nameLen);\n         }\n\n         if (nameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Name\", nameLen, 4096000);\n         }\n\n         obj.name = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 25 + buf.getIntLE(offset + 5);\n         int groupLen = VarInt.peek(buf, varPos1);\n         if (groupLen < 0) {\n            throw ProtocolException.negativeLength(\"Group\", groupLen);\n         }\n\n         if (groupLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Group\", groupLen, 4096000);\n         }\n\n         obj.group = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 25 + buf.getIntLE(offset + 9);\n         int websiteLen = VarInt.peek(buf, varPos2);\n         if (websiteLen < 0) {\n            throw ProtocolException.negativeLength(\"Website\", websiteLen);\n         }\n\n         if (websiteLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Website\", websiteLen, 4096000);\n         }\n\n         obj.website = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 25 + buf.getIntLE(offset + 13);\n         int descriptionLen = VarInt.peek(buf, varPos3);\n         if (descriptionLen < 0) {\n            throw ProtocolException.negativeLength(\"Description\", descriptionLen);\n         }\n\n         if (descriptionLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Description\", descriptionLen, 4096000);\n         }\n\n         obj.description = PacketIO.readVarString(buf, varPos3, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 16) != 0) {\n         int varPos4 = offset + 25 + buf.getIntLE(offset + 17);\n         int versionLen = VarInt.peek(buf, varPos4);\n         if (versionLen < 0) {\n            throw ProtocolException.negativeLength(\"Version\", versionLen);\n         }\n\n         if (versionLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Version\", versionLen, 4096000);\n         }\n\n         obj.version = PacketIO.readVarString(buf, varPos4, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 32) != 0) {\n         int varPos5 = offset + 25 + buf.getIntLE(offset + 21);\n         int authorsCount = VarInt.peek(buf, varPos5);\n         if (authorsCount < 0) {\n            throw ProtocolException.negativeLength(\"Authors\", authorsCount);\n         }\n\n         if (authorsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Authors\", authorsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos5);\n         if ((long)(varPos5 + varIntLen) + (long)authorsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Authors\", varPos5 + varIntLen + authorsCount * 1, buf.readableBytes());\n         }\n\n         obj.authors = new AuthorInfo[authorsCount];\n         int elemPos = varPos5 + varIntLen;\n\n         for (int i = 0; i < authorsCount; i++) {\n            obj.authors[i] = AuthorInfo.deserialize(buf, elemPos);\n            elemPos += AuthorInfo.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetPackManifest deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetPackManifest obj = new AssetPackManifest();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 25 + buf.getIntLE(offset + 1);\n         int nameLen = VarInt.peek(buf, varPos0);\n         if (nameLen < 0) {\n            throw ProtocolException.negativeLength(\"Name\", nameLen);\n         }\n\n         if (nameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Name\", nameLen, 4096000);\n         }\n\n         obj.name = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 25 + buf.getIntLE(offset + 5);\n         int groupLen = VarInt.peek(buf, varPos1);\n         if (groupLen < 0) {\n            throw ProtocolException.negativeLength(\"Group\", groupLen);\n         }\n\n         if (groupLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Group\", groupLen, 4096000);\n         }\n\n         obj.group = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 25 + buf.getIntLE(offset + 9);\n         int websiteLen = VarInt.peek(buf, varPos2);\n         if (websiteLen < 0) {\n            throw ProtocolException.negativeLength(\"Website\", websiteLen);\n         }\n\n         if (websiteLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Website\", websiteLen, 4096000);\n         }\n\n         obj.website = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 25 + buf.getIntLE(offset + 13);\n         int descriptionLen = VarInt.peek(buf, varPos3);\n         if (descriptionLen < 0) {\n            throw ProtocolException.negativeLength(\"Description\", descriptionLen);\n         }\n\n         if (descriptionLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Description\", descriptionLen, 4096000);\n         }\n\n         obj.description = PacketIO.readVarString(buf, varPos3, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 16) != 0) {\n         int varPos4 = offset + 25 + buf.getIntLE(offset + 17);\n         int versionLen = VarInt.peek(buf, varPos4);\n         if (versionLen < 0) {\n            throw ProtocolException.negativeLength(\"Version\", versionLen);\n         }\n\n         if (versionLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Version\", versionLen, 4096000);\n         }\n\n         obj.version = PacketIO.readVarString(buf, varPos4, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 32) != 0) {\n         int varPos5 = offset + 25 + buf.getIntLE(offset + 21);\n         int authorsCount = VarInt.peek(buf, varPos5);\n         if (authorsCount < 0) {\n            throw ProtocolException.negativeLength(\"Authors\", authorsCount);\n         }\n\n         if (authorsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Authors\", authorsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos5);\n         if ((long)(varPos5 + varIntLen) + (long)authorsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Authors\", varPos5 + varIntLen + authorsCount * 1, buf.readableBytes());\n         }\n\n         obj.authors = new AuthorInfo[authorsCount];\n         int elemPos = varPos5 + varIntLen;\n\n         for (int i = 0; i < authorsCount; i++) {\n            obj.authors[i] = AuthorInfo.deserialize(buf, elemPos);\n            elemPos += AuthorInfo.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 25;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 25 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 25 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 9);\n         int pos2 = offset + 25 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         int fieldOffset3 = buf.getIntLE(offset + 13);\n         int pos3 = offset + 25 + fieldOffset3;\n         int sl = VarInt.peek(buf, pos3);\n         pos3 += VarInt.length(buf, pos3) + sl;\n         if (pos3 - offset > maxEnd) {\n            maxEnd = pos3 - offset;\n         }\n      }\n\n      if ((nullBits & 16) != 0) {\n         int fieldOffset4 = buf.getIntLE(offset + 17);\n         int pos4 = offset + 25 + fieldOffset4;\n         int sl = VarInt.peek(buf, pos4);\n         pos4 += VarInt.length(buf, pos4) + sl;\n         if (pos4 - offset > maxEnd) {\n            maxEnd = pos4 - offset;\n         }\n      }\n\n      if ((nullBits & 32) != 0) {\n         int fieldOffset5 = buf.getIntLE(offset + 21);\n         int pos5 = offset + 25 + fieldOffset5;\n         int arrLen = VarInt.peek(buf, pos5);\n         pos5 += VarInt.length(buf, pos5);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos5 += AuthorInfo.computeBytesConsumed(buf, pos5);\n         }\n\n         if (pos5 - offset > maxEnd) {\n            maxEnd = pos5 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 25) {\n         return ValidationResult.error(\"Buffer too small: expected at least 25 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int nameOffset = buffer.getIntLE(offset + 1);\n            if (nameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Name\");\n            }\n\n            int pos = offset + 25 + nameOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Name\");\n            }\n\n            int nameLen = VarInt.peek(buffer, pos);\n            if (nameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Name\");\n            }\n\n            if (nameLen > 4096000) {\n               return ValidationResult.error(\"Name exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += nameLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Name\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int groupOffset = buffer.getIntLE(offset + 5);\n            if (groupOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Group\");\n            }\n\n            int posx = offset + 25 + groupOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Group\");\n            }\n\n            int groupLen = VarInt.peek(buffer, posx);\n            if (groupLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Group\");\n            }\n\n            if (groupLen > 4096000) {\n               return ValidationResult.error(\"Group exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += groupLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Group\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int websiteOffset = buffer.getIntLE(offset + 9);\n            if (websiteOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Website\");\n            }\n\n            int posxx = offset + 25 + websiteOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Website\");\n            }\n\n            int websiteLen = VarInt.peek(buffer, posxx);\n            if (websiteLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Website\");\n            }\n\n            if (websiteLen > 4096000) {\n               return ValidationResult.error(\"Website exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += websiteLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Website\");\n            }\n         }\n\n         if ((nullBits & 8) != 0) {\n            int descriptionOffset = buffer.getIntLE(offset + 13);\n            if (descriptionOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Description\");\n            }\n\n            int posxxx = offset + 25 + descriptionOffset;\n            if (posxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Description\");\n            }\n\n            int descriptionLen = VarInt.peek(buffer, posxxx);\n            if (descriptionLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Description\");\n            }\n\n            if (descriptionLen > 4096000) {\n               return ValidationResult.error(\"Description exceeds max length 4096000\");\n            }\n\n            posxxx += VarInt.length(buffer, posxxx);\n            posxxx += descriptionLen;\n            if (posxxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Description\");\n            }\n         }\n\n         if ((nullBits & 16) != 0) {\n            int versionOffset = buffer.getIntLE(offset + 17);\n            if (versionOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Version\");\n            }\n\n            int posxxxx = offset + 25 + versionOffset;\n            if (posxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Version\");\n            }\n\n            int versionLen = VarInt.peek(buffer, posxxxx);\n            if (versionLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Version\");\n            }\n\n            if (versionLen > 4096000) {\n               return ValidationResult.error(\"Version exceeds max length 4096000\");\n            }\n\n            posxxxx += VarInt.length(buffer, posxxxx);\n            posxxxx += versionLen;\n            if (posxxxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Version\");\n            }\n         }\n\n         if ((nullBits & 32) != 0) {\n            int authorsOffset = buffer.getIntLE(offset + 21);\n            if (authorsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Authors\");\n            }\n\n            int posxxxxx = offset + 25 + authorsOffset;\n            if (posxxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Authors\");\n            }\n\n            int authorsCount = VarInt.peek(buffer, posxxxxx);\n            if (authorsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Authors\");\n            }\n\n            if (authorsCount > 4096000) {\n               return ValidationResult.error(\"Authors exceeds max length 4096000\");\n            }\n\n            posxxxxx += VarInt.length(buffer, posxxxxx);\n\n            for (int i = 0; i < authorsCount; i++) {\n               ValidationResult structResult = AuthorInfo.validateStructure(buffer, posxxxxx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid AuthorInfo in Authors[\" + i + \"]: \" + structResult.error());\n               }\n\n               posxxxxx += AuthorInfo.computeBytesConsumed(buffer, posxxxxx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, AuthorInfo.deserialize, AuthorInfo.computeBytesConsumed\n// Types referenced: AuthorInfo\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorAssetType",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "id",
            "type": "String",
            "nullable": true
          },
          {
            "name": "icon",
            "type": "String",
            "nullable": true
          },
          {
            "name": "isColoredIcon",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "path",
            "type": "String",
            "nullable": true
          },
          {
            "name": "fileExtension",
            "type": "String",
            "nullable": true
          },
          {
            "name": "editorType",
            "type": "AssetEditorEditorType",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorAssetType\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 3;\npublic static final int VARIABLE_FIELD_COUNT = 4;\npublic static final int VARIABLE_BLOCK_START = 19;\npublic static final int MAX_SIZE = 65536039;\n\n// === FIELDS ===\n@Nullable String id;\n@Nullable String icon;\n@Nonnull boolean isColoredIcon;\n@Nullable String path;\n@Nullable String fileExtension;\n@Nonnull AssetEditorEditorType editorType;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorAssetType deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAssetType obj = new AssetEditorAssetType();\n      byte nullBits = buf.getByte(offset);\n      obj.isColoredIcon = buf.getByte(offset + 1) != 0;\n      obj.editorType = AssetEditorEditorType.fromValue(buf.getByte(offset + 2));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 19 + buf.getIntLE(offset + 3);\n         int idLen = VarInt.peek(buf, varPos0);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         obj.id = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 19 + buf.getIntLE(offset + 7);\n         int iconLen = VarInt.peek(buf, varPos1);\n         if (iconLen < 0) {\n            throw ProtocolException.negativeLength(\"Icon\", iconLen);\n         }\n\n         if (iconLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Icon\", iconLen, 4096000);\n         }\n\n         obj.icon = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 19 + buf.getIntLE(offset + 11);\n         int pathLen = VarInt.peek(buf, varPos2);\n         if (pathLen < 0) {\n            throw ProtocolException.negativeLength(\"Path\", pathLen);\n         }\n\n         if (pathLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Path\", pathLen, 4096000);\n         }\n\n         obj.path = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 19 + buf.getIntLE(offset + 15);\n         int fileExtensionLen = VarInt.peek(buf, varPos3);\n         if (fileExtensionLen < 0) {\n            throw ProtocolException.negativeLength(\"FileExtension\", fileExtensionLen);\n         }\n\n         if (fileExtensionLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"FileExtension\", fileExtensionLen, 4096000);\n         }\n\n         obj.fileExtension = PacketIO.readVarString(buf, varPos3, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 19;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 3);\n         int pos0 = offset + 19 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 7);\n         int pos1 = offset + 19 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 11);\n         int pos2 = offset + 19 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         int fieldOffset3 = buf.getIntLE(offset + 15);\n         int pos3 = offset + 19 + fieldOffset3;\n         int sl = VarInt.peek(buf, pos3);\n         pos3 += VarInt.length(buf, pos3) + sl;\n         if (pos3 - offset > maxEnd) {\n            maxEnd = pos3 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 19) {\n         return ValidationResult.error(\"Buffer too small: expected at least 19 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int idOffset = buffer.getIntLE(offset + 3);\n            if (idOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Id\");\n            }\n\n            int pos = offset + 19 + idOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Id\");\n            }\n\n            int idLen = VarInt.peek(buffer, pos);\n            if (idLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Id\");\n            }\n\n            if (idLen > 4096000) {\n               return ValidationResult.error(\"Id exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += idLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Id\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int iconOffset = buffer.getIntLE(offset + 7);\n            if (iconOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Icon\");\n            }\n\n            int posx = offset + 19 + iconOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Icon\");\n            }\n\n            int iconLen = VarInt.peek(buffer, posx);\n            if (iconLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Icon\");\n            }\n\n            if (iconLen > 4096000) {\n               return ValidationResult.error(\"Icon exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += iconLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Icon\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 11);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int posxx = offset + 19 + pathOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            int pathLen = VarInt.peek(buffer, posxx);\n            if (pathLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Path\");\n            }\n\n            if (pathLen > 4096000) {\n               return ValidationResult.error(\"Path exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += pathLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Path\");\n            }\n         }\n\n         if ((nullBits & 8) != 0) {\n            int fileExtensionOffset = buffer.getIntLE(offset + 15);\n            if (fileExtensionOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for FileExtension\");\n            }\n\n            int posxxx = offset + 19 + fileExtensionOffset;\n            if (posxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for FileExtension\");\n            }\n\n            int fileExtensionLen = VarInt.peek(buffer, posxxx);\n            if (fileExtensionLen < 0) {\n               return ValidationResult.error(\"Invalid string length for FileExtension\");\n            }\n\n            if (fileExtensionLen > 4096000) {\n               return ValidationResult.error(\"FileExtension exceeds max length 4096000\");\n            }\n\n            posxxx += VarInt.length(buffer, posxxx);\n            posxxx += fileExtensionLen;\n            if (posxxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading FileExtension\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, AssetEditorEditorType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: AssetEditorEditorType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "TimestampedAssetReference",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "timestamp",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: TimestampedAssetReference\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 49152033;\n\n// === FIELDS ===\n@Nullable AssetPath path;\n@Nullable String timestamp;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static TimestampedAssetReference deserialize(@Nonnull ByteBuf buf, int offset) {\n      TimestampedAssetReference obj = new TimestampedAssetReference();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int timestampLen = VarInt.peek(buf, varPos1);\n         if (timestampLen < 0) {\n            throw ProtocolException.negativeLength(\"Timestamp\", timestampLen);\n         }\n\n         if (timestampLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Timestamp\", timestampLen, 4096000);\n         }\n\n         obj.timestamp = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static TimestampedAssetReference deserialize(@Nonnull ByteBuf buf, int offset) {\n      TimestampedAssetReference obj = new TimestampedAssetReference();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int timestampLen = VarInt.peek(buf, varPos1);\n         if (timestampLen < 0) {\n            throw ProtocolException.negativeLength(\"Timestamp\", timestampLen);\n         }\n\n         if (timestampLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Timestamp\", timestampLen, 4096000);\n         }\n\n         obj.timestamp = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         pos0 += AssetPath.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 1);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int pos = offset + 9 + pathOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int timestampOffset = buffer.getIntLE(offset + 5);\n            if (timestampOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Timestamp\");\n            }\n\n            int posx = offset + 9 + timestampOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Timestamp\");\n            }\n\n            int timestampLen = VarInt.peek(buffer, posx);\n            if (timestampLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Timestamp\");\n            }\n\n            if (timestampLen > 4096000) {\n               return ValidationResult.error(\"Timestamp exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += timestampLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Timestamp\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorFileEntry",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "path",
            "type": "String",
            "nullable": true
          },
          {
            "name": "isDirectory",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorFileEntry\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 16384007;\n\n// === FIELDS ===\n@Nullable String path;\n@Nonnull boolean isDirectory;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorFileEntry deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorFileEntry obj = new AssetEditorFileEntry();\n      byte nullBits = buf.getByte(offset);\n      obj.isDirectory = buf.getByte(offset + 1) != 0;\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int pathLen = VarInt.peek(buf, pos);\n         if (pathLen < 0) {\n            throw ProtocolException.negativeLength(\"Path\", pathLen);\n         }\n\n         if (pathLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Path\", pathLen, 4096000);\n         }\n\n         int pathVarLen = VarInt.length(buf, pos);\n         obj.path = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += pathVarLen + pathLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int pathLen = VarInt.peek(buffer, pos);\n            if (pathLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Path\");\n            }\n\n            if (pathLen > 4096000) {\n               return ValidationResult.error(\"Path exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += pathLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Path\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AuthorInfo",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "name",
            "type": "String",
            "nullable": true
          },
          {
            "name": "email",
            "type": "String",
            "nullable": true
          },
          {
            "name": "url",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AuthorInfo\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 49152028;\n\n// === FIELDS ===\n@Nullable String name;\n@Nullable String email;\n@Nullable String url;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AuthorInfo deserialize(@Nonnull ByteBuf buf, int offset) {\n      AuthorInfo obj = new AuthorInfo();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 1);\n         int nameLen = VarInt.peek(buf, varPos0);\n         if (nameLen < 0) {\n            throw ProtocolException.negativeLength(\"Name\", nameLen);\n         }\n\n         if (nameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Name\", nameLen, 4096000);\n         }\n\n         obj.name = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 5);\n         int emailLen = VarInt.peek(buf, varPos1);\n         if (emailLen < 0) {\n            throw ProtocolException.negativeLength(\"Email\", emailLen);\n         }\n\n         if (emailLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Email\", emailLen, 4096000);\n         }\n\n         obj.email = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 13 + buf.getIntLE(offset + 9);\n         int urlLen = VarInt.peek(buf, varPos2);\n         if (urlLen < 0) {\n            throw ProtocolException.negativeLength(\"Url\", urlLen);\n         }\n\n         if (urlLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Url\", urlLen, 4096000);\n         }\n\n         obj.url = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 13;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 13 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 13 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 9);\n         int pos2 = offset + 13 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int nameOffset = buffer.getIntLE(offset + 1);\n            if (nameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Name\");\n            }\n\n            int pos = offset + 13 + nameOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Name\");\n            }\n\n            int nameLen = VarInt.peek(buffer, pos);\n            if (nameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Name\");\n            }\n\n            if (nameLen > 4096000) {\n               return ValidationResult.error(\"Name exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += nameLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Name\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int emailOffset = buffer.getIntLE(offset + 5);\n            if (emailOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Email\");\n            }\n\n            int posx = offset + 13 + emailOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Email\");\n            }\n\n            int emailLen = VarInt.peek(buffer, posx);\n            if (emailLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Email\");\n            }\n\n            if (emailLen > 4096000) {\n               return ValidationResult.error(\"Email exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += emailLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Email\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int urlOffset = buffer.getIntLE(offset + 9);\n            if (urlOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Url\");\n            }\n\n            int posxx = offset + 13 + urlOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Url\");\n            }\n\n            int urlLen = VarInt.peek(buffer, posxx);\n            if (urlLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Url\");\n            }\n\n            if (urlLen > 4096000) {\n               return ValidationResult.error(\"Url exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += urlLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Url\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorAsset",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "hash",
            "type": "String",
            "nullable": true
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorAsset\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 49152033;\n\n// === FIELDS ===\n@Nullable String hash;\n@Nullable AssetPath path;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAsset obj = new AssetEditorAsset();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int hashLen = VarInt.peek(buf, varPos0);\n         if (hashLen < 0) {\n            throw ProtocolException.negativeLength(\"Hash\", hashLen);\n         }\n\n         if (hashLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Hash\", hashLen, 4096000);\n         }\n\n         obj.hash = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         obj.path = AssetPath.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAsset obj = new AssetEditorAsset();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int hashLen = VarInt.peek(buf, varPos0);\n         if (hashLen < 0) {\n            throw ProtocolException.negativeLength(\"Hash\", hashLen);\n         }\n\n         if (hashLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Hash\", hashLen, 4096000);\n         }\n\n         obj.hash = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         obj.path = AssetPath.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         pos1 += AssetPath.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int hashOffset = buffer.getIntLE(offset + 1);\n            if (hashOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Hash\");\n            }\n\n            int pos = offset + 9 + hashOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Hash\");\n            }\n\n            int hashLen = VarInt.peek(buffer, pos);\n            if (hashLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Hash\");\n            }\n\n            if (hashLen > 4096000) {\n               return ValidationResult.error(\"Hash exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += hashLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Hash\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 5);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int posx = offset + 9 + pathOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, posx);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            posx += AssetPath.computeBytesConsumed(buffer, posx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, AssetPath.deserialize\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetInfo",
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "oldPath",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "isDeleted",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "isNew",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "lastModificationDate",
            "type": "long",
            "nullable": false
          },
          {
            "name": "lastModificationUsername",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetInfo\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 11;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 23;\npublic static final int MAX_SIZE = 81920066;\n\n// === FIELDS ===\n@Nullable AssetPath path;\n@Nullable AssetPath oldPath;\n@Nonnull boolean isDeleted;\n@Nonnull boolean isNew;\n@Nonnull long lastModificationDate;\n@Nullable String lastModificationUsername;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetInfo deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetInfo obj = new AssetInfo();\n      byte nullBits = buf.getByte(offset);\n      obj.isDeleted = buf.getByte(offset + 1) != 0;\n      obj.isNew = buf.getByte(offset + 2) != 0;\n      obj.lastModificationDate = buf.getLongLE(offset + 3);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 23 + buf.getIntLE(offset + 11);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 23 + buf.getIntLE(offset + 15);\n         obj.oldPath = AssetPath.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 23 + buf.getIntLE(offset + 19);\n         int lastModificationUsernameLen = VarInt.peek(buf, varPos2);\n         if (lastModificationUsernameLen < 0) {\n            throw ProtocolException.negativeLength(\"LastModificationUsername\", lastModificationUsernameLen);\n         }\n\n         if (lastModificationUsernameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"LastModificationUsername\", lastModificationUsernameLen, 4096000);\n         }\n\n         obj.lastModificationUsername = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetInfo deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetInfo obj = new AssetInfo();\n      byte nullBits = buf.getByte(offset);\n      obj.isDeleted = buf.getByte(offset + 1) != 0;\n      obj.isNew = buf.getByte(offset + 2) != 0;\n      obj.lastModificationDate = buf.getLongLE(offset + 3);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 23 + buf.getIntLE(offset + 11);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 23 + buf.getIntLE(offset + 15);\n         obj.oldPath = AssetPath.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 23 + buf.getIntLE(offset + 19);\n         int lastModificationUsernameLen = VarInt.peek(buf, varPos2);\n         if (lastModificationUsernameLen < 0) {\n            throw ProtocolException.negativeLength(\"LastModificationUsername\", lastModificationUsernameLen);\n         }\n\n         if (lastModificationUsernameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"LastModificationUsername\", lastModificationUsernameLen, 4096000);\n         }\n\n         obj.lastModificationUsername = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 23;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 11);\n         int pos0 = offset + 23 + fieldOffset0;\n         pos0 += AssetPath.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 15);\n         int pos1 = offset + 23 + fieldOffset1;\n         pos1 += AssetPath.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 19);\n         int pos2 = offset + 23 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 23) {\n         return ValidationResult.error(\"Buffer too small: expected at least 23 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 11);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int pos = offset + 23 + pathOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int oldPathOffset = buffer.getIntLE(offset + 15);\n            if (oldPathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for OldPath\");\n            }\n\n            int posx = offset + 23 + oldPathOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for OldPath\");\n            }\n\n            ValidationResult oldPathResult = AssetPath.validateStructure(buffer, posx);\n            if (!oldPathResult.isValid()) {\n               return ValidationResult.error(\"Invalid OldPath: \" + oldPathResult.error());\n            }\n\n            posx += AssetPath.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int lastModificationUsernameOffset = buffer.getIntLE(offset + 19);\n            if (lastModificationUsernameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for LastModificationUsername\");\n            }\n\n            int posxx = offset + 23 + lastModificationUsernameOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for LastModificationUsername\");\n            }\n\n            int lastModificationUsernameLen = VarInt.peek(buffer, posxx);\n            if (lastModificationUsernameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for LastModificationUsername\");\n            }\n\n            if (lastModificationUsernameLen > 4096000) {\n               return ValidationResult.error(\"LastModificationUsername exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += lastModificationUsernameLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading LastModificationUsername\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getLongLE, buf.getIntLE, AssetPath.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "FailureReply",
        "packetId": 300,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "message",
            "type": "FormattedMessage",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: FailureReply\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 300;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable FormattedMessage message;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static FailureReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      FailureReply obj = new FailureReply();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.message = FormattedMessage.deserialize(buf, pos);\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static FailureReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      FailureReply obj = new FailureReply();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.message = FormattedMessage.deserialize(buf, pos);\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            ValidationResult messageResult = FormattedMessage.validateStructure(buffer, pos);\n            if (!messageResult.isValid()) {\n               return ValidationResult.error(\"Invalid Message: \" + messageResult.error());\n            }\n\n            pos += FormattedMessage.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, FormattedMessage.deserialize, FormattedMessage.computeBytesConsumed\n// Types referenced: FormattedMessage\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SuccessReply",
        "packetId": 301,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "message",
            "type": "FormattedMessage",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SuccessReply\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 301;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable FormattedMessage message;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SuccessReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      SuccessReply obj = new SuccessReply();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.message = FormattedMessage.deserialize(buf, pos);\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SuccessReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      SuccessReply obj = new SuccessReply();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.message = FormattedMessage.deserialize(buf, pos);\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            ValidationResult messageResult = FormattedMessage.validateStructure(buffer, pos);\n            if (!messageResult.isValid()) {\n               return ValidationResult.error(\"Invalid Message: \" + messageResult.error());\n            }\n\n            pos += FormattedMessage.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, FormattedMessage.deserialize, FormattedMessage.computeBytesConsumed\n// Types referenced: FormattedMessage\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorInitialize",
        "packetId": 302,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [],
        "deserializeContext": "// Packet: AssetEditorInitialize\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 302;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorInitialize deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new AssetEditorInitialize();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorAuthorization",
        "packetId": 303,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "canUse",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorAuthorization\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 303;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean canUse;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorAuthorization deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAuthorization obj = new AssetEditorAuthorization();\n      obj.canUse = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorCapabilities",
        "packetId": 304,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "canDiscardAssets",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "canEditAssets",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "canCreateAssetPacks",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "canEditAssetPacks",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "canDeleteAssetPacks",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorCapabilities\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 304;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 5;\n\n// === FIELDS ===\n@Nonnull boolean canDiscardAssets;\n@Nonnull boolean canEditAssets;\n@Nonnull boolean canCreateAssetPacks;\n@Nonnull boolean canEditAssetPacks;\n@Nonnull boolean canDeleteAssetPacks;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorCapabilities deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorCapabilities obj = new AssetEditorCapabilities();\n      obj.canDiscardAssets = buf.getByte(offset + 0) != 0;\n      obj.canEditAssets = buf.getByte(offset + 1) != 0;\n      obj.canCreateAssetPacks = buf.getByte(offset + 2) != 0;\n      obj.canEditAssetPacks = buf.getByte(offset + 3) != 0;\n      obj.canDeleteAssetPacks = buf.getByte(offset + 4) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 5;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 5 ? ValidationResult.error(\"Buffer too small: expected at least 5 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorSetupSchemas",
        "packetId": 305,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "schemas",
            "type": "SchemaFile[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorSetupSchemas\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 305;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable SchemaFile[] schemas;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorSetupSchemas deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorSetupSchemas obj = new AssetEditorSetupSchemas();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int schemasCount = VarInt.peek(buf, pos);\n         if (schemasCount < 0) {\n            throw ProtocolException.negativeLength(\"Schemas\", schemasCount);\n         }\n\n         if (schemasCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Schemas\", schemasCount, 4096000);\n         }\n\n         int schemasVarLen = VarInt.size(schemasCount);\n         if ((long)(pos + schemasVarLen) + (long)schemasCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Schemas\", pos + schemasVarLen + schemasCount * 1, buf.readableBytes());\n         }\n\n         pos += schemasVarLen;\n         obj.schemas = new SchemaFile[schemasCount];\n\n         for (int i = 0; i < schemasCount; i++) {\n            obj.schemas[i] = SchemaFile.deserialize(buf, pos);\n            pos += SchemaFile.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorSetupSchemas deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorSetupSchemas obj = new AssetEditorSetupSchemas();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int schemasCount = VarInt.peek(buf, pos);\n         if (schemasCount < 0) {\n            throw ProtocolException.negativeLength(\"Schemas\", schemasCount);\n         }\n\n         if (schemasCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Schemas\", schemasCount, 4096000);\n         }\n\n         int schemasVarLen = VarInt.size(schemasCount);\n         if ((long)(pos + schemasVarLen) + (long)schemasCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Schemas\", pos + schemasVarLen + schemasCount * 1, buf.readableBytes());\n         }\n\n         pos += schemasVarLen;\n         obj.schemas = new SchemaFile[schemasCount];\n\n         for (int i = 0; i < schemasCount; i++) {\n            obj.schemas[i] = SchemaFile.deserialize(buf, pos);\n            pos += SchemaFile.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += SchemaFile.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int schemasCount = VarInt.peek(buffer, pos);\n            if (schemasCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Schemas\");\n            }\n\n            if (schemasCount > 4096000) {\n               return ValidationResult.error(\"Schemas exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < schemasCount; i++) {\n               ValidationResult structResult = SchemaFile.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid SchemaFile in Schemas[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += SchemaFile.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, SchemaFile.deserialize, SchemaFile.computeBytesConsumed\n// Types referenced: SchemaFile\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorSetupAssetTypes",
        "packetId": 306,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "assetTypes",
            "type": "AssetEditorAssetType[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorSetupAssetTypes\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 306;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable AssetEditorAssetType[] assetTypes;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorSetupAssetTypes deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorSetupAssetTypes obj = new AssetEditorSetupAssetTypes();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetTypesCount = VarInt.peek(buf, pos);\n         if (assetTypesCount < 0) {\n            throw ProtocolException.negativeLength(\"AssetTypes\", assetTypesCount);\n         }\n\n         if (assetTypesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"AssetTypes\", assetTypesCount, 4096000);\n         }\n\n         int assetTypesVarLen = VarInt.size(assetTypesCount);\n         if ((long)(pos + assetTypesVarLen) + (long)assetTypesCount * 3L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"AssetTypes\", pos + assetTypesVarLen + assetTypesCount * 3, buf.readableBytes());\n         }\n\n         pos += assetTypesVarLen;\n         obj.assetTypes = new AssetEditorAssetType[assetTypesCount];\n\n         for (int i = 0; i < assetTypesCount; i++) {\n            obj.assetTypes[i] = AssetEditorAssetType.deserialize(buf, pos);\n            pos += AssetEditorAssetType.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorSetupAssetTypes deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorSetupAssetTypes obj = new AssetEditorSetupAssetTypes();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetTypesCount = VarInt.peek(buf, pos);\n         if (assetTypesCount < 0) {\n            throw ProtocolException.negativeLength(\"AssetTypes\", assetTypesCount);\n         }\n\n         if (assetTypesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"AssetTypes\", assetTypesCount, 4096000);\n         }\n\n         int assetTypesVarLen = VarInt.size(assetTypesCount);\n         if ((long)(pos + assetTypesVarLen) + (long)assetTypesCount * 3L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"AssetTypes\", pos + assetTypesVarLen + assetTypesCount * 3, buf.readableBytes());\n         }\n\n         pos += assetTypesVarLen;\n         obj.assetTypes = new AssetEditorAssetType[assetTypesCount];\n\n         for (int i = 0; i < assetTypesCount; i++) {\n            obj.assetTypes[i] = AssetEditorAssetType.deserialize(buf, pos);\n            pos += AssetEditorAssetType.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += AssetEditorAssetType.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int assetTypesCount = VarInt.peek(buffer, pos);\n            if (assetTypesCount < 0) {\n               return ValidationResult.error(\"Invalid array count for AssetTypes\");\n            }\n\n            if (assetTypesCount > 4096000) {\n               return ValidationResult.error(\"AssetTypes exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < assetTypesCount; i++) {\n               ValidationResult structResult = AssetEditorAssetType.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid AssetEditorAssetType in AssetTypes[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += AssetEditorAssetType.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, AssetEditorAssetType.deserialize, AssetEditorAssetType.computeBytesConsumed\n// Types referenced: AssetEditorAssetType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorCreateDirectory",
        "packetId": 307,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorCreateDirectory\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 307;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 32768024;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPath path;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorCreateDirectory deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorCreateDirectory obj = new AssetEditorCreateDirectory();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorCreateDirectory deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorCreateDirectory obj = new AssetEditorCreateDirectory();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, AssetPath.computeBytesConsumed\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorDeleteDirectory",
        "packetId": 308,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorDeleteDirectory\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 308;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 32768024;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPath path;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorDeleteDirectory deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorDeleteDirectory obj = new AssetEditorDeleteDirectory();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorDeleteDirectory deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorDeleteDirectory obj = new AssetEditorDeleteDirectory();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, AssetPath.computeBytesConsumed\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorRenameDirectory",
        "packetId": 309,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "newPath",
            "type": "AssetPath",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorRenameDirectory\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 309;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 65536051;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPath path;\n@Nullable AssetPath newPath;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorRenameDirectory deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRenameDirectory obj = new AssetEditorRenameDirectory();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 5);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 9);\n         obj.newPath = AssetPath.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorRenameDirectory deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRenameDirectory obj = new AssetEditorRenameDirectory();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 5);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 9);\n         obj.newPath = AssetPath.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 13;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 5);\n         int pos0 = offset + 13 + fieldOffset0;\n         pos0 += AssetPath.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 9);\n         int pos1 = offset + 13 + fieldOffset1;\n         pos1 += AssetPath.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 5);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int pos = offset + 13 + pathOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int newPathOffset = buffer.getIntLE(offset + 9);\n            if (newPathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for NewPath\");\n            }\n\n            int posx = offset + 13 + newPathOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for NewPath\");\n            }\n\n            ValidationResult newPathResult = AssetPath.validateStructure(buffer, posx);\n            if (!newPathResult.isValid()) {\n               return ValidationResult.error(\"Invalid NewPath: \" + newPathResult.error());\n            }\n\n            posx += AssetPath.computeBytesConsumed(buffer, posx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorFetchAsset",
        "packetId": 310,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "isFromOpenedTab",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorFetchAsset\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 310;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 32768025;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPath path;\n@Nonnull boolean isFromOpenedTab;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorFetchAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorFetchAsset obj = new AssetEditorFetchAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      obj.isFromOpenedTab = buf.getByte(offset + 5) != 0;\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorFetchAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorFetchAsset obj = new AssetEditorFetchAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      obj.isFromOpenedTab = buf.getByte(offset + 5) != 0;\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, AssetPath.computeBytesConsumed\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorFetchJsonAssetWithParents",
        "packetId": 311,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "isFromOpenedTab",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorFetchJsonAssetWithParents\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 311;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 32768025;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPath path;\n@Nonnull boolean isFromOpenedTab;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorFetchJsonAssetWithParents deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorFetchJsonAssetWithParents obj = new AssetEditorFetchJsonAssetWithParents();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      obj.isFromOpenedTab = buf.getByte(offset + 5) != 0;\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorFetchJsonAssetWithParents deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorFetchJsonAssetWithParents obj = new AssetEditorFetchJsonAssetWithParents();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      obj.isFromOpenedTab = buf.getByte(offset + 5) != 0;\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, AssetPath.computeBytesConsumed\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorFetchAssetReply",
        "packetId": 312,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "contents",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorFetchAssetReply\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 312;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 4096010;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable byte[] contents;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorFetchAssetReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorFetchAssetReply obj = new AssetEditorFetchAssetReply();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int contentsCount = VarInt.peek(buf, pos);\n         if (contentsCount < 0) {\n            throw ProtocolException.negativeLength(\"Contents\", contentsCount);\n         }\n\n         if (contentsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Contents\", contentsCount, 4096000);\n         }\n\n         int contentsVarLen = VarInt.size(contentsCount);\n         if ((long)(pos + contentsVarLen) + (long)contentsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Contents\", pos + contentsVarLen + contentsCount * 1, buf.readableBytes());\n         }\n\n         pos += contentsVarLen;\n         obj.contents = new byte[contentsCount];\n\n         for (int i = 0; i < contentsCount; i++) {\n            obj.contents[i] = buf.getByte(pos + i * 1);\n         }\n\n         pos += contentsCount * 1;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            int contentsCount = VarInt.peek(buffer, pos);\n            if (contentsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Contents\");\n            }\n\n            if (contentsCount > 4096000) {\n               return ValidationResult.error(\"Contents exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += contentsCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Contents\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorFetchJsonAssetWithParentsReply",
        "packetId": 313,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "assets",
            "type": "Map<AssetPath, String>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorFetchJsonAssetWithParentsReply\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 313;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable Map<AssetPath, String> assets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorFetchJsonAssetWithParentsReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorFetchJsonAssetWithParentsReply obj = new AssetEditorFetchJsonAssetWithParentsReply();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int assetsCount = VarInt.peek(buf, pos);\n         if (assetsCount < 0) {\n            throw ProtocolException.negativeLength(\"Assets\", assetsCount);\n         }\n\n         if (assetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Assets\", assetsCount, 4096000);\n         }\n\n         pos += VarInt.size(assetsCount);\n         obj.assets = new HashMap<>(assetsCount);\n\n         for (int i = 0; i < assetsCount; i++) {\n            AssetPath key = AssetPath.deserialize(buf, pos);\n            pos += AssetPath.computeBytesConsumed(buf, pos);\n            int valLen = VarInt.peek(buf, pos);\n            if (valLen < 0) {\n               throw ProtocolException.negativeLength(\"val\", valLen);\n            }\n\n            if (valLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"val\", valLen, 4096000);\n            }\n\n            int valVarLen = VarInt.length(buf, pos);\n            String val = PacketIO.readVarString(buf, pos);\n            pos += valVarLen + valLen;\n            if (obj.assets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"assets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorFetchJsonAssetWithParentsReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorFetchJsonAssetWithParentsReply obj = new AssetEditorFetchJsonAssetWithParentsReply();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int assetsCount = VarInt.peek(buf, pos);\n         if (assetsCount < 0) {\n            throw ProtocolException.negativeLength(\"Assets\", assetsCount);\n         }\n\n         if (assetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Assets\", assetsCount, 4096000);\n         }\n\n         pos += VarInt.size(assetsCount);\n         obj.assets = new HashMap<>(assetsCount);\n\n         for (int i = 0; i < assetsCount; i++) {\n            AssetPath key = AssetPath.deserialize(buf, pos);\n            pos += AssetPath.computeBytesConsumed(buf, pos);\n            int valLen = VarInt.peek(buf, pos);\n            if (valLen < 0) {\n               throw ProtocolException.negativeLength(\"val\", valLen);\n            }\n\n            if (valLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"val\", valLen, 4096000);\n            }\n\n            int valVarLen = VarInt.length(buf, pos);\n            String val = PacketIO.readVarString(buf, pos);\n            pos += valVarLen + valLen;\n            if (obj.assets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"assets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += AssetPath.computeBytesConsumed(buf, pos);\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            int assetsCount = VarInt.peek(buffer, pos);\n            if (assetsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Assets\");\n            }\n\n            if (assetsCount > 4096000) {\n               return ValidationResult.error(\"Assets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < assetsCount; i++) {\n               pos += AssetPath.computeBytesConsumed(buffer, pos);\n               int valueLen = VarInt.peek(buffer, pos);\n               if (valueLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for value\");\n               }\n\n               if (valueLen > 4096000) {\n                  return ValidationResult.error(\"value exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += valueLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading value\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, AssetPath.deserialize, AssetPath.computeBytesConsumed, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, obj.assets.put, ProtocolException.duplicateKey\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorAssetPackSetup",
        "packetId": 314,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "packs",
            "type": "Map<String, AssetPackManifest>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorAssetPackSetup\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 314;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable Map<String, AssetPackManifest> packs;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorAssetPackSetup deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAssetPackSetup obj = new AssetEditorAssetPackSetup();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int packsCount = VarInt.peek(buf, pos);\n         if (packsCount < 0) {\n            throw ProtocolException.negativeLength(\"Packs\", packsCount);\n         }\n\n         if (packsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Packs\", packsCount, 4096000);\n         }\n\n         pos += VarInt.size(packsCount);\n         obj.packs = new HashMap<>(packsCount);\n\n         for (int i = 0; i < packsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            AssetPackManifest val = AssetPackManifest.deserialize(buf, pos);\n            pos += AssetPackManifest.computeBytesConsumed(buf, pos);\n            if (obj.packs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"packs\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorAssetPackSetup deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAssetPackSetup obj = new AssetEditorAssetPackSetup();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int packsCount = VarInt.peek(buf, pos);\n         if (packsCount < 0) {\n            throw ProtocolException.negativeLength(\"Packs\", packsCount);\n         }\n\n         if (packsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Packs\", packsCount, 4096000);\n         }\n\n         pos += VarInt.size(packsCount);\n         obj.packs = new HashMap<>(packsCount);\n\n         for (int i = 0; i < packsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            AssetPackManifest val = AssetPackManifest.deserialize(buf, pos);\n            pos += AssetPackManifest.computeBytesConsumed(buf, pos);\n            if (obj.packs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"packs\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            pos += AssetPackManifest.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int packsCount = VarInt.peek(buffer, pos);\n            if (packsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Packs\");\n            }\n\n            if (packsCount > 4096000) {\n               return ValidationResult.error(\"Packs exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < packsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += AssetPackManifest.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, AssetPackManifest.deserialize, AssetPackManifest.computeBytesConsumed, obj.packs.put, ProtocolException.duplicateKey\n// Types referenced: AssetPackManifest\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorUpdateAssetPack",
        "packetId": 315,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "id",
            "type": "String",
            "nullable": true
          },
          {
            "name": "manifest",
            "type": "AssetPackManifest",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorUpdateAssetPack\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 315;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable String id;\n@Nullable AssetPackManifest manifest;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorUpdateAssetPack deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUpdateAssetPack obj = new AssetEditorUpdateAssetPack();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int idLen = VarInt.peek(buf, varPos0);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         obj.id = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         obj.manifest = AssetPackManifest.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorUpdateAssetPack deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUpdateAssetPack obj = new AssetEditorUpdateAssetPack();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int idLen = VarInt.peek(buf, varPos0);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         obj.id = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         obj.manifest = AssetPackManifest.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         pos1 += AssetPackManifest.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int idOffset = buffer.getIntLE(offset + 1);\n            if (idOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Id\");\n            }\n\n            int pos = offset + 9 + idOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Id\");\n            }\n\n            int idLen = VarInt.peek(buffer, pos);\n            if (idLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Id\");\n            }\n\n            if (idLen > 4096000) {\n               return ValidationResult.error(\"Id exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += idLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Id\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int manifestOffset = buffer.getIntLE(offset + 5);\n            if (manifestOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Manifest\");\n            }\n\n            int posx = offset + 9 + manifestOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Manifest\");\n            }\n\n            ValidationResult manifestResult = AssetPackManifest.validateStructure(buffer, posx);\n            if (!manifestResult.isValid()) {\n               return ValidationResult.error(\"Invalid Manifest: \" + manifestResult.error());\n            }\n\n            posx += AssetPackManifest.computeBytesConsumed(buffer, posx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, AssetPackManifest.deserialize\n// Types referenced: AssetPackManifest\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorCreateAssetPack",
        "packetId": 316,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "manifest",
            "type": "AssetPackManifest",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorCreateAssetPack\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 316;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPackManifest manifest;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorCreateAssetPack deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorCreateAssetPack obj = new AssetEditorCreateAssetPack();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.manifest = AssetPackManifest.deserialize(buf, pos);\n         pos += AssetPackManifest.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorCreateAssetPack deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorCreateAssetPack obj = new AssetEditorCreateAssetPack();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.manifest = AssetPackManifest.deserialize(buf, pos);\n         pos += AssetPackManifest.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         pos += AssetPackManifest.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            ValidationResult manifestResult = AssetPackManifest.validateStructure(buffer, pos);\n            if (!manifestResult.isValid()) {\n               return ValidationResult.error(\"Invalid Manifest: \" + manifestResult.error());\n            }\n\n            pos += AssetPackManifest.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPackManifest.deserialize, AssetPackManifest.computeBytesConsumed\n// Types referenced: AssetPackManifest\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorDeleteAssetPack",
        "packetId": 317,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "id",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorDeleteAssetPack\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 317;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String id;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorDeleteAssetPack deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorDeleteAssetPack obj = new AssetEditorDeleteAssetPack();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int idLen = VarInt.peek(buf, pos);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         int idVarLen = VarInt.length(buf, pos);\n         obj.id = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += idVarLen + idLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int idLen = VarInt.peek(buffer, pos);\n            if (idLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Id\");\n            }\n\n            if (idLen > 4096000) {\n               return ValidationResult.error(\"Id exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += idLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Id\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorEnableAssetPack",
        "packetId": 318,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "id",
            "type": "String",
            "nullable": true
          },
          {
            "name": "enabled",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorEnableAssetPack\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 318;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 16384007;\n\n// === FIELDS ===\n@Nullable String id;\n@Nonnull boolean enabled;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorEnableAssetPack deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorEnableAssetPack obj = new AssetEditorEnableAssetPack();\n      byte nullBits = buf.getByte(offset);\n      obj.enabled = buf.getByte(offset + 1) != 0;\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int idLen = VarInt.peek(buf, pos);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         int idVarLen = VarInt.length(buf, pos);\n         obj.id = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += idVarLen + idLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int idLen = VarInt.peek(buffer, pos);\n            if (idLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Id\");\n            }\n\n            if (idLen > 4096000) {\n               return ValidationResult.error(\"Id exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += idLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Id\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorAssetListSetup",
        "packetId": 319,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "pack",
            "type": "String",
            "nullable": true
          },
          {
            "name": "isReadOnly",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "canBeDeleted",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "tree",
            "type": "AssetEditorFileTree",
            "nullable": false
          },
          {
            "name": "paths",
            "type": "AssetEditorFileEntry[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorAssetListSetup\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 319;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 12;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable String pack;\n@Nonnull boolean isReadOnly;\n@Nonnull boolean canBeDeleted;\n@Nonnull AssetEditorFileTree tree;\n@Nullable AssetEditorFileEntry[] paths;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorAssetListSetup deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAssetListSetup obj = new AssetEditorAssetListSetup();\n      byte nullBits = buf.getByte(offset);\n      obj.isReadOnly = buf.getByte(offset + 1) != 0;\n      obj.canBeDeleted = buf.getByte(offset + 2) != 0;\n      obj.tree = AssetEditorFileTree.fromValue(buf.getByte(offset + 3));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 12 + buf.getIntLE(offset + 4);\n         int packLen = VarInt.peek(buf, varPos0);\n         if (packLen < 0) {\n            throw ProtocolException.negativeLength(\"Pack\", packLen);\n         }\n\n         if (packLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Pack\", packLen, 4096000);\n         }\n\n         obj.pack = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 12 + buf.getIntLE(offset + 8);\n         int pathsCount = VarInt.peek(buf, varPos1);\n         if (pathsCount < 0) {\n            throw ProtocolException.negativeLength(\"Paths\", pathsCount);\n         }\n\n         if (pathsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Paths\", pathsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)pathsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Paths\", varPos1 + varIntLen + pathsCount * 2, buf.readableBytes());\n         }\n\n         obj.paths = new AssetEditorFileEntry[pathsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < pathsCount; i++) {\n            obj.paths[i] = AssetEditorFileEntry.deserialize(buf, elemPos);\n            elemPos += AssetEditorFileEntry.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorAssetListSetup deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAssetListSetup obj = new AssetEditorAssetListSetup();\n      byte nullBits = buf.getByte(offset);\n      obj.isReadOnly = buf.getByte(offset + 1) != 0;\n      obj.canBeDeleted = buf.getByte(offset + 2) != 0;\n      obj.tree = AssetEditorFileTree.fromValue(buf.getByte(offset + 3));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 12 + buf.getIntLE(offset + 4);\n         int packLen = VarInt.peek(buf, varPos0);\n         if (packLen < 0) {\n            throw ProtocolException.negativeLength(\"Pack\", packLen);\n         }\n\n         if (packLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Pack\", packLen, 4096000);\n         }\n\n         obj.pack = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 12 + buf.getIntLE(offset + 8);\n         int pathsCount = VarInt.peek(buf, varPos1);\n         if (pathsCount < 0) {\n            throw ProtocolException.negativeLength(\"Paths\", pathsCount);\n         }\n\n         if (pathsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Paths\", pathsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)pathsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Paths\", varPos1 + varIntLen + pathsCount * 2, buf.readableBytes());\n         }\n\n         obj.paths = new AssetEditorFileEntry[pathsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < pathsCount; i++) {\n            obj.paths[i] = AssetEditorFileEntry.deserialize(buf, elemPos);\n            elemPos += AssetEditorFileEntry.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 12;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 4);\n         int pos0 = offset + 12 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 8);\n         int pos1 = offset + 12 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos1 += AssetEditorFileEntry.computeBytesConsumed(buf, pos1);\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 12) {\n         return ValidationResult.error(\"Buffer too small: expected at least 12 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int packOffset = buffer.getIntLE(offset + 4);\n            if (packOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Pack\");\n            }\n\n            int pos = offset + 12 + packOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Pack\");\n            }\n\n            int packLen = VarInt.peek(buffer, pos);\n            if (packLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Pack\");\n            }\n\n            if (packLen > 4096000) {\n               return ValidationResult.error(\"Pack exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += packLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Pack\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int pathsOffset = buffer.getIntLE(offset + 8);\n            if (pathsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Paths\");\n            }\n\n            int posx = offset + 12 + pathsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Paths\");\n            }\n\n            int pathsCount = VarInt.peek(buffer, posx);\n            if (pathsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Paths\");\n            }\n\n            if (pathsCount > 4096000) {\n               return ValidationResult.error(\"Paths exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < pathsCount; i++) {\n               ValidationResult structResult = AssetEditorFileEntry.validateStructure(buffer, posx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid AssetEditorFileEntry in Paths[\" + i + \"]: \" + structResult.error());\n               }\n\n               posx += AssetEditorFileEntry.computeBytesConsumed(buffer, posx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, AssetEditorFileTree.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, AssetEditorFileEntry.deserialize, AssetEditorFileEntry.computeBytesConsumed\n// Types referenced: AssetEditorFileTree, AssetEditorFileEntry\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorAssetListUpdate",
        "packetId": 320,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "pack",
            "type": "String",
            "nullable": true
          },
          {
            "name": "additions",
            "type": "AssetEditorFileEntry[]",
            "nullable": true
          },
          {
            "name": "deletions",
            "type": "AssetEditorFileEntry[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorAssetListUpdate\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 320;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable String pack;\n@Nullable AssetEditorFileEntry[] additions;\n@Nullable AssetEditorFileEntry[] deletions;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorAssetListUpdate deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAssetListUpdate obj = new AssetEditorAssetListUpdate();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 1);\n         int packLen = VarInt.peek(buf, varPos0);\n         if (packLen < 0) {\n            throw ProtocolException.negativeLength(\"Pack\", packLen);\n         }\n\n         if (packLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Pack\", packLen, 4096000);\n         }\n\n         obj.pack = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 5);\n         int additionsCount = VarInt.peek(buf, varPos1);\n         if (additionsCount < 0) {\n            throw ProtocolException.negativeLength(\"Additions\", additionsCount);\n         }\n\n         if (additionsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Additions\", additionsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)additionsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Additions\", varPos1 + varIntLen + additionsCount * 2, buf.readableBytes());\n         }\n\n         obj.additions = new AssetEditorFileEntry[additionsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < additionsCount; i++) {\n            obj.additions[i] = AssetEditorFileEntry.deserialize(buf, elemPos);\n            elemPos += AssetEditorFileEntry.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 13 + buf.getIntLE(offset + 9);\n         int deletionsCount = VarInt.peek(buf, varPos2);\n         if (deletionsCount < 0) {\n            throw ProtocolException.negativeLength(\"Deletions\", deletionsCount);\n         }\n\n         if (deletionsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Deletions\", deletionsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)deletionsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Deletions\", varPos2 + varIntLen + deletionsCount * 2, buf.readableBytes());\n         }\n\n         obj.deletions = new AssetEditorFileEntry[deletionsCount];\n         int elemPos = varPos2 + varIntLen;\n\n         for (int i = 0; i < deletionsCount; i++) {\n            obj.deletions[i] = AssetEditorFileEntry.deserialize(buf, elemPos);\n            elemPos += AssetEditorFileEntry.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorAssetListUpdate deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAssetListUpdate obj = new AssetEditorAssetListUpdate();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 1);\n         int packLen = VarInt.peek(buf, varPos0);\n         if (packLen < 0) {\n            throw ProtocolException.negativeLength(\"Pack\", packLen);\n         }\n\n         if (packLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Pack\", packLen, 4096000);\n         }\n\n         obj.pack = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 5);\n         int additionsCount = VarInt.peek(buf, varPos1);\n         if (additionsCount < 0) {\n            throw ProtocolException.negativeLength(\"Additions\", additionsCount);\n         }\n\n         if (additionsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Additions\", additionsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)additionsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Additions\", varPos1 + varIntLen + additionsCount * 2, buf.readableBytes());\n         }\n\n         obj.additions = new AssetEditorFileEntry[additionsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < additionsCount; i++) {\n            obj.additions[i] = AssetEditorFileEntry.deserialize(buf, elemPos);\n            elemPos += AssetEditorFileEntry.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 13 + buf.getIntLE(offset + 9);\n         int deletionsCount = VarInt.peek(buf, varPos2);\n         if (deletionsCount < 0) {\n            throw ProtocolException.negativeLength(\"Deletions\", deletionsCount);\n         }\n\n         if (deletionsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Deletions\", deletionsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)deletionsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Deletions\", varPos2 + varIntLen + deletionsCount * 2, buf.readableBytes());\n         }\n\n         obj.deletions = new AssetEditorFileEntry[deletionsCount];\n         int elemPos = varPos2 + varIntLen;\n\n         for (int i = 0; i < deletionsCount; i++) {\n            obj.deletions[i] = AssetEditorFileEntry.deserialize(buf, elemPos);\n            elemPos += AssetEditorFileEntry.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 13;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 13 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 13 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos1 += AssetEditorFileEntry.computeBytesConsumed(buf, pos1);\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 9);\n         int pos2 = offset + 13 + fieldOffset2;\n         int arrLen = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos2 += AssetEditorFileEntry.computeBytesConsumed(buf, pos2);\n         }\n\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int packOffset = buffer.getIntLE(offset + 1);\n            if (packOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Pack\");\n            }\n\n            int pos = offset + 13 + packOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Pack\");\n            }\n\n            int packLen = VarInt.peek(buffer, pos);\n            if (packLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Pack\");\n            }\n\n            if (packLen > 4096000) {\n               return ValidationResult.error(\"Pack exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += packLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Pack\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int additionsOffset = buffer.getIntLE(offset + 5);\n            if (additionsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Additions\");\n            }\n\n            int posx = offset + 13 + additionsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Additions\");\n            }\n\n            int additionsCount = VarInt.peek(buffer, posx);\n            if (additionsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Additions\");\n            }\n\n            if (additionsCount > 4096000) {\n               return ValidationResult.error(\"Additions exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < additionsCount; i++) {\n               ValidationResult structResult = AssetEditorFileEntry.validateStructure(buffer, posx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid AssetEditorFileEntry in Additions[\" + i + \"]: \" + structResult.error());\n               }\n\n               posx += AssetEditorFileEntry.computeBytesConsumed(buffer, posx);\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int deletionsOffset = buffer.getIntLE(offset + 9);\n            if (deletionsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Deletions\");\n            }\n\n            int posxx = offset + 13 + deletionsOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Deletions\");\n            }\n\n            int deletionsCount = VarInt.peek(buffer, posxx);\n            if (deletionsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Deletions\");\n            }\n\n            if (deletionsCount > 4096000) {\n               return ValidationResult.error(\"Deletions exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n\n            for (int i = 0; i < deletionsCount; i++) {\n               ValidationResult structResult = AssetEditorFileEntry.validateStructure(buffer, posxx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid AssetEditorFileEntry in Deletions[\" + i + \"]: \" + structResult.error());\n               }\n\n               posxx += AssetEditorFileEntry.computeBytesConsumed(buffer, posxx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, AssetEditorFileEntry.deserialize, AssetEditorFileEntry.computeBytesConsumed\n// Types referenced: AssetEditorFileEntry\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorRequestChildrenList",
        "packetId": 321,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorRequestChildrenList\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 321;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 32768020;\n\n// === FIELDS ===\n@Nullable AssetPath path;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorRequestChildrenList deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRequestChildrenList obj = new AssetEditorRequestChildrenList();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorRequestChildrenList deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRequestChildrenList obj = new AssetEditorRequestChildrenList();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, AssetPath.deserialize, AssetPath.computeBytesConsumed\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorRequestChildrenListReply",
        "packetId": 322,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "childrenIds",
            "type": "String[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorRequestChildrenListReply\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 322;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable AssetPath path;\n@Nullable String[] childrenIds;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorRequestChildrenListReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRequestChildrenListReply obj = new AssetEditorRequestChildrenListReply();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int childrenIdsCount = VarInt.peek(buf, varPos1);\n         if (childrenIdsCount < 0) {\n            throw ProtocolException.negativeLength(\"ChildrenIds\", childrenIdsCount);\n         }\n\n         if (childrenIdsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"ChildrenIds\", childrenIdsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)childrenIdsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"ChildrenIds\", varPos1 + varIntLen + childrenIdsCount * 1, buf.readableBytes());\n         }\n\n         obj.childrenIds = new String[childrenIdsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < childrenIdsCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"childrenIds[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"childrenIds[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.childrenIds[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorRequestChildrenListReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRequestChildrenListReply obj = new AssetEditorRequestChildrenListReply();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int childrenIdsCount = VarInt.peek(buf, varPos1);\n         if (childrenIdsCount < 0) {\n            throw ProtocolException.negativeLength(\"ChildrenIds\", childrenIdsCount);\n         }\n\n         if (childrenIdsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"ChildrenIds\", childrenIdsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)childrenIdsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"ChildrenIds\", varPos1 + varIntLen + childrenIdsCount * 1, buf.readableBytes());\n         }\n\n         obj.childrenIds = new String[childrenIdsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < childrenIdsCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"childrenIds[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"childrenIds[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.childrenIds[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         pos0 += AssetPath.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos1);\n            pos1 += VarInt.length(buf, pos1) + sl;\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 1);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int pos = offset + 9 + pathOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int childrenIdsOffset = buffer.getIntLE(offset + 5);\n            if (childrenIdsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ChildrenIds\");\n            }\n\n            int posx = offset + 9 + childrenIdsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ChildrenIds\");\n            }\n\n            int childrenIdsCount = VarInt.peek(buffer, posx);\n            if (childrenIdsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for ChildrenIds\");\n            }\n\n            if (childrenIdsCount > 4096000) {\n               return ValidationResult.error(\"ChildrenIds exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < childrenIdsCount; i++) {\n               int strLen = VarInt.peek(buffer, posx);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in ChildrenIds\");\n               }\n\n               posx += VarInt.length(buffer, posx);\n               posx += strLen;\n               if (posx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in ChildrenIds\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorUpdateJsonAsset",
        "packetId": 323,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "assetType",
            "type": "String",
            "nullable": true
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "assetIndex",
            "type": "int",
            "nullable": false
          },
          {
            "name": "commands",
            "type": "JsonUpdateCommand[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorUpdateJsonAsset\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 323;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 21;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable String assetType;\n@Nullable AssetPath path;\n@Nonnull int assetIndex;\n@Nullable JsonUpdateCommand[] commands;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorUpdateJsonAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUpdateJsonAsset obj = new AssetEditorUpdateJsonAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      obj.assetIndex = buf.getIntLE(offset + 5);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 21 + buf.getIntLE(offset + 9);\n         int assetTypeLen = VarInt.peek(buf, varPos0);\n         if (assetTypeLen < 0) {\n            throw ProtocolException.negativeLength(\"AssetType\", assetTypeLen);\n         }\n\n         if (assetTypeLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"AssetType\", assetTypeLen, 4096000);\n         }\n\n         obj.assetType = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 21 + buf.getIntLE(offset + 13);\n         obj.path = AssetPath.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 21 + buf.getIntLE(offset + 17);\n         int commandsCount = VarInt.peek(buf, varPos2);\n         if (commandsCount < 0) {\n            throw ProtocolException.negativeLength(\"Commands\", commandsCount);\n         }\n\n         if (commandsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Commands\", commandsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)commandsCount * 7L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Commands\", varPos2 + varIntLen + commandsCount * 7, buf.readableBytes());\n         }\n\n         obj.commands = new JsonUpdateCommand[commandsCount];\n         int elemPos = varPos2 + varIntLen;\n\n         for (int i = 0; i < commandsCount; i++) {\n            obj.commands[i] = JsonUpdateCommand.deserialize(buf, elemPos);\n            elemPos += JsonUpdateCommand.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorUpdateJsonAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUpdateJsonAsset obj = new AssetEditorUpdateJsonAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      obj.assetIndex = buf.getIntLE(offset + 5);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 21 + buf.getIntLE(offset + 9);\n         int assetTypeLen = VarInt.peek(buf, varPos0);\n         if (assetTypeLen < 0) {\n            throw ProtocolException.negativeLength(\"AssetType\", assetTypeLen);\n         }\n\n         if (assetTypeLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"AssetType\", assetTypeLen, 4096000);\n         }\n\n         obj.assetType = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 21 + buf.getIntLE(offset + 13);\n         obj.path = AssetPath.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 21 + buf.getIntLE(offset + 17);\n         int commandsCount = VarInt.peek(buf, varPos2);\n         if (commandsCount < 0) {\n            throw ProtocolException.negativeLength(\"Commands\", commandsCount);\n         }\n\n         if (commandsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Commands\", commandsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)commandsCount * 7L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Commands\", varPos2 + varIntLen + commandsCount * 7, buf.readableBytes());\n         }\n\n         obj.commands = new JsonUpdateCommand[commandsCount];\n         int elemPos = varPos2 + varIntLen;\n\n         for (int i = 0; i < commandsCount; i++) {\n            obj.commands[i] = JsonUpdateCommand.deserialize(buf, elemPos);\n            elemPos += JsonUpdateCommand.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 21;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 9);\n         int pos0 = offset + 21 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 13);\n         int pos1 = offset + 21 + fieldOffset1;\n         pos1 += AssetPath.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 17);\n         int pos2 = offset + 21 + fieldOffset2;\n         int arrLen = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos2 += JsonUpdateCommand.computeBytesConsumed(buf, pos2);\n         }\n\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 21) {\n         return ValidationResult.error(\"Buffer too small: expected at least 21 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int assetTypeOffset = buffer.getIntLE(offset + 9);\n            if (assetTypeOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for AssetType\");\n            }\n\n            int pos = offset + 21 + assetTypeOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for AssetType\");\n            }\n\n            int assetTypeLen = VarInt.peek(buffer, pos);\n            if (assetTypeLen < 0) {\n               return ValidationResult.error(\"Invalid string length for AssetType\");\n            }\n\n            if (assetTypeLen > 4096000) {\n               return ValidationResult.error(\"AssetType exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += assetTypeLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading AssetType\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 13);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int posx = offset + 21 + pathOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, posx);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            posx += AssetPath.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int commandsOffset = buffer.getIntLE(offset + 17);\n            if (commandsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Commands\");\n            }\n\n            int posxx = offset + 21 + commandsOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Commands\");\n            }\n\n            int commandsCount = VarInt.peek(buffer, posxx);\n            if (commandsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Commands\");\n            }\n\n            if (commandsCount > 4096000) {\n               return ValidationResult.error(\"Commands exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n\n            for (int i = 0; i < commandsCount; i++) {\n               ValidationResult structResult = JsonUpdateCommand.validateStructure(buffer, posxx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid JsonUpdateCommand in Commands[\" + i + \"]: \" + structResult.error());\n               }\n\n               posxx += JsonUpdateCommand.computeBytesConsumed(buffer, posxx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, AssetPath.deserialize, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, JsonUpdateCommand.deserialize, JsonUpdateCommand.computeBytesConsumed\n// Types referenced: AssetPath, JsonUpdateCommand\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorUpdateAsset",
        "packetId": 324,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "assetType",
            "type": "String",
            "nullable": true
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "assetIndex",
            "type": "int",
            "nullable": false
          },
          {
            "name": "data",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorUpdateAsset\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 324;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 21;\npublic static final int MAX_SIZE = 53248050;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable String assetType;\n@Nullable AssetPath path;\n@Nonnull int assetIndex;\n@Nullable byte[] data;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorUpdateAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUpdateAsset obj = new AssetEditorUpdateAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      obj.assetIndex = buf.getIntLE(offset + 5);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 21 + buf.getIntLE(offset + 9);\n         int assetTypeLen = VarInt.peek(buf, varPos0);\n         if (assetTypeLen < 0) {\n            throw ProtocolException.negativeLength(\"AssetType\", assetTypeLen);\n         }\n\n         if (assetTypeLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"AssetType\", assetTypeLen, 4096000);\n         }\n\n         obj.assetType = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 21 + buf.getIntLE(offset + 13);\n         obj.path = AssetPath.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 21 + buf.getIntLE(offset + 17);\n         int dataCount = VarInt.peek(buf, varPos2);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)dataCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", varPos2 + varIntLen + dataCount * 1, buf.readableBytes());\n         }\n\n         obj.data = new byte[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getByte(varPos2 + varIntLen + i * 1);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorUpdateAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUpdateAsset obj = new AssetEditorUpdateAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      obj.assetIndex = buf.getIntLE(offset + 5);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 21 + buf.getIntLE(offset + 9);\n         int assetTypeLen = VarInt.peek(buf, varPos0);\n         if (assetTypeLen < 0) {\n            throw ProtocolException.negativeLength(\"AssetType\", assetTypeLen);\n         }\n\n         if (assetTypeLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"AssetType\", assetTypeLen, 4096000);\n         }\n\n         obj.assetType = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 21 + buf.getIntLE(offset + 13);\n         obj.path = AssetPath.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 21 + buf.getIntLE(offset + 17);\n         int dataCount = VarInt.peek(buf, varPos2);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)dataCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", varPos2 + varIntLen + dataCount * 1, buf.readableBytes());\n         }\n\n         obj.data = new byte[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getByte(varPos2 + varIntLen + i * 1);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 21;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 9);\n         int pos0 = offset + 21 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 13);\n         int pos1 = offset + 21 + fieldOffset1;\n         pos1 += AssetPath.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 17);\n         int pos2 = offset + 21 + fieldOffset2;\n         int arrLen = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + arrLen * 1;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 21) {\n         return ValidationResult.error(\"Buffer too small: expected at least 21 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int assetTypeOffset = buffer.getIntLE(offset + 9);\n            if (assetTypeOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for AssetType\");\n            }\n\n            int pos = offset + 21 + assetTypeOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for AssetType\");\n            }\n\n            int assetTypeLen = VarInt.peek(buffer, pos);\n            if (assetTypeLen < 0) {\n               return ValidationResult.error(\"Invalid string length for AssetType\");\n            }\n\n            if (assetTypeLen > 4096000) {\n               return ValidationResult.error(\"AssetType exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += assetTypeLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading AssetType\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 13);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int posx = offset + 21 + pathOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, posx);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            posx += AssetPath.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int dataOffset = buffer.getIntLE(offset + 17);\n            if (dataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Data\");\n            }\n\n            int posxx = offset + 21 + dataOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Data\");\n            }\n\n            int dataCount = VarInt.peek(buffer, posxx);\n            if (dataCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Data\");\n            }\n\n            if (dataCount > 4096000) {\n               return ValidationResult.error(\"Data exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += dataCount * 1;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Data\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, AssetPath.deserialize, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorJsonAssetUpdated",
        "packetId": 325,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "commands",
            "type": "JsonUpdateCommand[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorJsonAssetUpdated\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 325;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable AssetPath path;\n@Nullable JsonUpdateCommand[] commands;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorJsonAssetUpdated deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorJsonAssetUpdated obj = new AssetEditorJsonAssetUpdated();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int commandsCount = VarInt.peek(buf, varPos1);\n         if (commandsCount < 0) {\n            throw ProtocolException.negativeLength(\"Commands\", commandsCount);\n         }\n\n         if (commandsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Commands\", commandsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)commandsCount * 7L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Commands\", varPos1 + varIntLen + commandsCount * 7, buf.readableBytes());\n         }\n\n         obj.commands = new JsonUpdateCommand[commandsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < commandsCount; i++) {\n            obj.commands[i] = JsonUpdateCommand.deserialize(buf, elemPos);\n            elemPos += JsonUpdateCommand.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorJsonAssetUpdated deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorJsonAssetUpdated obj = new AssetEditorJsonAssetUpdated();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int commandsCount = VarInt.peek(buf, varPos1);\n         if (commandsCount < 0) {\n            throw ProtocolException.negativeLength(\"Commands\", commandsCount);\n         }\n\n         if (commandsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Commands\", commandsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)commandsCount * 7L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Commands\", varPos1 + varIntLen + commandsCount * 7, buf.readableBytes());\n         }\n\n         obj.commands = new JsonUpdateCommand[commandsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < commandsCount; i++) {\n            obj.commands[i] = JsonUpdateCommand.deserialize(buf, elemPos);\n            elemPos += JsonUpdateCommand.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         pos0 += AssetPath.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos1 += JsonUpdateCommand.computeBytesConsumed(buf, pos1);\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 1);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int pos = offset + 9 + pathOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int commandsOffset = buffer.getIntLE(offset + 5);\n            if (commandsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Commands\");\n            }\n\n            int posx = offset + 9 + commandsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Commands\");\n            }\n\n            int commandsCount = VarInt.peek(buffer, posx);\n            if (commandsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Commands\");\n            }\n\n            if (commandsCount > 4096000) {\n               return ValidationResult.error(\"Commands exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < commandsCount; i++) {\n               ValidationResult structResult = JsonUpdateCommand.validateStructure(buffer, posx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid JsonUpdateCommand in Commands[\" + i + \"]: \" + structResult.error());\n               }\n\n               posx += JsonUpdateCommand.computeBytesConsumed(buffer, posx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, JsonUpdateCommand.deserialize, JsonUpdateCommand.computeBytesConsumed\n// Types referenced: AssetPath, JsonUpdateCommand\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorAssetUpdated",
        "packetId": 326,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "data",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorAssetUpdated\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 326;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 36864033;\n\n// === FIELDS ===\n@Nullable AssetPath path;\n@Nullable byte[] data;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorAssetUpdated deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAssetUpdated obj = new AssetEditorAssetUpdated();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int dataCount = VarInt.peek(buf, varPos1);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)dataCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", varPos1 + varIntLen + dataCount * 1, buf.readableBytes());\n         }\n\n         obj.data = new byte[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getByte(varPos1 + varIntLen + i * 1);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorAssetUpdated deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorAssetUpdated obj = new AssetEditorAssetUpdated();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int dataCount = VarInt.peek(buf, varPos1);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)dataCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", varPos1 + varIntLen + dataCount * 1, buf.readableBytes());\n         }\n\n         obj.data = new byte[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getByte(varPos1 + varIntLen + i * 1);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         pos0 += AssetPath.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + arrLen * 1;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 1);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int pos = offset + 9 + pathOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int dataOffset = buffer.getIntLE(offset + 5);\n            if (dataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Data\");\n            }\n\n            int posx = offset + 9 + dataOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Data\");\n            }\n\n            int dataCount = VarInt.peek(buffer, posx);\n            if (dataCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Data\");\n            }\n\n            if (dataCount > 4096000) {\n               return ValidationResult.error(\"Data exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += dataCount * 1;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Data\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorCreateAsset",
        "packetId": 327,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "data",
            "type": "byte[]",
            "nullable": true
          },
          {
            "name": "rebuildCaches",
            "type": "AssetEditorRebuildCaches",
            "nullable": true
          },
          {
            "name": "buttonId",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorCreateAsset\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 327;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 10;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 22;\npublic static final int MAX_SIZE = 53248051;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPath path;\n@Nullable byte[] data;\n@Nullable AssetEditorRebuildCaches rebuildCaches;\n@Nullable String buttonId;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorCreateAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorCreateAsset obj = new AssetEditorCreateAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      if ((nullBits & 4) != 0) {\n         obj.rebuildCaches = AssetEditorRebuildCaches.deserialize(buf, offset + 5);\n      }\n\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 22 + buf.getIntLE(offset + 10);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 22 + buf.getIntLE(offset + 14);\n         int dataCount = VarInt.peek(buf, varPos1);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)dataCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", varPos1 + varIntLen + dataCount * 1, buf.readableBytes());\n         }\n\n         obj.data = new byte[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getByte(varPos1 + varIntLen + i * 1);\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos2 = offset + 22 + buf.getIntLE(offset + 18);\n         int buttonIdLen = VarInt.peek(buf, varPos2);\n         if (buttonIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ButtonId\", buttonIdLen);\n         }\n\n         if (buttonIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ButtonId\", buttonIdLen, 4096000);\n         }\n\n         obj.buttonId = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorCreateAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorCreateAsset obj = new AssetEditorCreateAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      if ((nullBits & 4) != 0) {\n         obj.rebuildCaches = AssetEditorRebuildCaches.deserialize(buf, offset + 5);\n      }\n\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 22 + buf.getIntLE(offset + 10);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 22 + buf.getIntLE(offset + 14);\n         int dataCount = VarInt.peek(buf, varPos1);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)dataCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", varPos1 + varIntLen + dataCount * 1, buf.readableBytes());\n         }\n\n         obj.data = new byte[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getByte(varPos1 + varIntLen + i * 1);\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos2 = offset + 22 + buf.getIntLE(offset + 18);\n         int buttonIdLen = VarInt.peek(buf, varPos2);\n         if (buttonIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ButtonId\", buttonIdLen);\n         }\n\n         if (buttonIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ButtonId\", buttonIdLen, 4096000);\n         }\n\n         obj.buttonId = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 22;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 10);\n         int pos0 = offset + 22 + fieldOffset0;\n         pos0 += AssetPath.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 14);\n         int pos1 = offset + 22 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + arrLen * 1;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 18);\n         int pos2 = offset + 22 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 22) {\n         return ValidationResult.error(\"Buffer too small: expected at least 22 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 10);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int pos = offset + 22 + pathOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int dataOffset = buffer.getIntLE(offset + 14);\n            if (dataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Data\");\n            }\n\n            int posx = offset + 22 + dataOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Data\");\n            }\n\n            int dataCount = VarInt.peek(buffer, posx);\n            if (dataCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Data\");\n            }\n\n            if (dataCount > 4096000) {\n               return ValidationResult.error(\"Data exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += dataCount * 1;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Data\");\n            }\n         }\n\n         if ((nullBits & 8) != 0) {\n            int buttonIdOffset = buffer.getIntLE(offset + 18);\n            if (buttonIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ButtonId\");\n            }\n\n            int posxx = offset + 22 + buttonIdOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ButtonId\");\n            }\n\n            int buttonIdLen = VarInt.peek(buffer, posxx);\n            if (buttonIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ButtonId\");\n            }\n\n            if (buttonIdLen > 4096000) {\n               return ValidationResult.error(\"ButtonId exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += buttonIdLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ButtonId\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetEditorRebuildCaches.deserialize, AssetPath.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: AssetEditorRebuildCaches, AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorRenameAsset",
        "packetId": 328,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "newPath",
            "type": "AssetPath",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorRenameAsset\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 328;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 65536051;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPath path;\n@Nullable AssetPath newPath;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorRenameAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRenameAsset obj = new AssetEditorRenameAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 5);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 9);\n         obj.newPath = AssetPath.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorRenameAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRenameAsset obj = new AssetEditorRenameAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 5);\n         obj.path = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 9);\n         obj.newPath = AssetPath.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 13;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 5);\n         int pos0 = offset + 13 + fieldOffset0;\n         pos0 += AssetPath.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 9);\n         int pos1 = offset + 13 + fieldOffset1;\n         pos1 += AssetPath.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int pathOffset = buffer.getIntLE(offset + 5);\n            if (pathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Path\");\n            }\n\n            int pos = offset + 13 + pathOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Path\");\n            }\n\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int newPathOffset = buffer.getIntLE(offset + 9);\n            if (newPathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for NewPath\");\n            }\n\n            int posx = offset + 13 + newPathOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for NewPath\");\n            }\n\n            ValidationResult newPathResult = AssetPath.validateStructure(buffer, posx);\n            if (!newPathResult.isValid()) {\n               return ValidationResult.error(\"Invalid NewPath: \" + newPathResult.error());\n            }\n\n            posx += AssetPath.computeBytesConsumed(buffer, posx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorDeleteAsset",
        "packetId": 329,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorDeleteAsset\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 329;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 32768024;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPath path;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorDeleteAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorDeleteAsset obj = new AssetEditorDeleteAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorDeleteAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorDeleteAsset obj = new AssetEditorDeleteAsset();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, AssetPath.computeBytesConsumed\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorDiscardChanges",
        "packetId": 330,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "assets",
            "type": "TimestampedAssetReference[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorDiscardChanges\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 330;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable TimestampedAssetReference[] assets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorDiscardChanges deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorDiscardChanges obj = new AssetEditorDiscardChanges();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetsCount = VarInt.peek(buf, pos);\n         if (assetsCount < 0) {\n            throw ProtocolException.negativeLength(\"Assets\", assetsCount);\n         }\n\n         if (assetsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Assets\", assetsCount, 4096000);\n         }\n\n         int assetsVarLen = VarInt.size(assetsCount);\n         if ((long)(pos + assetsVarLen) + (long)assetsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Assets\", pos + assetsVarLen + assetsCount * 1, buf.readableBytes());\n         }\n\n         pos += assetsVarLen;\n         obj.assets = new TimestampedAssetReference[assetsCount];\n\n         for (int i = 0; i < assetsCount; i++) {\n            obj.assets[i] = TimestampedAssetReference.deserialize(buf, pos);\n            pos += TimestampedAssetReference.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorDiscardChanges deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorDiscardChanges obj = new AssetEditorDiscardChanges();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetsCount = VarInt.peek(buf, pos);\n         if (assetsCount < 0) {\n            throw ProtocolException.negativeLength(\"Assets\", assetsCount);\n         }\n\n         if (assetsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Assets\", assetsCount, 4096000);\n         }\n\n         int assetsVarLen = VarInt.size(assetsCount);\n         if ((long)(pos + assetsVarLen) + (long)assetsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Assets\", pos + assetsVarLen + assetsCount * 1, buf.readableBytes());\n         }\n\n         pos += assetsVarLen;\n         obj.assets = new TimestampedAssetReference[assetsCount];\n\n         for (int i = 0; i < assetsCount; i++) {\n            obj.assets[i] = TimestampedAssetReference.deserialize(buf, pos);\n            pos += TimestampedAssetReference.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += TimestampedAssetReference.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int assetsCount = VarInt.peek(buffer, pos);\n            if (assetsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Assets\");\n            }\n\n            if (assetsCount > 4096000) {\n               return ValidationResult.error(\"Assets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < assetsCount; i++) {\n               ValidationResult structResult = TimestampedAssetReference.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid TimestampedAssetReference in Assets[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += TimestampedAssetReference.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, TimestampedAssetReference.deserialize, TimestampedAssetReference.computeBytesConsumed\n// Types referenced: TimestampedAssetReference\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorFetchAutoCompleteData",
        "packetId": 331,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "dataset",
            "type": "String",
            "nullable": true
          },
          {
            "name": "query",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorFetchAutoCompleteData\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 331;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 32768023;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable String dataset;\n@Nullable String query;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorFetchAutoCompleteData deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorFetchAutoCompleteData obj = new AssetEditorFetchAutoCompleteData();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 5);\n         int datasetLen = VarInt.peek(buf, varPos0);\n         if (datasetLen < 0) {\n            throw ProtocolException.negativeLength(\"Dataset\", datasetLen);\n         }\n\n         if (datasetLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Dataset\", datasetLen, 4096000);\n         }\n\n         obj.dataset = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 9);\n         int queryLen = VarInt.peek(buf, varPos1);\n         if (queryLen < 0) {\n            throw ProtocolException.negativeLength(\"Query\", queryLen);\n         }\n\n         if (queryLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Query\", queryLen, 4096000);\n         }\n\n         obj.query = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 13;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 5);\n         int pos0 = offset + 13 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 9);\n         int pos1 = offset + 13 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int datasetOffset = buffer.getIntLE(offset + 5);\n            if (datasetOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Dataset\");\n            }\n\n            int pos = offset + 13 + datasetOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Dataset\");\n            }\n\n            int datasetLen = VarInt.peek(buffer, pos);\n            if (datasetLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Dataset\");\n            }\n\n            if (datasetLen > 4096000) {\n               return ValidationResult.error(\"Dataset exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += datasetLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Dataset\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int queryOffset = buffer.getIntLE(offset + 9);\n            if (queryOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Query\");\n            }\n\n            int posx = offset + 13 + queryOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Query\");\n            }\n\n            int queryLen = VarInt.peek(buffer, posx);\n            if (queryLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Query\");\n            }\n\n            if (queryLen > 4096000) {\n               return ValidationResult.error(\"Query exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += queryLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Query\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorFetchAutoCompleteDataReply",
        "packetId": 332,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "results",
            "type": "String[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorFetchAutoCompleteDataReply\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 332;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable String[] results;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorFetchAutoCompleteDataReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorFetchAutoCompleteDataReply obj = new AssetEditorFetchAutoCompleteDataReply();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int resultsCount = VarInt.peek(buf, pos);\n         if (resultsCount < 0) {\n            throw ProtocolException.negativeLength(\"Results\", resultsCount);\n         }\n\n         if (resultsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Results\", resultsCount, 4096000);\n         }\n\n         int resultsVarLen = VarInt.size(resultsCount);\n         if ((long)(pos + resultsVarLen) + (long)resultsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Results\", pos + resultsVarLen + resultsCount * 1, buf.readableBytes());\n         }\n\n         pos += resultsVarLen;\n         obj.results = new String[resultsCount];\n\n         for (int i = 0; i < resultsCount; i++) {\n            int strLen = VarInt.peek(buf, pos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"results[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"results[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, pos);\n            obj.results[i] = PacketIO.readVarString(buf, pos);\n            pos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            int resultsCount = VarInt.peek(buffer, pos);\n            if (resultsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Results\");\n            }\n\n            if (resultsCount > 4096000) {\n               return ValidationResult.error(\"Results exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < resultsCount; i++) {\n               int strLen = VarInt.peek(buffer, pos);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in Results\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += strLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in Results\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorRequestDataset",
        "packetId": 333,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "name",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorRequestDataset\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 333;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String name;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorRequestDataset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRequestDataset obj = new AssetEditorRequestDataset();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int nameLen = VarInt.peek(buf, pos);\n         if (nameLen < 0) {\n            throw ProtocolException.negativeLength(\"Name\", nameLen);\n         }\n\n         if (nameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Name\", nameLen, 4096000);\n         }\n\n         int nameVarLen = VarInt.length(buf, pos);\n         obj.name = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += nameVarLen + nameLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int nameLen = VarInt.peek(buffer, pos);\n            if (nameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Name\");\n            }\n\n            if (nameLen > 4096000) {\n               return ValidationResult.error(\"Name exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += nameLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Name\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorRequestDatasetReply",
        "packetId": 334,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "name",
            "type": "String",
            "nullable": true
          },
          {
            "name": "ids",
            "type": "String[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorRequestDatasetReply\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 334;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable String name;\n@Nullable String[] ids;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorRequestDatasetReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRequestDatasetReply obj = new AssetEditorRequestDatasetReply();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int nameLen = VarInt.peek(buf, varPos0);\n         if (nameLen < 0) {\n            throw ProtocolException.negativeLength(\"Name\", nameLen);\n         }\n\n         if (nameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Name\", nameLen, 4096000);\n         }\n\n         obj.name = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int idsCount = VarInt.peek(buf, varPos1);\n         if (idsCount < 0) {\n            throw ProtocolException.negativeLength(\"Ids\", idsCount);\n         }\n\n         if (idsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Ids\", idsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)idsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Ids\", varPos1 + varIntLen + idsCount * 1, buf.readableBytes());\n         }\n\n         obj.ids = new String[idsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < idsCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"ids[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"ids[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.ids[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos1);\n            pos1 += VarInt.length(buf, pos1) + sl;\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int nameOffset = buffer.getIntLE(offset + 1);\n            if (nameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Name\");\n            }\n\n            int pos = offset + 9 + nameOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Name\");\n            }\n\n            int nameLen = VarInt.peek(buffer, pos);\n            if (nameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Name\");\n            }\n\n            if (nameLen > 4096000) {\n               return ValidationResult.error(\"Name exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += nameLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Name\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int idsOffset = buffer.getIntLE(offset + 5);\n            if (idsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Ids\");\n            }\n\n            int posx = offset + 9 + idsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Ids\");\n            }\n\n            int idsCount = VarInt.peek(buffer, posx);\n            if (idsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Ids\");\n            }\n\n            if (idsCount > 4096000) {\n               return ValidationResult.error(\"Ids exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < idsCount; i++) {\n               int strLen = VarInt.peek(buffer, posx);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in Ids\");\n               }\n\n               posx += VarInt.length(buffer, posx);\n               posx += strLen;\n               if (posx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in Ids\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorActivateButton",
        "packetId": 335,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "buttonId",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorActivateButton\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 335;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String buttonId;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorActivateButton deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorActivateButton obj = new AssetEditorActivateButton();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int buttonIdLen = VarInt.peek(buf, pos);\n         if (buttonIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ButtonId\", buttonIdLen);\n         }\n\n         if (buttonIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ButtonId\", buttonIdLen, 4096000);\n         }\n\n         int buttonIdVarLen = VarInt.length(buf, pos);\n         obj.buttonId = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += buttonIdVarLen + buttonIdLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int buttonIdLen = VarInt.peek(buffer, pos);\n            if (buttonIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ButtonId\");\n            }\n\n            if (buttonIdLen > 4096000) {\n               return ValidationResult.error(\"ButtonId exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += buttonIdLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ButtonId\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorSelectAsset",
        "packetId": 336,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorSelectAsset\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 336;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 32768020;\n\n// === FIELDS ===\n@Nullable AssetPath path;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorSelectAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorSelectAsset obj = new AssetEditorSelectAsset();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorSelectAsset deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorSelectAsset obj = new AssetEditorSelectAsset();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, AssetPath.deserialize, AssetPath.computeBytesConsumed\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorPopupNotification",
        "packetId": 337,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "type",
            "type": "AssetEditorPopupNotificationType",
            "nullable": false
          },
          {
            "name": "message",
            "type": "FormattedMessage",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorPopupNotification\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 337;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull AssetEditorPopupNotificationType type;\n@Nullable FormattedMessage message;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorPopupNotification deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorPopupNotification obj = new AssetEditorPopupNotification();\n      byte nullBits = buf.getByte(offset);\n      obj.type = AssetEditorPopupNotificationType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         obj.message = FormattedMessage.deserialize(buf, pos);\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorPopupNotification deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorPopupNotification obj = new AssetEditorPopupNotification();\n      byte nullBits = buf.getByte(offset);\n      obj.type = AssetEditorPopupNotificationType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         obj.message = FormattedMessage.deserialize(buf, pos);\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            ValidationResult messageResult = FormattedMessage.validateStructure(buffer, pos);\n            if (!messageResult.isValid()) {\n               return ValidationResult.error(\"Invalid Message: \" + messageResult.error());\n            }\n\n            pos += FormattedMessage.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, AssetEditorPopupNotificationType.fromValue, FormattedMessage.deserialize, FormattedMessage.computeBytesConsumed\n// Types referenced: AssetEditorPopupNotificationType, FormattedMessage\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorFetchLastModifiedAssets",
        "packetId": 338,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [],
        "deserializeContext": "// Packet: AssetEditorFetchLastModifiedAssets\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 338;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorFetchLastModifiedAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new AssetEditorFetchLastModifiedAssets();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorLastModifiedAssets",
        "packetId": 339,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "assets",
            "type": "AssetInfo[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorLastModifiedAssets\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 339;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable AssetInfo[] assets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorLastModifiedAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorLastModifiedAssets obj = new AssetEditorLastModifiedAssets();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetsCount = VarInt.peek(buf, pos);\n         if (assetsCount < 0) {\n            throw ProtocolException.negativeLength(\"Assets\", assetsCount);\n         }\n\n         if (assetsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Assets\", assetsCount, 4096000);\n         }\n\n         int assetsVarLen = VarInt.size(assetsCount);\n         if ((long)(pos + assetsVarLen) + (long)assetsCount * 11L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Assets\", pos + assetsVarLen + assetsCount * 11, buf.readableBytes());\n         }\n\n         pos += assetsVarLen;\n         obj.assets = new AssetInfo[assetsCount];\n\n         for (int i = 0; i < assetsCount; i++) {\n            obj.assets[i] = AssetInfo.deserialize(buf, pos);\n            pos += AssetInfo.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorLastModifiedAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorLastModifiedAssets obj = new AssetEditorLastModifiedAssets();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetsCount = VarInt.peek(buf, pos);\n         if (assetsCount < 0) {\n            throw ProtocolException.negativeLength(\"Assets\", assetsCount);\n         }\n\n         if (assetsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Assets\", assetsCount, 4096000);\n         }\n\n         int assetsVarLen = VarInt.size(assetsCount);\n         if ((long)(pos + assetsVarLen) + (long)assetsCount * 11L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Assets\", pos + assetsVarLen + assetsCount * 11, buf.readableBytes());\n         }\n\n         pos += assetsVarLen;\n         obj.assets = new AssetInfo[assetsCount];\n\n         for (int i = 0; i < assetsCount; i++) {\n            obj.assets[i] = AssetInfo.deserialize(buf, pos);\n            pos += AssetInfo.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += AssetInfo.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int assetsCount = VarInt.peek(buffer, pos);\n            if (assetsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Assets\");\n            }\n\n            if (assetsCount > 4096000) {\n               return ValidationResult.error(\"Assets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < assetsCount; i++) {\n               ValidationResult structResult = AssetInfo.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid AssetInfo in Assets[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += AssetInfo.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, AssetInfo.deserialize, AssetInfo.computeBytesConsumed\n// Types referenced: AssetInfo\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorModifiedAssetsCount",
        "packetId": 340,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "count",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorModifiedAssetsCount\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 340;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int count;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorModifiedAssetsCount deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorModifiedAssetsCount obj = new AssetEditorModifiedAssetsCount();\n      obj.count = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorSubscribeModifiedAssetsChanges",
        "packetId": 341,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "subscribe",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorSubscribeModifiedAssetsChanges\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 341;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean subscribe;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorSubscribeModifiedAssetsChanges deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorSubscribeModifiedAssetsChanges obj = new AssetEditorSubscribeModifiedAssetsChanges();\n      obj.subscribe = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorExportAssets",
        "packetId": 342,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "paths",
            "type": "AssetPath[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorExportAssets\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 342;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable AssetPath[] paths;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorExportAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorExportAssets obj = new AssetEditorExportAssets();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int pathsCount = VarInt.peek(buf, pos);\n         if (pathsCount < 0) {\n            throw ProtocolException.negativeLength(\"Paths\", pathsCount);\n         }\n\n         if (pathsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Paths\", pathsCount, 4096000);\n         }\n\n         int pathsVarLen = VarInt.size(pathsCount);\n         if ((long)(pos + pathsVarLen) + (long)pathsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Paths\", pos + pathsVarLen + pathsCount * 1, buf.readableBytes());\n         }\n\n         pos += pathsVarLen;\n         obj.paths = new AssetPath[pathsCount];\n\n         for (int i = 0; i < pathsCount; i++) {\n            obj.paths[i] = AssetPath.deserialize(buf, pos);\n            pos += AssetPath.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorExportAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorExportAssets obj = new AssetEditorExportAssets();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int pathsCount = VarInt.peek(buf, pos);\n         if (pathsCount < 0) {\n            throw ProtocolException.negativeLength(\"Paths\", pathsCount);\n         }\n\n         if (pathsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Paths\", pathsCount, 4096000);\n         }\n\n         int pathsVarLen = VarInt.size(pathsCount);\n         if ((long)(pos + pathsVarLen) + (long)pathsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Paths\", pos + pathsVarLen + pathsCount * 1, buf.readableBytes());\n         }\n\n         pos += pathsVarLen;\n         obj.paths = new AssetPath[pathsCount];\n\n         for (int i = 0; i < pathsCount; i++) {\n            obj.paths[i] = AssetPath.deserialize(buf, pos);\n            pos += AssetPath.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += AssetPath.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int pathsCount = VarInt.peek(buffer, pos);\n            if (pathsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Paths\");\n            }\n\n            if (pathsCount > 4096000) {\n               return ValidationResult.error(\"Paths exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < pathsCount; i++) {\n               ValidationResult structResult = AssetPath.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid AssetPath in Paths[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += AssetPath.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, AssetPath.deserialize, AssetPath.computeBytesConsumed\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorExportAssetInitialize",
        "packetId": 343,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "asset",
            "type": "AssetEditorAsset",
            "nullable": true
          },
          {
            "name": "oldPath",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "size",
            "type": "int",
            "nullable": false
          },
          {
            "name": "failed",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorExportAssetInitialize\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 343;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 14;\npublic static final int MAX_SIZE = 81920066;\n\n// === FIELDS ===\n@Nullable AssetEditorAsset asset;\n@Nullable AssetPath oldPath;\n@Nonnull int size;\n@Nonnull boolean failed;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorExportAssetInitialize deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorExportAssetInitialize obj = new AssetEditorExportAssetInitialize();\n      byte nullBits = buf.getByte(offset);\n      obj.size = buf.getIntLE(offset + 1);\n      obj.failed = buf.getByte(offset + 5) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 14 + buf.getIntLE(offset + 6);\n         obj.asset = AssetEditorAsset.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 14 + buf.getIntLE(offset + 10);\n         obj.oldPath = AssetPath.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorExportAssetInitialize deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorExportAssetInitialize obj = new AssetEditorExportAssetInitialize();\n      byte nullBits = buf.getByte(offset);\n      obj.size = buf.getIntLE(offset + 1);\n      obj.failed = buf.getByte(offset + 5) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 14 + buf.getIntLE(offset + 6);\n         obj.asset = AssetEditorAsset.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 14 + buf.getIntLE(offset + 10);\n         obj.oldPath = AssetPath.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 14;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 6);\n         int pos0 = offset + 14 + fieldOffset0;\n         pos0 += AssetEditorAsset.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 10);\n         int pos1 = offset + 14 + fieldOffset1;\n         pos1 += AssetPath.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 14) {\n         return ValidationResult.error(\"Buffer too small: expected at least 14 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int assetOffset = buffer.getIntLE(offset + 6);\n            if (assetOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Asset\");\n            }\n\n            int pos = offset + 14 + assetOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Asset\");\n            }\n\n            ValidationResult assetResult = AssetEditorAsset.validateStructure(buffer, pos);\n            if (!assetResult.isValid()) {\n               return ValidationResult.error(\"Invalid Asset: \" + assetResult.error());\n            }\n\n            pos += AssetEditorAsset.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int oldPathOffset = buffer.getIntLE(offset + 10);\n            if (oldPathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for OldPath\");\n            }\n\n            int posx = offset + 14 + oldPathOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for OldPath\");\n            }\n\n            ValidationResult oldPathResult = AssetPath.validateStructure(buffer, posx);\n            if (!oldPathResult.isValid()) {\n               return ValidationResult.error(\"Invalid OldPath: \" + oldPathResult.error());\n            }\n\n            posx += AssetPath.computeBytesConsumed(buffer, posx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetEditorAsset.deserialize, AssetPath.deserialize\n// Types referenced: AssetEditorAsset, AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorExportAssetPart",
        "packetId": 344,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "part",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorExportAssetPart\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 344;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 4096006;\n\n// === FIELDS ===\n@Nullable byte[] part;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorExportAssetPart deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorExportAssetPart obj = new AssetEditorExportAssetPart();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int partCount = VarInt.peek(buf, pos);\n         if (partCount < 0) {\n            throw ProtocolException.negativeLength(\"Part\", partCount);\n         }\n\n         if (partCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Part\", partCount, 4096000);\n         }\n\n         int partVarLen = VarInt.size(partCount);\n         if ((long)(pos + partVarLen) + (long)partCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Part\", pos + partVarLen + partCount * 1, buf.readableBytes());\n         }\n\n         pos += partVarLen;\n         obj.part = new byte[partCount];\n\n         for (int i = 0; i < partCount; i++) {\n            obj.part[i] = buf.getByte(pos + i * 1);\n         }\n\n         pos += partCount * 1;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int partCount = VarInt.peek(buffer, pos);\n            if (partCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Part\");\n            }\n\n            if (partCount > 4096000) {\n               return ValidationResult.error(\"Part exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += partCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Part\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorExportAssetFinalize",
        "packetId": 345,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [],
        "deserializeContext": "// Packet: AssetEditorExportAssetFinalize\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 345;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorExportAssetFinalize deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new AssetEditorExportAssetFinalize();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorExportDeleteAssets",
        "packetId": 346,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "asset",
            "type": "AssetEditorAsset[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorExportDeleteAssets\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 346;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable AssetEditorAsset[] asset;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorExportDeleteAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorExportDeleteAssets obj = new AssetEditorExportDeleteAssets();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetCount = VarInt.peek(buf, pos);\n         if (assetCount < 0) {\n            throw ProtocolException.negativeLength(\"Asset\", assetCount);\n         }\n\n         if (assetCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Asset\", assetCount, 4096000);\n         }\n\n         int assetVarLen = VarInt.size(assetCount);\n         if ((long)(pos + assetVarLen) + (long)assetCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Asset\", pos + assetVarLen + assetCount * 1, buf.readableBytes());\n         }\n\n         pos += assetVarLen;\n         obj.asset = new AssetEditorAsset[assetCount];\n\n         for (int i = 0; i < assetCount; i++) {\n            obj.asset[i] = AssetEditorAsset.deserialize(buf, pos);\n            pos += AssetEditorAsset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorExportDeleteAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorExportDeleteAssets obj = new AssetEditorExportDeleteAssets();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetCount = VarInt.peek(buf, pos);\n         if (assetCount < 0) {\n            throw ProtocolException.negativeLength(\"Asset\", assetCount);\n         }\n\n         if (assetCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Asset\", assetCount, 4096000);\n         }\n\n         int assetVarLen = VarInt.size(assetCount);\n         if ((long)(pos + assetVarLen) + (long)assetCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Asset\", pos + assetVarLen + assetCount * 1, buf.readableBytes());\n         }\n\n         pos += assetVarLen;\n         obj.asset = new AssetEditorAsset[assetCount];\n\n         for (int i = 0; i < assetCount; i++) {\n            obj.asset[i] = AssetEditorAsset.deserialize(buf, pos);\n            pos += AssetEditorAsset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += AssetEditorAsset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int assetCount = VarInt.peek(buffer, pos);\n            if (assetCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Asset\");\n            }\n\n            if (assetCount > 4096000) {\n               return ValidationResult.error(\"Asset exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < assetCount; i++) {\n               ValidationResult structResult = AssetEditorAsset.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid AssetEditorAsset in Asset[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += AssetEditorAsset.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, AssetEditorAsset.deserialize, AssetEditorAsset.computeBytesConsumed\n// Types referenced: AssetEditorAsset\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorExportComplete",
        "packetId": 347,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "assets",
            "type": "TimestampedAssetReference[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorExportComplete\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 347;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable TimestampedAssetReference[] assets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorExportComplete deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorExportComplete obj = new AssetEditorExportComplete();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetsCount = VarInt.peek(buf, pos);\n         if (assetsCount < 0) {\n            throw ProtocolException.negativeLength(\"Assets\", assetsCount);\n         }\n\n         if (assetsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Assets\", assetsCount, 4096000);\n         }\n\n         int assetsVarLen = VarInt.size(assetsCount);\n         if ((long)(pos + assetsVarLen) + (long)assetsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Assets\", pos + assetsVarLen + assetsCount * 1, buf.readableBytes());\n         }\n\n         pos += assetsVarLen;\n         obj.assets = new TimestampedAssetReference[assetsCount];\n\n         for (int i = 0; i < assetsCount; i++) {\n            obj.assets[i] = TimestampedAssetReference.deserialize(buf, pos);\n            pos += TimestampedAssetReference.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorExportComplete deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorExportComplete obj = new AssetEditorExportComplete();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetsCount = VarInt.peek(buf, pos);\n         if (assetsCount < 0) {\n            throw ProtocolException.negativeLength(\"Assets\", assetsCount);\n         }\n\n         if (assetsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Assets\", assetsCount, 4096000);\n         }\n\n         int assetsVarLen = VarInt.size(assetsCount);\n         if ((long)(pos + assetsVarLen) + (long)assetsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Assets\", pos + assetsVarLen + assetsCount * 1, buf.readableBytes());\n         }\n\n         pos += assetsVarLen;\n         obj.assets = new TimestampedAssetReference[assetsCount];\n\n         for (int i = 0; i < assetsCount; i++) {\n            obj.assets[i] = TimestampedAssetReference.deserialize(buf, pos);\n            pos += TimestampedAssetReference.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += TimestampedAssetReference.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int assetsCount = VarInt.peek(buffer, pos);\n            if (assetsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Assets\");\n            }\n\n            if (assetsCount > 4096000) {\n               return ValidationResult.error(\"Assets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < assetsCount; i++) {\n               ValidationResult structResult = TimestampedAssetReference.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid TimestampedAssetReference in Assets[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += TimestampedAssetReference.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, TimestampedAssetReference.deserialize, TimestampedAssetReference.computeBytesConsumed\n// Types referenced: TimestampedAssetReference\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorRebuildCaches",
        "packetId": 348,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "blockTextures",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "models",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "modelTextures",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "mapGeometry",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "itemIcons",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorRebuildCaches\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 348;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 5;\n\n// === FIELDS ===\n@Nonnull boolean blockTextures;\n@Nonnull boolean models;\n@Nonnull boolean modelTextures;\n@Nonnull boolean mapGeometry;\n@Nonnull boolean itemIcons;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorRebuildCaches deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRebuildCaches obj = new AssetEditorRebuildCaches();\n      obj.blockTextures = buf.getByte(offset + 0) != 0;\n      obj.models = buf.getByte(offset + 1) != 0;\n      obj.modelTextures = buf.getByte(offset + 2) != 0;\n      obj.mapGeometry = buf.getByte(offset + 3) != 0;\n      obj.itemIcons = buf.getByte(offset + 4) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 5;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 5 ? ValidationResult.error(\"Buffer too small: expected at least 5 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorUndoChanges",
        "packetId": 349,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorUndoChanges\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 349;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 32768024;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPath path;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorUndoChanges deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUndoChanges obj = new AssetEditorUndoChanges();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorUndoChanges deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUndoChanges obj = new AssetEditorUndoChanges();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, AssetPath.computeBytesConsumed\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorRedoChanges",
        "packetId": 350,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "path",
            "type": "AssetPath",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorRedoChanges\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 350;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 32768024;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable AssetPath path;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorRedoChanges deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRedoChanges obj = new AssetEditorRedoChanges();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorRedoChanges deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorRedoChanges obj = new AssetEditorRedoChanges();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.path = AssetPath.deserialize(buf, pos);\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         pos += AssetPath.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            ValidationResult pathResult = AssetPath.validateStructure(buffer, pos);\n            if (!pathResult.isValid()) {\n               return ValidationResult.error(\"Invalid Path: \" + pathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AssetPath.deserialize, AssetPath.computeBytesConsumed\n// Types referenced: AssetPath\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorUndoRedoReply",
        "packetId": 351,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "command",
            "type": "JsonUpdateCommand",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorUndoRedoReply\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 351;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nullable JsonUpdateCommand command;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorUndoRedoReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUndoRedoReply obj = new AssetEditorUndoRedoReply();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.command = JsonUpdateCommand.deserialize(buf, pos);\n         pos += JsonUpdateCommand.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorUndoRedoReply deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUndoRedoReply obj = new AssetEditorUndoRedoReply();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.command = JsonUpdateCommand.deserialize(buf, pos);\n         pos += JsonUpdateCommand.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         pos += JsonUpdateCommand.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            ValidationResult commandResult = JsonUpdateCommand.validateStructure(buffer, pos);\n            if (!commandResult.isValid()) {\n               return ValidationResult.error(\"Invalid Command: \" + commandResult.error());\n            }\n\n            pos += JsonUpdateCommand.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, JsonUpdateCommand.deserialize, JsonUpdateCommand.computeBytesConsumed\n// Types referenced: JsonUpdateCommand\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorSetGameTime",
        "packetId": 352,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "gameTime",
            "type": "InstantData",
            "nullable": true
          },
          {
            "name": "paused",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorSetGameTime\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 352;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 14;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 14;\npublic static final int MAX_SIZE = 14;\n\n// === FIELDS ===\n@Nullable InstantData gameTime;\n@Nonnull boolean paused;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorSetGameTime deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorSetGameTime obj = new AssetEditorSetGameTime();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.gameTime = InstantData.deserialize(buf, offset + 1);\n      }\n\n      obj.paused = buf.getByte(offset + 13) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorSetGameTime deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorSetGameTime obj = new AssetEditorSetGameTime();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.gameTime = InstantData.deserialize(buf, offset + 1);\n      }\n\n      obj.paused = buf.getByte(offset + 13) != 0;\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 14;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 14 ? ValidationResult.error(\"Buffer too small: expected at least 14 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, InstantData.deserialize\n// Types referenced: InstantData\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorUpdateSecondsPerGameDay",
        "packetId": 353,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "daytimeDurationSeconds",
            "type": "int",
            "nullable": false
          },
          {
            "name": "nighttimeDurationSeconds",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorUpdateSecondsPerGameDay\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 353;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 8;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 8;\npublic static final int MAX_SIZE = 8;\n\n// === FIELDS ===\n@Nonnull int daytimeDurationSeconds;\n@Nonnull int nighttimeDurationSeconds;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorUpdateSecondsPerGameDay deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUpdateSecondsPerGameDay obj = new AssetEditorUpdateSecondsPerGameDay();\n      obj.daytimeDurationSeconds = buf.getIntLE(offset + 0);\n      obj.nighttimeDurationSeconds = buf.getIntLE(offset + 4);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 8;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 8 ? ValidationResult.error(\"Buffer too small: expected at least 8 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorUpdateWeatherPreviewLock",
        "packetId": 354,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "locked",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetEditorUpdateWeatherPreviewLock\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 354;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean locked;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorUpdateWeatherPreviewLock deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUpdateWeatherPreviewLock obj = new AssetEditorUpdateWeatherPreviewLock();\n      obj.locked = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetEditorUpdateModelPreview",
        "packetId": 355,
        "package": "com.hypixel.hytale.protocol.packets.asseteditor",
        "fields": [
          {
            "name": "assetPath",
            "type": "AssetPath",
            "nullable": true
          },
          {
            "name": "model",
            "type": "Model",
            "nullable": true
          },
          {
            "name": "block",
            "type": "BlockType",
            "nullable": true
          },
          {
            "name": "camera",
            "type": "AssetEditorPreviewCameraSettings",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetEditorUpdateModelPreview\n// Package: com.hypixel.hytale.protocol.packets.asseteditor\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 355;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 30;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 42;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable AssetPath assetPath;\n@Nullable Model model;\n@Nullable BlockType block;\n@Nullable AssetEditorPreviewCameraSettings camera;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetEditorUpdateModelPreview deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUpdateModelPreview obj = new AssetEditorUpdateModelPreview();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 8) != 0) {\n         obj.camera = AssetEditorPreviewCameraSettings.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 42 + buf.getIntLE(offset + 30);\n         obj.assetPath = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 42 + buf.getIntLE(offset + 34);\n         obj.model = Model.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 42 + buf.getIntLE(offset + 38);\n         obj.block = BlockType.deserialize(buf, varPos2);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetEditorUpdateModelPreview deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetEditorUpdateModelPreview obj = new AssetEditorUpdateModelPreview();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 8) != 0) {\n         obj.camera = AssetEditorPreviewCameraSettings.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 42 + buf.getIntLE(offset + 30);\n         obj.assetPath = AssetPath.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 42 + buf.getIntLE(offset + 34);\n         obj.model = Model.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 42 + buf.getIntLE(offset + 38);\n         obj.block = BlockType.deserialize(buf, varPos2);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 42;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 30);\n         int pos0 = offset + 42 + fieldOffset0;\n         pos0 += AssetPath.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 34);\n         int pos1 = offset + 42 + fieldOffset1;\n         pos1 += Model.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 38);\n         int pos2 = offset + 42 + fieldOffset2;\n         pos2 += BlockType.computeBytesConsumed(buf, pos2);\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 42) {\n         return ValidationResult.error(\"Buffer too small: expected at least 42 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int assetPathOffset = buffer.getIntLE(offset + 30);\n            if (assetPathOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for AssetPath\");\n            }\n\n            int pos = offset + 42 + assetPathOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for AssetPath\");\n            }\n\n            ValidationResult assetPathResult = AssetPath.validateStructure(buffer, pos);\n            if (!assetPathResult.isValid()) {\n               return ValidationResult.error(\"Invalid AssetPath: \" + assetPathResult.error());\n            }\n\n            pos += AssetPath.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int modelOffset = buffer.getIntLE(offset + 34);\n            if (modelOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Model\");\n            }\n\n            int posx = offset + 42 + modelOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Model\");\n            }\n\n            ValidationResult modelResult = Model.validateStructure(buffer, posx);\n            if (!modelResult.isValid()) {\n               return ValidationResult.error(\"Invalid Model: \" + modelResult.error());\n            }\n\n            posx += Model.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int blockOffset = buffer.getIntLE(offset + 38);\n            if (blockOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Block\");\n            }\n\n            int posxx = offset + 42 + blockOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Block\");\n            }\n\n            ValidationResult blockResult = BlockType.validateStructure(buffer, posxx);\n            if (!blockResult.isValid()) {\n               return ValidationResult.error(\"Invalid Block: \" + blockResult.error());\n            }\n\n            posxx += BlockType.computeBytesConsumed(buffer, posxx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, AssetEditorPreviewCameraSettings.deserialize, buf.getIntLE, AssetPath.deserialize, Model.deserialize, BlockType.deserialize\n// Types referenced: AssetEditorPreviewCameraSettings, AssetPath, Model, BlockType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "serveraccess": [
      {
        "name": "RequestServerAccess",
        "packetId": 250,
        "package": "com.hypixel.hytale.protocol.packets.serveraccess",
        "fields": [
          {
            "name": "access",
            "type": "Access",
            "nullable": false
          },
          {
            "name": "externalPort",
            "type": "short",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: RequestServerAccess\n// Package: com.hypixel.hytale.protocol.packets.serveraccess\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 250;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 3;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 3;\npublic static final int MAX_SIZE = 3;\n\n// === FIELDS ===\n@Nonnull Access access;\n@Nonnull short externalPort;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static RequestServerAccess deserialize(@Nonnull ByteBuf buf, int offset) {\n      RequestServerAccess obj = new RequestServerAccess();\n      obj.access = Access.fromValue(buf.getByte(offset + 0));\n      obj.externalPort = buf.getShortLE(offset + 1);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 3;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 3 ? ValidationResult.error(\"Buffer too small: expected at least 3 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: Access.fromValue, buf.getByte, buf.getShortLE\n// Types referenced: Access\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateServerAccess",
        "packetId": 251,
        "package": "com.hypixel.hytale.protocol.packets.serveraccess",
        "fields": [
          {
            "name": "access",
            "type": "Access",
            "nullable": false
          },
          {
            "name": "hosts",
            "type": "HostAddress[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateServerAccess\n// Package: com.hypixel.hytale.protocol.packets.serveraccess\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 251;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull Access access;\n@Nullable HostAddress[] hosts;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateServerAccess deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateServerAccess obj = new UpdateServerAccess();\n      byte nullBits = buf.getByte(offset);\n      obj.access = Access.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int hostsCount = VarInt.peek(buf, pos);\n         if (hostsCount < 0) {\n            throw ProtocolException.negativeLength(\"Hosts\", hostsCount);\n         }\n\n         if (hostsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Hosts\", hostsCount, 4096000);\n         }\n\n         int hostsVarLen = VarInt.size(hostsCount);\n         if ((long)(pos + hostsVarLen) + (long)hostsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Hosts\", pos + hostsVarLen + hostsCount * 2, buf.readableBytes());\n         }\n\n         pos += hostsVarLen;\n         obj.hosts = new HostAddress[hostsCount];\n\n         for (int i = 0; i < hostsCount; i++) {\n            obj.hosts[i] = HostAddress.deserialize(buf, pos);\n            pos += HostAddress.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateServerAccess deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateServerAccess obj = new UpdateServerAccess();\n      byte nullBits = buf.getByte(offset);\n      obj.access = Access.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int hostsCount = VarInt.peek(buf, pos);\n         if (hostsCount < 0) {\n            throw ProtocolException.negativeLength(\"Hosts\", hostsCount);\n         }\n\n         if (hostsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Hosts\", hostsCount, 4096000);\n         }\n\n         int hostsVarLen = VarInt.size(hostsCount);\n         if ((long)(pos + hostsVarLen) + (long)hostsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Hosts\", pos + hostsVarLen + hostsCount * 2, buf.readableBytes());\n         }\n\n         pos += hostsVarLen;\n         obj.hosts = new HostAddress[hostsCount];\n\n         for (int i = 0; i < hostsCount; i++) {\n            obj.hosts[i] = HostAddress.deserialize(buf, pos);\n            pos += HostAddress.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += HostAddress.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int hostsCount = VarInt.peek(buffer, pos);\n            if (hostsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Hosts\");\n            }\n\n            if (hostsCount > 4096000) {\n               return ValidationResult.error(\"Hosts exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < hostsCount; i++) {\n               ValidationResult structResult = HostAddress.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid HostAddress in Hosts[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += HostAddress.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, Access.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, HostAddress.deserialize, HostAddress.computeBytesConsumed\n// Types referenced: Access, HostAddress\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetServerAccess",
        "packetId": 252,
        "package": "com.hypixel.hytale.protocol.packets.serveraccess",
        "fields": [
          {
            "name": "access",
            "type": "Access",
            "nullable": false
          },
          {
            "name": "password",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SetServerAccess\n// Package: com.hypixel.hytale.protocol.packets.serveraccess\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 252;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 16384007;\n\n// === FIELDS ===\n@Nonnull Access access;\n@Nullable String password;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetServerAccess deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetServerAccess obj = new SetServerAccess();\n      byte nullBits = buf.getByte(offset);\n      obj.access = Access.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int passwordLen = VarInt.peek(buf, pos);\n         if (passwordLen < 0) {\n            throw ProtocolException.negativeLength(\"Password\", passwordLen);\n         }\n\n         if (passwordLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Password\", passwordLen, 4096000);\n         }\n\n         int passwordVarLen = VarInt.length(buf, pos);\n         obj.password = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += passwordVarLen + passwordLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int passwordLen = VarInt.peek(buffer, pos);\n            if (passwordLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Password\");\n            }\n\n            if (passwordLen > 4096000) {\n               return ValidationResult.error(\"Password exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += passwordLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Password\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, Access.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n// Types referenced: Access\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "machinima": [
      {
        "name": "RequestMachinimaActorModel",
        "packetId": 260,
        "package": "com.hypixel.hytale.protocol.packets.machinima",
        "fields": [
          {
            "name": "modelId",
            "type": "String",
            "nullable": true
          },
          {
            "name": "sceneName",
            "type": "String",
            "nullable": true
          },
          {
            "name": "actorName",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: RequestMachinimaActorModel\n// Package: com.hypixel.hytale.protocol.packets.machinima\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 260;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 49152028;\n\n// === FIELDS ===\n@Nullable String modelId;\n@Nullable String sceneName;\n@Nullable String actorName;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static RequestMachinimaActorModel deserialize(@Nonnull ByteBuf buf, int offset) {\n      RequestMachinimaActorModel obj = new RequestMachinimaActorModel();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 1);\n         int modelIdLen = VarInt.peek(buf, varPos0);\n         if (modelIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ModelId\", modelIdLen);\n         }\n\n         if (modelIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ModelId\", modelIdLen, 4096000);\n         }\n\n         obj.modelId = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 5);\n         int sceneNameLen = VarInt.peek(buf, varPos1);\n         if (sceneNameLen < 0) {\n            throw ProtocolException.negativeLength(\"SceneName\", sceneNameLen);\n         }\n\n         if (sceneNameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"SceneName\", sceneNameLen, 4096000);\n         }\n\n         obj.sceneName = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 13 + buf.getIntLE(offset + 9);\n         int actorNameLen = VarInt.peek(buf, varPos2);\n         if (actorNameLen < 0) {\n            throw ProtocolException.negativeLength(\"ActorName\", actorNameLen);\n         }\n\n         if (actorNameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ActorName\", actorNameLen, 4096000);\n         }\n\n         obj.actorName = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 13;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 13 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 13 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 9);\n         int pos2 = offset + 13 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int modelIdOffset = buffer.getIntLE(offset + 1);\n            if (modelIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ModelId\");\n            }\n\n            int pos = offset + 13 + modelIdOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ModelId\");\n            }\n\n            int modelIdLen = VarInt.peek(buffer, pos);\n            if (modelIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ModelId\");\n            }\n\n            if (modelIdLen > 4096000) {\n               return ValidationResult.error(\"ModelId exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += modelIdLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ModelId\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int sceneNameOffset = buffer.getIntLE(offset + 5);\n            if (sceneNameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for SceneName\");\n            }\n\n            int posx = offset + 13 + sceneNameOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for SceneName\");\n            }\n\n            int sceneNameLen = VarInt.peek(buffer, posx);\n            if (sceneNameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for SceneName\");\n            }\n\n            if (sceneNameLen > 4096000) {\n               return ValidationResult.error(\"SceneName exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += sceneNameLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading SceneName\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int actorNameOffset = buffer.getIntLE(offset + 9);\n            if (actorNameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ActorName\");\n            }\n\n            int posxx = offset + 13 + actorNameOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ActorName\");\n            }\n\n            int actorNameLen = VarInt.peek(buffer, posxx);\n            if (actorNameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ActorName\");\n            }\n\n            if (actorNameLen > 4096000) {\n               return ValidationResult.error(\"ActorName exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += actorNameLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ActorName\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetMachinimaActorModel",
        "packetId": 261,
        "package": "com.hypixel.hytale.protocol.packets.machinima",
        "fields": [
          {
            "name": "model",
            "type": "Model",
            "nullable": true
          },
          {
            "name": "sceneName",
            "type": "String",
            "nullable": true
          },
          {
            "name": "actorName",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SetMachinimaActorModel\n// Package: com.hypixel.hytale.protocol.packets.machinima\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 261;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable Model model;\n@Nullable String sceneName;\n@Nullable String actorName;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetMachinimaActorModel deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetMachinimaActorModel obj = new SetMachinimaActorModel();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 1);\n         obj.model = Model.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 5);\n         int sceneNameLen = VarInt.peek(buf, varPos1);\n         if (sceneNameLen < 0) {\n            throw ProtocolException.negativeLength(\"SceneName\", sceneNameLen);\n         }\n\n         if (sceneNameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"SceneName\", sceneNameLen, 4096000);\n         }\n\n         obj.sceneName = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 13 + buf.getIntLE(offset + 9);\n         int actorNameLen = VarInt.peek(buf, varPos2);\n         if (actorNameLen < 0) {\n            throw ProtocolException.negativeLength(\"ActorName\", actorNameLen);\n         }\n\n         if (actorNameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ActorName\", actorNameLen, 4096000);\n         }\n\n         obj.actorName = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SetMachinimaActorModel deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetMachinimaActorModel obj = new SetMachinimaActorModel();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 1);\n         obj.model = Model.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 5);\n         int sceneNameLen = VarInt.peek(buf, varPos1);\n         if (sceneNameLen < 0) {\n            throw ProtocolException.negativeLength(\"SceneName\", sceneNameLen);\n         }\n\n         if (sceneNameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"SceneName\", sceneNameLen, 4096000);\n         }\n\n         obj.sceneName = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 13 + buf.getIntLE(offset + 9);\n         int actorNameLen = VarInt.peek(buf, varPos2);\n         if (actorNameLen < 0) {\n            throw ProtocolException.negativeLength(\"ActorName\", actorNameLen);\n         }\n\n         if (actorNameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ActorName\", actorNameLen, 4096000);\n         }\n\n         obj.actorName = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 13;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 13 + fieldOffset0;\n         pos0 += Model.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 13 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 9);\n         int pos2 = offset + 13 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int modelOffset = buffer.getIntLE(offset + 1);\n            if (modelOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Model\");\n            }\n\n            int pos = offset + 13 + modelOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Model\");\n            }\n\n            ValidationResult modelResult = Model.validateStructure(buffer, pos);\n            if (!modelResult.isValid()) {\n               return ValidationResult.error(\"Invalid Model: \" + modelResult.error());\n            }\n\n            pos += Model.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int sceneNameOffset = buffer.getIntLE(offset + 5);\n            if (sceneNameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for SceneName\");\n            }\n\n            int posx = offset + 13 + sceneNameOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for SceneName\");\n            }\n\n            int sceneNameLen = VarInt.peek(buffer, posx);\n            if (sceneNameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for SceneName\");\n            }\n\n            if (sceneNameLen > 4096000) {\n               return ValidationResult.error(\"SceneName exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += sceneNameLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading SceneName\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int actorNameOffset = buffer.getIntLE(offset + 9);\n            if (actorNameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ActorName\");\n            }\n\n            int posxx = offset + 13 + actorNameOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ActorName\");\n            }\n\n            int actorNameLen = VarInt.peek(buffer, posxx);\n            if (actorNameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ActorName\");\n            }\n\n            if (actorNameLen > 4096000) {\n               return ValidationResult.error(\"ActorName exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += actorNameLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ActorName\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, Model.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: Model\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateMachinimaScene",
        "packetId": 262,
        "package": "com.hypixel.hytale.protocol.packets.machinima",
        "fields": [
          {
            "name": "player",
            "type": "String",
            "nullable": true
          },
          {
            "name": "sceneName",
            "type": "String",
            "nullable": true
          },
          {
            "name": "frame",
            "type": "float",
            "nullable": false
          },
          {
            "name": "updateType",
            "type": "SceneUpdateType",
            "nullable": false
          },
          {
            "name": "scene",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateMachinimaScene\n// Package: com.hypixel.hytale.protocol.packets.machinima\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 262;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 18;\npublic static final int MAX_SIZE = 36864033;\n\n// === FIELDS ===\n@Nullable String player;\n@Nullable String sceneName;\n@Nonnull float frame;\n@Nonnull SceneUpdateType updateType;\n@Nullable byte[] scene;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateMachinimaScene deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateMachinimaScene obj = new UpdateMachinimaScene();\n      byte nullBits = buf.getByte(offset);\n      obj.frame = buf.getFloatLE(offset + 1);\n      obj.updateType = SceneUpdateType.fromValue(buf.getByte(offset + 5));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 18 + buf.getIntLE(offset + 6);\n         int playerLen = VarInt.peek(buf, varPos0);\n         if (playerLen < 0) {\n            throw ProtocolException.negativeLength(\"Player\", playerLen);\n         }\n\n         if (playerLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Player\", playerLen, 4096000);\n         }\n\n         obj.player = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 18 + buf.getIntLE(offset + 10);\n         int sceneNameLen = VarInt.peek(buf, varPos1);\n         if (sceneNameLen < 0) {\n            throw ProtocolException.negativeLength(\"SceneName\", sceneNameLen);\n         }\n\n         if (sceneNameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"SceneName\", sceneNameLen, 4096000);\n         }\n\n         obj.sceneName = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 18 + buf.getIntLE(offset + 14);\n         int sceneCount = VarInt.peek(buf, varPos2);\n         if (sceneCount < 0) {\n            throw ProtocolException.negativeLength(\"Scene\", sceneCount);\n         }\n\n         if (sceneCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Scene\", sceneCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)sceneCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Scene\", varPos2 + varIntLen + sceneCount * 1, buf.readableBytes());\n         }\n\n         obj.scene = new byte[sceneCount];\n\n         for (int i = 0; i < sceneCount; i++) {\n            obj.scene[i] = buf.getByte(varPos2 + varIntLen + i * 1);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 18;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 6);\n         int pos0 = offset + 18 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 10);\n         int pos1 = offset + 18 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 14);\n         int pos2 = offset + 18 + fieldOffset2;\n         int arrLen = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + arrLen * 1;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 18) {\n         return ValidationResult.error(\"Buffer too small: expected at least 18 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int playerOffset = buffer.getIntLE(offset + 6);\n            if (playerOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Player\");\n            }\n\n            int pos = offset + 18 + playerOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Player\");\n            }\n\n            int playerLen = VarInt.peek(buffer, pos);\n            if (playerLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Player\");\n            }\n\n            if (playerLen > 4096000) {\n               return ValidationResult.error(\"Player exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += playerLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Player\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int sceneNameOffset = buffer.getIntLE(offset + 10);\n            if (sceneNameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for SceneName\");\n            }\n\n            int posx = offset + 18 + sceneNameOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for SceneName\");\n            }\n\n            int sceneNameLen = VarInt.peek(buffer, posx);\n            if (sceneNameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for SceneName\");\n            }\n\n            if (sceneNameLen > 4096000) {\n               return ValidationResult.error(\"SceneName exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += sceneNameLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading SceneName\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int sceneOffset = buffer.getIntLE(offset + 14);\n            if (sceneOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Scene\");\n            }\n\n            int posxx = offset + 18 + sceneOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Scene\");\n            }\n\n            int sceneCount = VarInt.peek(buffer, posxx);\n            if (sceneCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Scene\");\n            }\n\n            if (sceneCount > 4096000) {\n               return ValidationResult.error(\"Scene exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += sceneCount * 1;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Scene\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getFloatLE, SceneUpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall\n// Types referenced: SceneUpdateType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "setup": [
      {
        "name": "WorldSettings",
        "packetId": 20,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "worldHeight",
            "type": "int",
            "nullable": false
          },
          {
            "name": "requiredAssets",
            "type": "Asset[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: WorldSettings\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 20;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int worldHeight;\n@Nullable Asset[] requiredAssets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static WorldSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      WorldSettings obj = new WorldSettings();\n      byte nullBits = buf.getByte(offset);\n      obj.worldHeight = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int requiredAssetsCount = VarInt.peek(buf, pos);\n         if (requiredAssetsCount < 0) {\n            throw ProtocolException.negativeLength(\"RequiredAssets\", requiredAssetsCount);\n         }\n\n         if (requiredAssetsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RequiredAssets\", requiredAssetsCount, 4096000);\n         }\n\n         int requiredAssetsVarLen = VarInt.size(requiredAssetsCount);\n         if ((long)(pos + requiredAssetsVarLen) + (long)requiredAssetsCount * 64L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RequiredAssets\", pos + requiredAssetsVarLen + requiredAssetsCount * 64, buf.readableBytes());\n         }\n\n         pos += requiredAssetsVarLen;\n         obj.requiredAssets = new Asset[requiredAssetsCount];\n\n         for (int i = 0; i < requiredAssetsCount; i++) {\n            obj.requiredAssets[i] = Asset.deserialize(buf, pos);\n            pos += Asset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static WorldSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      WorldSettings obj = new WorldSettings();\n      byte nullBits = buf.getByte(offset);\n      obj.worldHeight = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int requiredAssetsCount = VarInt.peek(buf, pos);\n         if (requiredAssetsCount < 0) {\n            throw ProtocolException.negativeLength(\"RequiredAssets\", requiredAssetsCount);\n         }\n\n         if (requiredAssetsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RequiredAssets\", requiredAssetsCount, 4096000);\n         }\n\n         int requiredAssetsVarLen = VarInt.size(requiredAssetsCount);\n         if ((long)(pos + requiredAssetsVarLen) + (long)requiredAssetsCount * 64L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RequiredAssets\", pos + requiredAssetsVarLen + requiredAssetsCount * 64, buf.readableBytes());\n         }\n\n         pos += requiredAssetsVarLen;\n         obj.requiredAssets = new Asset[requiredAssetsCount];\n\n         for (int i = 0; i < requiredAssetsCount; i++) {\n            obj.requiredAssets[i] = Asset.deserialize(buf, pos);\n            pos += Asset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += Asset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            int requiredAssetsCount = VarInt.peek(buffer, pos);\n            if (requiredAssetsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for RequiredAssets\");\n            }\n\n            if (requiredAssetsCount > 4096000) {\n               return ValidationResult.error(\"RequiredAssets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < requiredAssetsCount; i++) {\n               ValidationResult structResult = Asset.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid Asset in RequiredAssets[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += Asset.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, Asset.deserialize, Asset.computeBytesConsumed\n// Types referenced: Asset\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "WorldLoadProgress",
        "packetId": 21,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "status",
            "type": "String",
            "nullable": true
          },
          {
            "name": "percentComplete",
            "type": "int",
            "nullable": false
          },
          {
            "name": "percentCompleteSubitem",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: WorldLoadProgress\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 21;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 16384014;\n\n// === FIELDS ===\n@Nullable String status;\n@Nonnull int percentComplete;\n@Nonnull int percentCompleteSubitem;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static WorldLoadProgress deserialize(@Nonnull ByteBuf buf, int offset) {\n      WorldLoadProgress obj = new WorldLoadProgress();\n      byte nullBits = buf.getByte(offset);\n      obj.percentComplete = buf.getIntLE(offset + 1);\n      obj.percentCompleteSubitem = buf.getIntLE(offset + 5);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int statusLen = VarInt.peek(buf, pos);\n         if (statusLen < 0) {\n            throw ProtocolException.negativeLength(\"Status\", statusLen);\n         }\n\n         if (statusLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Status\", statusLen, 4096000);\n         }\n\n         int statusVarLen = VarInt.length(buf, pos);\n         obj.status = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += statusVarLen + statusLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 9;\n         if ((nullBits & 1) != 0) {\n            int statusLen = VarInt.peek(buffer, pos);\n            if (statusLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Status\");\n            }\n\n            if (statusLen > 4096000) {\n               return ValidationResult.error(\"Status exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += statusLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Status\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "WorldLoadFinished",
        "packetId": 22,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [],
        "deserializeContext": "// Packet: WorldLoadFinished\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 22;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static WorldLoadFinished deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new WorldLoadFinished();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "RequestAssets",
        "packetId": 23,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "assets",
            "type": "Asset[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: RequestAssets\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 23;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable Asset[] assets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static RequestAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      RequestAssets obj = new RequestAssets();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetsCount = VarInt.peek(buf, pos);\n         if (assetsCount < 0) {\n            throw ProtocolException.negativeLength(\"Assets\", assetsCount);\n         }\n\n         if (assetsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Assets\", assetsCount, 4096000);\n         }\n\n         int assetsVarLen = VarInt.size(assetsCount);\n         if ((long)(pos + assetsVarLen) + (long)assetsCount * 64L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Assets\", pos + assetsVarLen + assetsCount * 64, buf.readableBytes());\n         }\n\n         pos += assetsVarLen;\n         obj.assets = new Asset[assetsCount];\n\n         for (int i = 0; i < assetsCount; i++) {\n            obj.assets[i] = Asset.deserialize(buf, pos);\n            pos += Asset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static RequestAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      RequestAssets obj = new RequestAssets();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetsCount = VarInt.peek(buf, pos);\n         if (assetsCount < 0) {\n            throw ProtocolException.negativeLength(\"Assets\", assetsCount);\n         }\n\n         if (assetsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Assets\", assetsCount, 4096000);\n         }\n\n         int assetsVarLen = VarInt.size(assetsCount);\n         if ((long)(pos + assetsVarLen) + (long)assetsCount * 64L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Assets\", pos + assetsVarLen + assetsCount * 64, buf.readableBytes());\n         }\n\n         pos += assetsVarLen;\n         obj.assets = new Asset[assetsCount];\n\n         for (int i = 0; i < assetsCount; i++) {\n            obj.assets[i] = Asset.deserialize(buf, pos);\n            pos += Asset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += Asset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int assetsCount = VarInt.peek(buffer, pos);\n            if (assetsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Assets\");\n            }\n\n            if (assetsCount > 4096000) {\n               return ValidationResult.error(\"Assets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < assetsCount; i++) {\n               ValidationResult structResult = Asset.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid Asset in Assets[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += Asset.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, Asset.deserialize, Asset.computeBytesConsumed\n// Types referenced: Asset\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetInitialize",
        "packetId": 24,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "asset",
            "type": "Asset",
            "nullable": false
          },
          {
            "name": "size",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: AssetInitialize\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 24;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 2121;\n\n// === FIELDS ===\n@Nonnull Asset asset;\n@Nonnull int size;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetInitialize deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetInitialize obj = new AssetInitialize();\n      obj.size = buf.getIntLE(offset + 0);\n      int pos = offset + 4;\n      obj.asset = Asset.deserialize(buf, pos);\n      pos += Asset.computeBytesConsumed(buf, pos);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AssetInitialize deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetInitialize obj = new AssetInitialize();\n      obj.size = buf.getIntLE(offset + 0);\n      int pos = offset + 4;\n      obj.asset = Asset.deserialize(buf, pos);\n      pos += Asset.computeBytesConsumed(buf, pos);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int pos = offset + 4;\n      pos += Asset.computeBytesConsumed(buf, pos);\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 4) {\n         return ValidationResult.error(\"Buffer too small: expected at least 4 bytes\");\n      } else {\n         int pos = offset + 4;\n         ValidationResult assetResult = Asset.validateStructure(buffer, pos);\n         if (!assetResult.isValid()) {\n            return ValidationResult.error(\"Invalid Asset: \" + assetResult.error());\n         } else {\n            pos += Asset.computeBytesConsumed(buffer, pos);\n            return ValidationResult.OK;\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, Asset.deserialize, Asset.computeBytesConsumed\n// Types referenced: Asset\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetPart",
        "packetId": 25,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "part",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AssetPart\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 25;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 4096006;\n\n// === FIELDS ===\n@Nullable byte[] part;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetPart deserialize(@Nonnull ByteBuf buf, int offset) {\n      AssetPart obj = new AssetPart();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int partCount = VarInt.peek(buf, pos);\n         if (partCount < 0) {\n            throw ProtocolException.negativeLength(\"Part\", partCount);\n         }\n\n         if (partCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Part\", partCount, 4096000);\n         }\n\n         int partVarLen = VarInt.size(partCount);\n         if ((long)(pos + partVarLen) + (long)partCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Part\", pos + partVarLen + partCount * 1, buf.readableBytes());\n         }\n\n         pos += partVarLen;\n         obj.part = new byte[partCount];\n\n         for (int i = 0; i < partCount; i++) {\n            obj.part[i] = buf.getByte(pos + i * 1);\n         }\n\n         pos += partCount * 1;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int partCount = VarInt.peek(buffer, pos);\n            if (partCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Part\");\n            }\n\n            if (partCount > 4096000) {\n               return ValidationResult.error(\"Part exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += partCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Part\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AssetFinalize",
        "packetId": 26,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [],
        "deserializeContext": "// Packet: AssetFinalize\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 26;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AssetFinalize deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new AssetFinalize();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "RemoveAssets",
        "packetId": 27,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "asset",
            "type": "Asset[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: RemoveAssets\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 27;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable Asset[] asset;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static RemoveAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      RemoveAssets obj = new RemoveAssets();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetCount = VarInt.peek(buf, pos);\n         if (assetCount < 0) {\n            throw ProtocolException.negativeLength(\"Asset\", assetCount);\n         }\n\n         if (assetCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Asset\", assetCount, 4096000);\n         }\n\n         int assetVarLen = VarInt.size(assetCount);\n         if ((long)(pos + assetVarLen) + (long)assetCount * 64L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Asset\", pos + assetVarLen + assetCount * 64, buf.readableBytes());\n         }\n\n         pos += assetVarLen;\n         obj.asset = new Asset[assetCount];\n\n         for (int i = 0; i < assetCount; i++) {\n            obj.asset[i] = Asset.deserialize(buf, pos);\n            pos += Asset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static RemoveAssets deserialize(@Nonnull ByteBuf buf, int offset) {\n      RemoveAssets obj = new RemoveAssets();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int assetCount = VarInt.peek(buf, pos);\n         if (assetCount < 0) {\n            throw ProtocolException.negativeLength(\"Asset\", assetCount);\n         }\n\n         if (assetCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Asset\", assetCount, 4096000);\n         }\n\n         int assetVarLen = VarInt.size(assetCount);\n         if ((long)(pos + assetVarLen) + (long)assetCount * 64L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Asset\", pos + assetVarLen + assetCount * 64, buf.readableBytes());\n         }\n\n         pos += assetVarLen;\n         obj.asset = new Asset[assetCount];\n\n         for (int i = 0; i < assetCount; i++) {\n            obj.asset[i] = Asset.deserialize(buf, pos);\n            pos += Asset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += Asset.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int assetCount = VarInt.peek(buffer, pos);\n            if (assetCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Asset\");\n            }\n\n            if (assetCount > 4096000) {\n               return ValidationResult.error(\"Asset exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < assetCount; i++) {\n               ValidationResult structResult = Asset.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid Asset in Asset[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += Asset.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, Asset.deserialize, Asset.computeBytesConsumed\n// Types referenced: Asset\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "RequestCommonAssetsRebuild",
        "packetId": 28,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [],
        "deserializeContext": "// Packet: RequestCommonAssetsRebuild\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 28;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static RequestCommonAssetsRebuild deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new RequestCommonAssetsRebuild();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetUpdateRate",
        "packetId": 29,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "updatesPerSecond",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetUpdateRate\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 29;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int updatesPerSecond;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetUpdateRate deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetUpdateRate obj = new SetUpdateRate();\n      obj.updatesPerSecond = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetTimeDilation",
        "packetId": 30,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "timeDilation",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetTimeDilation\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 30;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull float timeDilation;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetTimeDilation deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetTimeDilation obj = new SetTimeDilation();\n      obj.timeDilation = buf.getFloatLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getFloatLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateFeatures",
        "packetId": 31,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "features",
            "type": "Map<ClientFeature, Boolean>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateFeatures\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 31;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 8192006;\n\n// === FIELDS ===\n@Nullable Map<ClientFeature, Boolean> features;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateFeatures deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateFeatures obj = new UpdateFeatures();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int featuresCount = VarInt.peek(buf, pos);\n         if (featuresCount < 0) {\n            throw ProtocolException.negativeLength(\"Features\", featuresCount);\n         }\n\n         if (featuresCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Features\", featuresCount, 4096000);\n         }\n\n         pos += VarInt.size(featuresCount);\n         obj.features = new HashMap<>(featuresCount);\n\n         for (int i = 0; i < featuresCount; i++) {\n            ClientFeature key = ClientFeature.fromValue(buf.getByte(pos));\n            pos++;\n            boolean val = buf.getByte(pos) != 0;\n            pos++;\n            if (obj.features.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"features\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos++;\n            pos++;\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int featuresCount = VarInt.peek(buffer, pos);\n            if (featuresCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Features\");\n            }\n\n            if (featuresCount > 4096000) {\n               return ValidationResult.error(\"Features exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < featuresCount; i++) {\n               pos++;\n               if (++pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading value\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ClientFeature.fromValue, obj.features.put, ProtocolException.duplicateKey\n// Types referenced: ClientFeature\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ViewRadius",
        "packetId": 32,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "value",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ViewRadius\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 32;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int value;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ViewRadius deserialize(@Nonnull ByteBuf buf, int offset) {\n      ViewRadius obj = new ViewRadius();\n      obj.value = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PlayerOptions",
        "packetId": 33,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "skin",
            "type": "PlayerSkin",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: PlayerOptions\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 33;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 327680184;\n\n// === FIELDS ===\n@Nullable PlayerSkin skin;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PlayerOptions deserialize(@Nonnull ByteBuf buf, int offset) {\n      PlayerOptions obj = new PlayerOptions();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         obj.skin = PlayerSkin.deserialize(buf, pos);\n         pos += PlayerSkin.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static PlayerOptions deserialize(@Nonnull ByteBuf buf, int offset) {\n      PlayerOptions obj = new PlayerOptions();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         obj.skin = PlayerSkin.deserialize(buf, pos);\n         pos += PlayerSkin.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         pos += PlayerSkin.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            ValidationResult skinResult = PlayerSkin.validateStructure(buffer, pos);\n            if (!skinResult.isValid()) {\n               return ValidationResult.error(\"Invalid Skin: \" + skinResult.error());\n            }\n\n            pos += PlayerSkin.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, PlayerSkin.deserialize, PlayerSkin.computeBytesConsumed\n// Types referenced: PlayerSkin\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerTags",
        "packetId": 34,
        "package": "com.hypixel.hytale.protocol.packets.setup",
        "fields": [
          {
            "name": "tags",
            "type": "Map<String, Integer>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: ServerTags\n// Package: com.hypixel.hytale.protocol.packets.setup\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 34;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable Map<String, Integer> tags;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerTags deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerTags obj = new ServerTags();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int tagsCount = VarInt.peek(buf, pos);\n         if (tagsCount < 0) {\n            throw ProtocolException.negativeLength(\"Tags\", tagsCount);\n         }\n\n         if (tagsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Tags\", tagsCount, 4096000);\n         }\n\n         pos += VarInt.size(tagsCount);\n         obj.tags = new HashMap<>(tagsCount);\n\n         for (int i = 0; i < tagsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            int val = buf.getIntLE(pos);\n            pos += 4;\n            if (obj.tags.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"tags\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            pos += 4;\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int tagsCount = VarInt.peek(buffer, pos);\n            if (tagsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Tags\");\n            }\n\n            if (tagsCount > 4096000) {\n               return ValidationResult.error(\"Tags exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < tagsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading value\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, buf.getIntLE, obj.tags.put, ProtocolException.duplicateKey\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "buildertools": [
      {
        "name": "BuilderToolIntArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "int",
            "nullable": false
          },
          {
            "name": "min",
            "type": "int",
            "nullable": false
          },
          {
            "name": "max",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolIntArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 12;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 12;\npublic static final int MAX_SIZE = 12;\n\n// === FIELDS ===\n@Nonnull int defaultValue;\n@Nonnull int min;\n@Nonnull int max;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolIntArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolIntArg obj = new BuilderToolIntArg();\n      obj.defaultValue = buf.getIntLE(offset + 0);\n      obj.min = buf.getIntLE(offset + 4);\n      obj.max = buf.getIntLE(offset + 8);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 12;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 12 ? ValidationResult.error(\"Buffer too small: expected at least 12 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolBoolArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolBoolArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean defaultValue;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolBoolArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolBoolArg obj = new BuilderToolBoolArg();\n      obj.defaultValue = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolRotationArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "Rotation",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolRotationArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull Rotation defaultValue;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolRotationArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolRotationArg obj = new BuilderToolRotationArg();\n      obj.defaultValue = Rotation.fromValue(buf.getByte(offset + 0));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: Rotation.fromValue, buf.getByte\n// Types referenced: Rotation\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolBlockArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "String",
            "nullable": true
          },
          {
            "name": "allowPattern",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolBlockArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 16384007;\n\n// === FIELDS ===\n@Nullable String defaultValue;\n@Nonnull boolean allowPattern;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolBlockArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolBlockArg obj = new BuilderToolBlockArg();\n      byte nullBits = buf.getByte(offset);\n      obj.allowPattern = buf.getByte(offset + 1) != 0;\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int defaultValueLen = VarInt.peek(buf, pos);\n         if (defaultValueLen < 0) {\n            throw ProtocolException.negativeLength(\"Default\", defaultValueLen);\n         }\n\n         if (defaultValueLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Default\", defaultValueLen, 4096000);\n         }\n\n         int defaultValueVarLen = VarInt.length(buf, pos);\n         obj.defaultValue = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += defaultValueVarLen + defaultValueLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int defaultLen = VarInt.peek(buffer, pos);\n            if (defaultLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Default\");\n            }\n\n            if (defaultLen > 4096000) {\n               return ValidationResult.error(\"Default exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += defaultLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Default\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolBrushAxisArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "BrushAxis",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolBrushAxisArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull BrushAxis defaultValue;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolBrushAxisArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolBrushAxisArg obj = new BuilderToolBrushAxisArg();\n      obj.defaultValue = BrushAxis.fromValue(buf.getByte(offset + 0));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: BrushAxis.fromValue, buf.getByte\n// Types referenced: BrushAxis\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolOptionArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "String",
            "nullable": true
          },
          {
            "name": "options",
            "type": "String[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolOptionArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable String defaultValue;\n@Nullable String[] options;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolOptionArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolOptionArg obj = new BuilderToolOptionArg();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int defaultValueLen = VarInt.peek(buf, varPos0);\n         if (defaultValueLen < 0) {\n            throw ProtocolException.negativeLength(\"Default\", defaultValueLen);\n         }\n\n         if (defaultValueLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Default\", defaultValueLen, 4096000);\n         }\n\n         obj.defaultValue = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int optionsCount = VarInt.peek(buf, varPos1);\n         if (optionsCount < 0) {\n            throw ProtocolException.negativeLength(\"Options\", optionsCount);\n         }\n\n         if (optionsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Options\", optionsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)optionsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Options\", varPos1 + varIntLen + optionsCount * 1, buf.readableBytes());\n         }\n\n         obj.options = new String[optionsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < optionsCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"options[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"options[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.options[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos1);\n            pos1 += VarInt.length(buf, pos1) + sl;\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int defaultOffset = buffer.getIntLE(offset + 1);\n            if (defaultOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Default\");\n            }\n\n            int pos = offset + 9 + defaultOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Default\");\n            }\n\n            int defaultLen = VarInt.peek(buffer, pos);\n            if (defaultLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Default\");\n            }\n\n            if (defaultLen > 4096000) {\n               return ValidationResult.error(\"Default exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += defaultLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Default\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int optionsOffset = buffer.getIntLE(offset + 5);\n            if (optionsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Options\");\n            }\n\n            int posx = offset + 9 + optionsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Options\");\n            }\n\n            int optionsCount = VarInt.peek(buffer, posx);\n            if (optionsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Options\");\n            }\n\n            if (optionsCount > 4096000) {\n               return ValidationResult.error(\"Options exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < optionsCount; i++) {\n               int strLen = VarInt.peek(buffer, posx);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in Options\");\n               }\n\n               posx += VarInt.length(buffer, posx);\n               posx += strLen;\n               if (posx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in Options\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolBrushOriginArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "BrushOrigin",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolBrushOriginArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull BrushOrigin defaultValue;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolBrushOriginArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolBrushOriginArg obj = new BuilderToolBrushOriginArg();\n      obj.defaultValue = BrushOrigin.fromValue(buf.getByte(offset + 0));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: BrushOrigin.fromValue, buf.getByte\n// Types referenced: BrushOrigin\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolStringArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolStringArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String defaultValue;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolStringArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolStringArg obj = new BuilderToolStringArg();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int defaultValueLen = VarInt.peek(buf, pos);\n         if (defaultValueLen < 0) {\n            throw ProtocolException.negativeLength(\"Default\", defaultValueLen);\n         }\n\n         if (defaultValueLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Default\", defaultValueLen, 4096000);\n         }\n\n         int defaultValueVarLen = VarInt.length(buf, pos);\n         obj.defaultValue = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += defaultValueVarLen + defaultValueLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int defaultLen = VarInt.peek(buffer, pos);\n            if (defaultLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Default\");\n            }\n\n            if (defaultLen > 4096000) {\n               return ValidationResult.error(\"Default exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += defaultLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Default\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolMaskArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolMaskArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String defaultValue;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolMaskArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolMaskArg obj = new BuilderToolMaskArg();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int defaultValueLen = VarInt.peek(buf, pos);\n         if (defaultValueLen < 0) {\n            throw ProtocolException.negativeLength(\"Default\", defaultValueLen);\n         }\n\n         if (defaultValueLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Default\", defaultValueLen, 4096000);\n         }\n\n         int defaultValueVarLen = VarInt.length(buf, pos);\n         obj.defaultValue = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += defaultValueVarLen + defaultValueLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int defaultLen = VarInt.peek(buffer, pos);\n            if (defaultLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Default\");\n            }\n\n            if (defaultLen > 4096000) {\n               return ValidationResult.error(\"Default exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += defaultLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Default\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "required",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "argType",
            "type": "BuilderToolArgType",
            "nullable": false
          },
          {
            "name": "boolArg",
            "type": "BuilderToolBoolArg",
            "nullable": true
          },
          {
            "name": "floatArg",
            "type": "BuilderToolFloatArg",
            "nullable": true
          },
          {
            "name": "intArg",
            "type": "BuilderToolIntArg",
            "nullable": true
          },
          {
            "name": "stringArg",
            "type": "BuilderToolStringArg",
            "nullable": true
          },
          {
            "name": "blockArg",
            "type": "BuilderToolBlockArg",
            "nullable": true
          },
          {
            "name": "maskArg",
            "type": "BuilderToolMaskArg",
            "nullable": true
          },
          {
            "name": "brushShapeArg",
            "type": "BuilderToolBrushShapeArg",
            "nullable": true
          },
          {
            "name": "brushOriginArg",
            "type": "BuilderToolBrushOriginArg",
            "nullable": true
          },
          {
            "name": "brushAxisArg",
            "type": "BuilderToolBrushAxisArg",
            "nullable": true
          },
          {
            "name": "rotationArg",
            "type": "BuilderToolRotationArg",
            "nullable": true
          },
          {
            "name": "optionArg",
            "type": "BuilderToolOptionArg",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 2;\npublic static final int FIXED_BLOCK_SIZE = 33;\npublic static final int VARIABLE_FIELD_COUNT = 4;\npublic static final int VARIABLE_BLOCK_START = 49;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull boolean required;\n@Nonnull BuilderToolArgType argType;\n@Nullable BuilderToolBoolArg boolArg;\n@Nullable BuilderToolFloatArg floatArg;\n@Nullable BuilderToolIntArg intArg;\n@Nullable BuilderToolStringArg stringArg;\n@Nullable BuilderToolBlockArg blockArg;\n@Nullable BuilderToolMaskArg maskArg;\n@Nullable BuilderToolBrushShapeArg brushShapeArg;\n@Nullable BuilderToolBrushOriginArg brushOriginArg;\n@Nullable BuilderToolBrushAxisArg brushAxisArg;\n@Nullable BuilderToolRotationArg rotationArg;\n@Nullable BuilderToolOptionArg optionArg;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolArg obj = new BuilderToolArg();\n      byte[] nullBits = PacketIO.readBytes(buf, offset, 2);\n      obj.required = buf.getByte(offset + 2) != 0;\n      obj.argType = BuilderToolArgType.fromValue(buf.getByte(offset + 3));\n      if ((nullBits[0] & 1) != 0) {\n         obj.boolArg = BuilderToolBoolArg.deserialize(buf, offset + 4);\n      }\n\n      if ((nullBits[0] & 2) != 0) {\n         obj.floatArg = BuilderToolFloatArg.deserialize(buf, offset + 5);\n      }\n\n      if ((nullBits[0] & 4) != 0) {\n         obj.intArg = BuilderToolIntArg.deserialize(buf, offset + 17);\n      }\n\n      if ((nullBits[0] & 64) != 0) {\n         obj.brushShapeArg = BuilderToolBrushShapeArg.deserialize(buf, offset + 29);\n      }\n\n      if ((nullBits[0] & 128) != 0) {\n         obj.brushOriginArg = BuilderToolBrushOriginArg.deserialize(buf, offset + 30);\n      }\n\n      if ((nullBits[1] & 1) != 0) {\n         obj.brushAxisArg = BuilderToolBrushAxisArg.deserialize(buf, offset + 31);\n      }\n\n      if ((nullBits[1] & 2) != 0) {\n         obj.rotationArg = BuilderToolRotationArg.deserialize(buf, offset + 32);\n      }\n\n      if ((nullBits[0] & 8) != 0) {\n         int varPos0 = offset + 49 + buf.getIntLE(offset + 33);\n         obj.stringArg = BuilderToolStringArg.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits[0] & 16) != 0) {\n         int varPos1 = offset + 49 + buf.getIntLE(offset + 37);\n         obj.blockArg = BuilderToolBlockArg.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits[0] & 32) != 0) {\n         int varPos2 = offset + 49 + buf.getIntLE(offset + 41);\n         obj.maskArg = BuilderToolMaskArg.deserialize(buf, varPos2);\n      }\n\n      if ((nullBits[1] & 4) != 0) {\n         int varPos3 = offset + 49 + buf.getIntLE(offset + 45);\n         obj.optionArg = BuilderToolOptionArg.deserialize(buf, varPos3);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static BuilderToolArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolArg obj = new BuilderToolArg();\n      byte[] nullBits = PacketIO.readBytes(buf, offset, 2);\n      obj.required = buf.getByte(offset + 2) != 0;\n      obj.argType = BuilderToolArgType.fromValue(buf.getByte(offset + 3));\n      if ((nullBits[0] & 1) != 0) {\n         obj.boolArg = BuilderToolBoolArg.deserialize(buf, offset + 4);\n      }\n\n      if ((nullBits[0] & 2) != 0) {\n         obj.floatArg = BuilderToolFloatArg.deserialize(buf, offset + 5);\n      }\n\n      if ((nullBits[0] & 4) != 0) {\n         obj.intArg = BuilderToolIntArg.deserialize(buf, offset + 17);\n      }\n\n      if ((nullBits[0] & 64) != 0) {\n         obj.brushShapeArg = BuilderToolBrushShapeArg.deserialize(buf, offset + 29);\n      }\n\n      if ((nullBits[0] & 128) != 0) {\n         obj.brushOriginArg = BuilderToolBrushOriginArg.deserialize(buf, offset + 30);\n      }\n\n      if ((nullBits[1] & 1) != 0) {\n         obj.brushAxisArg = BuilderToolBrushAxisArg.deserialize(buf, offset + 31);\n      }\n\n      if ((nullBits[1] & 2) != 0) {\n         obj.rotationArg = BuilderToolRotationArg.deserialize(buf, offset + 32);\n      }\n\n      if ((nullBits[0] & 8) != 0) {\n         int varPos0 = offset + 49 + buf.getIntLE(offset + 33);\n         obj.stringArg = BuilderToolStringArg.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits[0] & 16) != 0) {\n         int varPos1 = offset + 49 + buf.getIntLE(offset + 37);\n         obj.blockArg = BuilderToolBlockArg.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits[0] & 32) != 0) {\n         int varPos2 = offset + 49 + buf.getIntLE(offset + 41);\n         obj.maskArg = BuilderToolMaskArg.deserialize(buf, varPos2);\n      }\n\n      if ((nullBits[1] & 4) != 0) {\n         int varPos3 = offset + 49 + buf.getIntLE(offset + 45);\n         obj.optionArg = BuilderToolOptionArg.deserialize(buf, varPos3);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte[] nullBits = PacketIO.readBytes(buf, offset, 2);\n      int maxEnd = 49;\n      if ((nullBits[0] & 8) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 33);\n         int pos0 = offset + 49 + fieldOffset0;\n         pos0 += BuilderToolStringArg.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits[0] & 16) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 37);\n         int pos1 = offset + 49 + fieldOffset1;\n         pos1 += BuilderToolBlockArg.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits[0] & 32) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 41);\n         int pos2 = offset + 49 + fieldOffset2;\n         pos2 += BuilderToolMaskArg.computeBytesConsumed(buf, pos2);\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      if ((nullBits[1] & 4) != 0) {\n         int fieldOffset3 = buf.getIntLE(offset + 45);\n         int pos3 = offset + 49 + fieldOffset3;\n         pos3 += BuilderToolOptionArg.computeBytesConsumed(buf, pos3);\n         if (pos3 - offset > maxEnd) {\n            maxEnd = pos3 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 49) {\n         return ValidationResult.error(\"Buffer too small: expected at least 49 bytes\");\n      } else {\n         byte[] nullBits = PacketIO.readBytes(buffer, offset, 2);\n         if ((nullBits[0] & 8) != 0) {\n            int stringArgOffset = buffer.getIntLE(offset + 33);\n            if (stringArgOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for StringArg\");\n            }\n\n            int pos = offset + 49 + stringArgOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for StringArg\");\n            }\n\n            ValidationResult stringArgResult = BuilderToolStringArg.validateStructure(buffer, pos);\n            if (!stringArgResult.isValid()) {\n               return ValidationResult.error(\"Invalid StringArg: \" + stringArgResult.error());\n            }\n\n            pos += BuilderToolStringArg.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits[0] & 16) != 0) {\n            int blockArgOffset = buffer.getIntLE(offset + 37);\n            if (blockArgOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for BlockArg\");\n            }\n\n            int posx = offset + 49 + blockArgOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for BlockArg\");\n            }\n\n            ValidationResult blockArgResult = BuilderToolBlockArg.validateStructure(buffer, posx);\n            if (!blockArgResult.isValid()) {\n               return ValidationResult.error(\"Invalid BlockArg: \" + blockArgResult.error());\n            }\n\n            posx += BuilderToolBlockArg.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits[0] & 32) != 0) {\n            int maskArgOffset = buffer.getIntLE(offset + 41);\n            if (maskArgOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for MaskArg\");\n            }\n\n            int posxx = offset + 49 + maskArgOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for MaskArg\");\n            }\n\n            ValidationResult maskArgResult = BuilderToolMaskArg.validateStructure(buffer, posxx);\n            if (!maskArgResult.isValid()) {\n               return ValidationResult.error(\"Invalid MaskArg: \" + maskArgResult.error());\n            }\n\n            posxx += BuilderToolMaskArg.computeBytesConsumed(buffer, posxx);\n         }\n\n         if ((nullBits[1] & 4) != 0) {\n            int optionArgOffset = buffer.getIntLE(offset + 45);\n            if (optionArgOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for OptionArg\");\n            }\n\n            int posxxx = offset + 49 + optionArgOffset;\n            if (posxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for OptionArg\");\n            }\n\n            ValidationResult optionArgResult = BuilderToolOptionArg.validateStructure(buffer, posxxx);\n            if (!optionArgResult.isValid()) {\n               return ValidationResult.error(\"Invalid OptionArg: \" + optionArgResult.error());\n            }\n\n            posxxx += BuilderToolOptionArg.computeBytesConsumed(buffer, posxxx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: PacketIO.readBytes, buf.getByte, BuilderToolArgType.fromValue, BuilderToolBoolArg.deserialize, BuilderToolFloatArg.deserialize, BuilderToolIntArg.deserialize, BuilderToolBrushShapeArg.deserialize, BuilderToolBrushOriginArg.deserialize, BuilderToolBrushAxisArg.deserialize, BuilderToolRotationArg.deserialize, buf.getIntLE, BuilderToolStringArg.deserialize, BuilderToolBlockArg.deserialize, BuilderToolMaskArg.deserialize, BuilderToolOptionArg.deserialize\n// Types referenced: BuilderToolArgType, BuilderToolBoolArg, BuilderToolFloatArg, BuilderToolIntArg, BuilderToolBrushShapeArg, BuilderToolBrushOriginArg, BuilderToolBrushAxisArg, BuilderToolRotationArg, BuilderToolStringArg, BuilderToolBlockArg, BuilderToolMaskArg, BuilderToolOptionArg\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolBrushData",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "width",
            "type": "BuilderToolIntArg",
            "nullable": true
          },
          {
            "name": "height",
            "type": "BuilderToolIntArg",
            "nullable": true
          },
          {
            "name": "thickness",
            "type": "BuilderToolIntArg",
            "nullable": true
          },
          {
            "name": "capped",
            "type": "BuilderToolBoolArg",
            "nullable": true
          },
          {
            "name": "shape",
            "type": "BuilderToolBrushShapeArg",
            "nullable": true
          },
          {
            "name": "origin",
            "type": "BuilderToolBrushOriginArg",
            "nullable": true
          },
          {
            "name": "originRotation",
            "type": "BuilderToolBoolArg",
            "nullable": true
          },
          {
            "name": "rotationAxis",
            "type": "BuilderToolBrushAxisArg",
            "nullable": true
          },
          {
            "name": "rotationAngle",
            "type": "BuilderToolRotationArg",
            "nullable": true
          },
          {
            "name": "mirrorAxis",
            "type": "BuilderToolBrushAxisArg",
            "nullable": true
          },
          {
            "name": "material",
            "type": "BuilderToolBlockArg",
            "nullable": true
          },
          {
            "name": "favoriteMaterials",
            "type": "BuilderToolBlockArg[]",
            "nullable": true
          },
          {
            "name": "mask",
            "type": "BuilderToolMaskArg",
            "nullable": true
          },
          {
            "name": "maskAbove",
            "type": "BuilderToolMaskArg",
            "nullable": true
          },
          {
            "name": "maskNot",
            "type": "BuilderToolMaskArg",
            "nullable": true
          },
          {
            "name": "maskBelow",
            "type": "BuilderToolMaskArg",
            "nullable": true
          },
          {
            "name": "maskAdjacent",
            "type": "BuilderToolMaskArg",
            "nullable": true
          },
          {
            "name": "maskNeighbor",
            "type": "BuilderToolMaskArg",
            "nullable": true
          },
          {
            "name": "maskCommands",
            "type": "BuilderToolStringArg[]",
            "nullable": true
          },
          {
            "name": "useMaskCommands",
            "type": "BuilderToolBoolArg",
            "nullable": true
          },
          {
            "name": "invertMask",
            "type": "BuilderToolBoolArg",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolBrushData\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 3;\npublic static final int FIXED_BLOCK_SIZE = 48;\npublic static final int VARIABLE_FIELD_COUNT = 9;\npublic static final int VARIABLE_BLOCK_START = 84;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable BuilderToolIntArg width;\n@Nullable BuilderToolIntArg height;\n@Nullable BuilderToolIntArg thickness;\n@Nullable BuilderToolBoolArg capped;\n@Nullable BuilderToolBrushShapeArg shape;\n@Nullable BuilderToolBrushOriginArg origin;\n@Nullable BuilderToolBoolArg originRotation;\n@Nullable BuilderToolBrushAxisArg rotationAxis;\n@Nullable BuilderToolRotationArg rotationAngle;\n@Nullable BuilderToolBrushAxisArg mirrorAxis;\n@Nullable BuilderToolBlockArg material;\n@Nullable BuilderToolBlockArg[] favoriteMaterials;\n@Nullable BuilderToolMaskArg mask;\n@Nullable BuilderToolMaskArg maskAbove;\n@Nullable BuilderToolMaskArg maskNot;\n@Nullable BuilderToolMaskArg maskBelow;\n@Nullable BuilderToolMaskArg maskAdjacent;\n@Nullable BuilderToolMaskArg maskNeighbor;\n@Nullable BuilderToolStringArg[] maskCommands;\n@Nullable BuilderToolBoolArg useMaskCommands;\n@Nullable BuilderToolBoolArg invertMask;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolBrushData deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolBrushData obj = new BuilderToolBrushData();\n      byte[] nullBits = PacketIO.readBytes(buf, offset, 3);\n      if ((nullBits[0] & 1) != 0) {\n         obj.width = BuilderToolIntArg.deserialize(buf, offset + 3);\n      }\n\n      if ((nullBits[0] & 2) != 0) {\n         obj.height = BuilderToolIntArg.deserialize(buf, offset + 15);\n      }\n\n      if ((nullBits[0] & 4) != 0) {\n         obj.thickness = BuilderToolIntArg.deserialize(buf, offset + 27);\n      }\n\n      if ((nullBits[0] & 8) != 0) {\n         obj.capped = BuilderToolBoolArg.deserialize(buf, offset + 39);\n      }\n\n      if ((nullBits[0] & 16) != 0) {\n         obj.shape = BuilderToolBrushShapeArg.deserialize(buf, offset + 40);\n      }\n\n      if ((nullBits[0] & 32) != 0) {\n         obj.origin = BuilderToolBrushOriginArg.deserialize(buf, offset + 41);\n      }\n\n      if ((nullBits[0] & 64) != 0) {\n         obj.originRotation = BuilderToolBoolArg.deserialize(buf, offset + 42);\n      }\n\n      if ((nullBits[0] & 128) != 0) {\n         obj.rotationAxis = BuilderToolBrushAxisArg.deserialize(buf, offset + 43);\n      }\n\n      if ((nullBits[1] & 1) != 0) {\n         obj.rotationAngle = BuilderToolRotationArg.deserialize(buf, offset + 44);\n      }\n\n      if ((nullBits[1] & 2) != 0) {\n         obj.mirrorAxis = BuilderToolBrushAxisArg.deserialize(buf, offset + 45);\n      }\n\n      if ((nullBits[2] & 8) != 0) {\n         obj.useMaskCommands = BuilderToolBoolArg.deserialize(buf, offset + 46);\n      }\n\n      if ((nullBits[2] & 16) != 0) {\n         obj.invertMask = BuilderToolBoolArg.deserialize(buf, offset + 47);\n      }\n\n      if ((nullBits[1] & 4) != 0) {\n         int varPos0 = offset + 84 + buf.getIntLE(offset + 48);\n         obj.material = BuilderToolBlockArg.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits[1] & 8) != 0) {\n         int varPos1 = offset + 84 + buf.getIntLE(offset + 52);\n         int favoriteMaterialsCount = VarInt.peek(buf, varPos1);\n         if (favoriteMaterialsCount < 0) {\n            throw ProtocolException.negativeLength(\"FavoriteMaterials\", favoriteMaterialsCount);\n         }\n\n         if (favoriteMaterialsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"FavoriteMaterials\", favoriteMaterialsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)favoriteMaterialsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"FavoriteMaterials\", varPos1 + varIntLen + favoriteMaterialsCount * 2, buf.readableBytes());\n         }\n\n         obj.favoriteMaterials = new BuilderToolBlockArg[favoriteMaterialsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < favoriteMaterialsCount; i++) {\n            obj.favoriteMaterials[i] = BuilderToolBlockArg.deserialize(buf, elemPos);\n            elemPos += BuilderToolBlockArg.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits[1] & 16) != 0) {\n         int varPos2 = offset + 84 + buf.getIntLE(offset + 56);\n         obj.mask = BuilderToolMaskArg.deserialize(buf, varPos2);\n      }\n\n      if ((nullBits[1] & 32) != 0) {\n         int varPos3 = offset + 84 + buf.getIntLE(offset + 60);\n         obj.maskAbove = BuilderToolMaskArg.deserialize(buf, varPos3);\n      }\n\n      if ((nullBits[1] & 64) != 0) {\n         int varPos4 = offset + 84 + buf.getIntLE(offset + 64);\n         obj.maskNot = BuilderToolMaskArg.deserialize(buf, varPos4);\n      }\n\n      if ((nullBits[1] & 128) != 0) {\n         int varPos5 = offset + 84 + buf.getIntLE(offset + 68);\n         obj.maskBelow = BuilderToolMaskArg.deserialize(buf, varPos5);\n      }\n\n      if ((nullBits[2] & 1) != 0) {\n         int varPos6 = offset + 84 + buf.getIntLE(offset + 72);\n         obj.maskAdjacent = BuilderToolMaskArg.deserialize(buf, varPos6);\n      }\n\n      if ((nullBits[2] & 2) != 0) {\n         int varPos7 = offset + 84 + buf.getIntLE(offset + 76);\n         obj.maskNeighbor = BuilderToolMaskArg.deserialize(buf, varPos7);\n      }\n\n      if ((nullBits[2] & 4) != 0) {\n         int varPos8 = offset + 84 + buf.getIntLE(offset + 80);\n         int maskCommandsCount = VarInt.peek(buf, varPos8);\n         if (maskCommandsCount < 0) {\n            throw ProtocolException.negativeLength(\"MaskCommands\", maskCommandsCount);\n         }\n\n         if (maskCommandsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"MaskCommands\", maskCommandsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos8);\n         if ((long)(varPos8 + varIntLen) + (long)maskCommandsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"MaskCommands\", varPos8 + varIntLen + maskCommandsCount * 1, buf.readableBytes());\n         }\n\n         obj.maskCommands = new BuilderToolStringArg[maskCommandsCount];\n         int elemPos = varPos8 + varIntLen;\n\n         for (int i = 0; i < maskCommandsCount; i++) {\n            obj.maskCommands[i] = BuilderToolStringArg.deserialize(buf, elemPos);\n            elemPos += BuilderToolStringArg.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static BuilderToolBrushData deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolBrushData obj = new BuilderToolBrushData();\n      byte[] nullBits = PacketIO.readBytes(buf, offset, 3);\n      if ((nullBits[0] & 1) != 0) {\n         obj.width = BuilderToolIntArg.deserialize(buf, offset + 3);\n      }\n\n      if ((nullBits[0] & 2) != 0) {\n         obj.height = BuilderToolIntArg.deserialize(buf, offset + 15);\n      }\n\n      if ((nullBits[0] & 4) != 0) {\n         obj.thickness = BuilderToolIntArg.deserialize(buf, offset + 27);\n      }\n\n      if ((nullBits[0] & 8) != 0) {\n         obj.capped = BuilderToolBoolArg.deserialize(buf, offset + 39);\n      }\n\n      if ((nullBits[0] & 16) != 0) {\n         obj.shape = BuilderToolBrushShapeArg.deserialize(buf, offset + 40);\n      }\n\n      if ((nullBits[0] & 32) != 0) {\n         obj.origin = BuilderToolBrushOriginArg.deserialize(buf, offset + 41);\n      }\n\n      if ((nullBits[0] & 64) != 0) {\n         obj.originRotation = BuilderToolBoolArg.deserialize(buf, offset + 42);\n      }\n\n      if ((nullBits[0] & 128) != 0) {\n         obj.rotationAxis = BuilderToolBrushAxisArg.deserialize(buf, offset + 43);\n      }\n\n      if ((nullBits[1] & 1) != 0) {\n         obj.rotationAngle = BuilderToolRotationArg.deserialize(buf, offset + 44);\n      }\n\n      if ((nullBits[1] & 2) != 0) {\n         obj.mirrorAxis = BuilderToolBrushAxisArg.deserialize(buf, offset + 45);\n      }\n\n      if ((nullBits[2] & 8) != 0) {\n         obj.useMaskCommands = BuilderToolBoolArg.deserialize(buf, offset + 46);\n      }\n\n      if ((nullBits[2] & 16) != 0) {\n         obj.invertMask = BuilderToolBoolArg.deserialize(buf, offset + 47);\n      }\n\n      if ((nullBits[1] & 4) != 0) {\n         int varPos0 = offset + 84 + buf.getIntLE(offset + 48);\n         obj.material = BuilderToolBlockArg.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits[1] & 8) != 0) {\n         int varPos1 = offset + 84 + buf.getIntLE(offset + 52);\n         int favoriteMaterialsCount = VarInt.peek(buf, varPos1);\n         if (favoriteMaterialsCount < 0) {\n            throw ProtocolException.negativeLength(\"FavoriteMaterials\", favoriteMaterialsCount);\n         }\n\n         if (favoriteMaterialsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"FavoriteMaterials\", favoriteMaterialsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)favoriteMaterialsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"FavoriteMaterials\", varPos1 + varIntLen + favoriteMaterialsCount * 2, buf.readableBytes());\n         }\n\n         obj.favoriteMaterials = new BuilderToolBlockArg[favoriteMaterialsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < favoriteMaterialsCount; i++) {\n            obj.favoriteMaterials[i] = BuilderToolBlockArg.deserialize(buf, elemPos);\n            elemPos += BuilderToolBlockArg.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits[1] & 16) != 0) {\n         int varPos2 = offset + 84 + buf.getIntLE(offset + 56);\n         obj.mask = BuilderToolMaskArg.deserialize(buf, varPos2);\n      }\n\n      if ((nullBits[1] & 32) != 0) {\n         int varPos3 = offset + 84 + buf.getIntLE(offset + 60);\n         obj.maskAbove = BuilderToolMaskArg.deserialize(buf, varPos3);\n      }\n\n      if ((nullBits[1] & 64) != 0) {\n         int varPos4 = offset + 84 + buf.getIntLE(offset + 64);\n         obj.maskNot = BuilderToolMaskArg.deserialize(buf, varPos4);\n      }\n\n      if ((nullBits[1] & 128) != 0) {\n         int varPos5 = offset + 84 + buf.getIntLE(offset + 68);\n         obj.maskBelow = BuilderToolMaskArg.deserialize(buf, varPos5);\n      }\n\n      if ((nullBits[2] & 1) != 0) {\n         int varPos6 = offset + 84 + buf.getIntLE(offset + 72);\n         obj.maskAdjacent = BuilderToolMaskArg.deserialize(buf, varPos6);\n      }\n\n      if ((nullBits[2] & 2) != 0) {\n         int varPos7 = offset + 84 + buf.getIntLE(offset + 76);\n         obj.maskNeighbor = BuilderToolMaskArg.deserialize(buf, varPos7);\n      }\n\n      if ((nullBits[2] & 4) != 0) {\n         int varPos8 = offset + 84 + buf.getIntLE(offset + 80);\n         int maskCommandsCount = VarInt.peek(buf, varPos8);\n         if (maskCommandsCount < 0) {\n            throw ProtocolException.negativeLength(\"MaskCommands\", maskCommandsCount);\n         }\n\n         if (maskCommandsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"MaskCommands\", maskCommandsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos8);\n         if ((long)(varPos8 + varIntLen) + (long)maskCommandsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"MaskCommands\", varPos8 + varIntLen + maskCommandsCount * 1, buf.readableBytes());\n         }\n\n         obj.maskCommands = new BuilderToolStringArg[maskCommandsCount];\n         int elemPos = varPos8 + varIntLen;\n\n         for (int i = 0; i < maskCommandsCount; i++) {\n            obj.maskCommands[i] = BuilderToolStringArg.deserialize(buf, elemPos);\n            elemPos += BuilderToolStringArg.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte[] nullBits = PacketIO.readBytes(buf, offset, 3);\n      int maxEnd = 84;\n      if ((nullBits[1] & 4) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 48);\n         int pos0 = offset + 84 + fieldOffset0;\n         pos0 += BuilderToolBlockArg.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits[1] & 8) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 52);\n         int pos1 = offset + 84 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos1 += BuilderToolBlockArg.computeBytesConsumed(buf, pos1);\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits[1] & 16) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 56);\n         int pos2 = offset + 84 + fieldOffset2;\n         pos2 += BuilderToolMaskArg.computeBytesConsumed(buf, pos2);\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      if ((nullBits[1] & 32) != 0) {\n         int fieldOffset3 = buf.getIntLE(offset + 60);\n         int pos3 = offset + 84 + fieldOffset3;\n         pos3 += BuilderToolMaskArg.computeBytesConsumed(buf, pos3);\n         if (pos3 - offset > maxEnd) {\n            maxEnd = pos3 - offset;\n         }\n      }\n\n      if ((nullBits[1] & 64) != 0) {\n         int fieldOffset4 = buf.getIntLE(offset + 64);\n         int pos4 = offset + 84 + fieldOffset4;\n         pos4 += BuilderToolMaskArg.computeBytesConsumed(buf, pos4);\n         if (pos4 - offset > maxEnd) {\n            maxEnd = pos4 - offset;\n         }\n      }\n\n      if ((nullBits[1] & 128) != 0) {\n         int fieldOffset5 = buf.getIntLE(offset + 68);\n         int pos5 = offset + 84 + fieldOffset5;\n         pos5 += BuilderToolMaskArg.computeBytesConsumed(buf, pos5);\n         if (pos5 - offset > maxEnd) {\n            maxEnd = pos5 - offset;\n         }\n      }\n\n      if ((nullBits[2] & 1) != 0) {\n         int fieldOffset6 = buf.getIntLE(offset + 72);\n         int pos6 = offset + 84 + fieldOffset6;\n         pos6 += BuilderToolMaskArg.computeBytesConsumed(buf, pos6);\n         if (pos6 - offset > maxEnd) {\n            maxEnd = pos6 - offset;\n         }\n      }\n\n      if ((nullBits[2] & 2) != 0) {\n         int fieldOffset7 = buf.getIntLE(offset + 76);\n         int pos7 = offset + 84 + fieldOffset7;\n         pos7 += BuilderToolMaskArg.computeBytesConsumed(buf, pos7);\n         if (pos7 - offset > maxEnd) {\n            maxEnd = pos7 - offset;\n         }\n      }\n\n      if ((nullBits[2] & 4) != 0) {\n         int fieldOffset8 = buf.getIntLE(offset + 80);\n         int pos8 = offset + 84 + fieldOffset8;\n         int arrLen = VarInt.peek(buf, pos8);\n         pos8 += VarInt.length(buf, pos8);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos8 += BuilderToolStringArg.computeBytesConsumed(buf, pos8);\n         }\n\n         if (pos8 - offset > maxEnd) {\n            maxEnd = pos8 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 84) {\n         return ValidationResult.error(\"Buffer too small: expected at least 84 bytes\");\n      } else {\n         byte[] nullBits = PacketIO.readBytes(buffer, offset, 3);\n         if ((nullBits[1] & 4) != 0) {\n            int materialOffset = buffer.getIntLE(offset + 48);\n            if (materialOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Material\");\n            }\n\n            int pos = offset + 84 + materialOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Material\");\n            }\n\n            ValidationResult materialResult = BuilderToolBlockArg.validateStructure(buffer, pos);\n            if (!materialResult.isValid()) {\n               return ValidationResult.error(\"Invalid Material: \" + materialResult.error());\n            }\n\n            pos += BuilderToolBlockArg.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits[1] & 8) != 0) {\n            int favoriteMaterialsOffset = buffer.getIntLE(offset + 52);\n            if (favoriteMaterialsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for FavoriteMaterials\");\n            }\n\n            int posx = offset + 84 + favoriteMaterialsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for FavoriteMaterials\");\n            }\n\n            int favoriteMaterialsCount = VarInt.peek(buffer, posx);\n            if (favoriteMaterialsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for FavoriteMaterials\");\n            }\n\n            if (favoriteMaterialsCount > 4096000) {\n               return ValidationResult.error(\"FavoriteMaterials exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < favoriteMaterialsCount; i++) {\n               ValidationResult structResult = BuilderToolBlockArg.validateStructure(buffer, posx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid BuilderToolBlockArg in FavoriteMaterials[\" + i + \"]: \" + structResult.error());\n               }\n\n               posx += BuilderToolBlockArg.computeBytesConsumed(buffer, posx);\n            }\n         }\n\n         if ((nullBits[1] & 16) != 0) {\n            int maskOffset = buffer.getIntLE(offset + 56);\n            if (maskOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Mask\");\n            }\n\n            int posxx = offset + 84 + maskOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Mask\");\n            }\n\n            ValidationResult maskResult = BuilderToolMaskArg.validateStructure(buffer, posxx);\n            if (!maskResult.isValid()) {\n               return ValidationResult.error(\"Invalid Mask: \" + maskResult.error());\n            }\n\n            posxx += BuilderToolMaskArg.computeBytesConsumed(buffer, posxx);\n         }\n\n         if ((nullBits[1] & 32) != 0) {\n            int maskAboveOffset = buffer.getIntLE(offset + 60);\n            if (maskAboveOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for MaskAbove\");\n            }\n\n            int posxxx = offset + 84 + maskAboveOffset;\n            if (posxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for MaskAbove\");\n            }\n\n            ValidationResult maskAboveResult = BuilderToolMaskArg.validateStructure(buffer, posxxx);\n            if (!maskAboveResult.isValid()) {\n               return ValidationResult.error(\"Invalid MaskAbove: \" + maskAboveResult.error());\n            }\n\n            posxxx += BuilderToolMaskArg.computeBytesConsumed(buffer, posxxx);\n         }\n\n         if ((nullBits[1] & 64) != 0) {\n            int maskNotOffset = buffer.getIntLE(offset + 64);\n            if (maskNotOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for MaskNot\");\n            }\n\n            int posxxxx = offset + 84 + maskNotOffset;\n            if (posxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for MaskNot\");\n            }\n\n            ValidationResult maskNotResult = BuilderToolMaskArg.validateStructure(buffer, posxxxx);\n            if (!maskNotResult.isValid()) {\n               return ValidationResult.error(\"Invalid MaskNot: \" + maskNotResult.error());\n            }\n\n            posxxxx += BuilderToolMaskArg.computeBytesConsumed(buffer, posxxxx);\n         }\n\n         if ((nullBits[1] & 128) != 0) {\n            int maskBelowOffset = buffer.getIntLE(offset + 68);\n            if (maskBelowOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for MaskBelow\");\n            }\n\n            int posxxxxx = offset + 84 + maskBelowOffset;\n            if (posxxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for MaskBelow\");\n            }\n\n            ValidationResult maskBelowResult = BuilderToolMaskArg.validateStructure(buffer, posxxxxx);\n            if (!maskBelowResult.isValid()) {\n               return ValidationResult.error(\"Invalid MaskBelow: \" + maskBelowResult.error());\n            }\n\n            posxxxxx += BuilderToolMaskArg.computeBytesConsumed(buffer, posxxxxx);\n         }\n\n         if ((nullBits[2] & 1) != 0) {\n            int maskAdjacentOffset = buffer.getIntLE(offset + 72);\n            if (maskAdjacentOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for MaskAdjacent\");\n            }\n\n            int posxxxxxx = offset + 84 + maskAdjacentOffset;\n            if (posxxxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for MaskAdjacent\");\n            }\n\n            ValidationResult maskAdjacentResult = BuilderToolMaskArg.validateStructure(buffer, posxxxxxx);\n            if (!maskAdjacentResult.isValid()) {\n               return ValidationResult.error(\"Invalid MaskAdjacent: \" + maskAdjacentResult.error());\n            }\n\n            posxxxxxx += BuilderToolMaskArg.computeBytesConsumed(buffer, posxxxxxx);\n         }\n\n         if ((nullBits[2] & 2) != 0) {\n            int maskNeighborOffset = buffer.getIntLE(offset + 76);\n            if (maskNeighborOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for MaskNeighbor\");\n            }\n\n            int posxxxxxxx = offset + 84 + maskNeighborOffset;\n            if (posxxxxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for MaskNeighbor\");\n            }\n\n            ValidationResult maskNeighborResult = BuilderToolMaskArg.validateStructure(buffer, posxxxxxxx);\n            if (!maskNeighborResult.isValid()) {\n               return ValidationResult.error(\"Invalid MaskNeighbor: \" + maskNeighborResult.error());\n            }\n\n            posxxxxxxx += BuilderToolMaskArg.computeBytesConsumed(buffer, posxxxxxxx);\n         }\n\n         if ((nullBits[2] & 4) != 0) {\n            int maskCommandsOffset = buffer.getIntLE(offset + 80);\n            if (maskCommandsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for MaskCommands\");\n            }\n\n            int posxxxxxxxx = offset + 84 + maskCommandsOffset;\n            if (posxxxxxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for MaskCommands\");\n            }\n\n            int maskCommandsCount = VarInt.peek(buffer, posxxxxxxxx);\n            if (maskCommandsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for MaskCommands\");\n            }\n\n            if (maskCommandsCount > 4096000) {\n               return ValidationResult.error(\"MaskCommands exceeds max length 4096000\");\n            }\n\n            posxxxxxxxx += VarInt.length(buffer, posxxxxxxxx);\n\n            for (int i = 0; i < maskCommandsCount; i++) {\n               ValidationResult structResult = BuilderToolStringArg.validateStructure(buffer, posxxxxxxxx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid BuilderToolStringArg in MaskCommands[\" + i + \"]: \" + structResult.error());\n               }\n\n               posxxxxxxxx += BuilderToolStringArg.computeBytesConsumed(buffer, posxxxxxxxx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: PacketIO.readBytes, BuilderToolIntArg.deserialize, BuilderToolBoolArg.deserialize, BuilderToolBrushShapeArg.deserialize, BuilderToolBrushOriginArg.deserialize, BuilderToolBrushAxisArg.deserialize, BuilderToolRotationArg.deserialize, buf.getIntLE, BuilderToolBlockArg.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, BuilderToolBlockArg.computeBytesConsumed, BuilderToolMaskArg.deserialize, BuilderToolStringArg.deserialize, BuilderToolStringArg.computeBytesConsumed\n// Types referenced: BuilderToolIntArg, BuilderToolBoolArg, BuilderToolBrushShapeArg, BuilderToolBrushOriginArg, BuilderToolBrushAxisArg, BuilderToolRotationArg, BuilderToolBlockArg, BuilderToolMaskArg, BuilderToolStringArg\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolFloatArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "float",
            "nullable": false
          },
          {
            "name": "min",
            "type": "float",
            "nullable": false
          },
          {
            "name": "max",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolFloatArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 12;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 12;\npublic static final int MAX_SIZE = 12;\n\n// === FIELDS ===\n@Nonnull float defaultValue;\n@Nonnull float min;\n@Nonnull float max;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolFloatArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolFloatArg obj = new BuilderToolFloatArg();\n      obj.defaultValue = buf.getFloatLE(offset + 0);\n      obj.min = buf.getFloatLE(offset + 4);\n      obj.max = buf.getFloatLE(offset + 8);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 12;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 12 ? ValidationResult.error(\"Buffer too small: expected at least 12 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getFloatLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolState",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "id",
            "type": "String",
            "nullable": true
          },
          {
            "name": "isBrush",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "brushData",
            "type": "BuilderToolBrushData",
            "nullable": true
          },
          {
            "name": "args",
            "type": "Map<String, BuilderToolArg>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolState\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 14;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable String id;\n@Nonnull boolean isBrush;\n@Nullable BuilderToolBrushData brushData;\n@Nullable Map<String, BuilderToolArg> args;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolState deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolState obj = new BuilderToolState();\n      byte nullBits = buf.getByte(offset);\n      obj.isBrush = buf.getByte(offset + 1) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 14 + buf.getIntLE(offset + 2);\n         int idLen = VarInt.peek(buf, varPos0);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         obj.id = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 14 + buf.getIntLE(offset + 6);\n         obj.brushData = BuilderToolBrushData.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 14 + buf.getIntLE(offset + 10);\n         int argsCount = VarInt.peek(buf, varPos2);\n         if (argsCount < 0) {\n            throw ProtocolException.negativeLength(\"Args\", argsCount);\n         }\n\n         if (argsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Args\", argsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         obj.args = new HashMap<>(argsCount);\n         int dictPos = varPos2 + varIntLen;\n\n         for (int i = 0; i < argsCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            BuilderToolArg val = BuilderToolArg.deserialize(buf, dictPos);\n            dictPos += BuilderToolArg.computeBytesConsumed(buf, dictPos);\n            if (obj.args.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"args\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static BuilderToolState deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolState obj = new BuilderToolState();\n      byte nullBits = buf.getByte(offset);\n      obj.isBrush = buf.getByte(offset + 1) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 14 + buf.getIntLE(offset + 2);\n         int idLen = VarInt.peek(buf, varPos0);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         obj.id = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 14 + buf.getIntLE(offset + 6);\n         obj.brushData = BuilderToolBrushData.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 14 + buf.getIntLE(offset + 10);\n         int argsCount = VarInt.peek(buf, varPos2);\n         if (argsCount < 0) {\n            throw ProtocolException.negativeLength(\"Args\", argsCount);\n         }\n\n         if (argsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Args\", argsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         obj.args = new HashMap<>(argsCount);\n         int dictPos = varPos2 + varIntLen;\n\n         for (int i = 0; i < argsCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            BuilderToolArg val = BuilderToolArg.deserialize(buf, dictPos);\n            dictPos += BuilderToolArg.computeBytesConsumed(buf, dictPos);\n            if (obj.args.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"args\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 14;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 2);\n         int pos0 = offset + 14 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 6);\n         int pos1 = offset + 14 + fieldOffset1;\n         pos1 += BuilderToolBrushData.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 10);\n         int pos2 = offset + 14 + fieldOffset2;\n         int dictLen = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos2);\n            pos2 += VarInt.length(buf, pos2) + sl;\n            pos2 += BuilderToolArg.computeBytesConsumed(buf, pos2);\n         }\n\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 14) {\n         return ValidationResult.error(\"Buffer too small: expected at least 14 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int idOffset = buffer.getIntLE(offset + 2);\n            if (idOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Id\");\n            }\n\n            int pos = offset + 14 + idOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Id\");\n            }\n\n            int idLen = VarInt.peek(buffer, pos);\n            if (idLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Id\");\n            }\n\n            if (idLen > 4096000) {\n               return ValidationResult.error(\"Id exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += idLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Id\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int brushDataOffset = buffer.getIntLE(offset + 6);\n            if (brushDataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for BrushData\");\n            }\n\n            int posx = offset + 14 + brushDataOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for BrushData\");\n            }\n\n            ValidationResult brushDataResult = BuilderToolBrushData.validateStructure(buffer, posx);\n            if (!brushDataResult.isValid()) {\n               return ValidationResult.error(\"Invalid BrushData: \" + brushDataResult.error());\n            }\n\n            posx += BuilderToolBrushData.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int argsOffset = buffer.getIntLE(offset + 10);\n            if (argsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Args\");\n            }\n\n            int posxx = offset + 14 + argsOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Args\");\n            }\n\n            int argsCount = VarInt.peek(buffer, posxx);\n            if (argsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Args\");\n            }\n\n            if (argsCount > 4096000) {\n               return ValidationResult.error(\"Args exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n\n            for (int i = 0; i < argsCount; i++) {\n               int keyLen = VarInt.peek(buffer, posxx);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               posxx += VarInt.length(buffer, posxx);\n               posxx += keyLen;\n               if (posxx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               posxx += BuilderToolArg.computeBytesConsumed(buffer, posxx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, BuilderToolBrushData.deserialize, ProtocolException.dictionaryTooLarge, VarInt.length, BuilderToolArg.deserialize, BuilderToolArg.computeBytesConsumed, obj.args.put, ProtocolException.duplicateKey\n// Types referenced: BuilderToolBrushData, BuilderToolArg\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolBrushShapeArg",
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "defaultValue",
            "type": "BrushShape",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolBrushShapeArg\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull BrushShape defaultValue;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolBrushShapeArg deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolBrushShapeArg obj = new BuilderToolBrushShapeArg();\n      obj.defaultValue = BrushShape.fromValue(buf.getByte(offset + 0));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: BrushShape.fromValue, buf.getByte\n// Types referenced: BrushShape\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolArgUpdate",
        "packetId": 400,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "token",
            "type": "int",
            "nullable": false
          },
          {
            "name": "section",
            "type": "int",
            "nullable": false
          },
          {
            "name": "slot",
            "type": "int",
            "nullable": false
          },
          {
            "name": "group",
            "type": "BuilderToolArgGroup",
            "nullable": false
          },
          {
            "name": "id",
            "type": "String",
            "nullable": true
          },
          {
            "name": "value",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolArgUpdate\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 400;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 14;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 22;\npublic static final int MAX_SIZE = 32768032;\n\n// === FIELDS ===\n@Nonnull int token;\n@Nonnull int section;\n@Nonnull int slot;\n@Nonnull BuilderToolArgGroup group;\n@Nullable String id;\n@Nullable String value;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolArgUpdate deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolArgUpdate obj = new BuilderToolArgUpdate();\n      byte nullBits = buf.getByte(offset);\n      obj.token = buf.getIntLE(offset + 1);\n      obj.section = buf.getIntLE(offset + 5);\n      obj.slot = buf.getIntLE(offset + 9);\n      obj.group = BuilderToolArgGroup.fromValue(buf.getByte(offset + 13));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 22 + buf.getIntLE(offset + 14);\n         int idLen = VarInt.peek(buf, varPos0);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         obj.id = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 22 + buf.getIntLE(offset + 18);\n         int valueLen = VarInt.peek(buf, varPos1);\n         if (valueLen < 0) {\n            throw ProtocolException.negativeLength(\"Value\", valueLen);\n         }\n\n         if (valueLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Value\", valueLen, 4096000);\n         }\n\n         obj.value = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 22;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 14);\n         int pos0 = offset + 22 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 18);\n         int pos1 = offset + 22 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 22) {\n         return ValidationResult.error(\"Buffer too small: expected at least 22 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int idOffset = buffer.getIntLE(offset + 14);\n            if (idOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Id\");\n            }\n\n            int pos = offset + 22 + idOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Id\");\n            }\n\n            int idLen = VarInt.peek(buffer, pos);\n            if (idLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Id\");\n            }\n\n            if (idLen > 4096000) {\n               return ValidationResult.error(\"Id exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += idLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Id\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int valueOffset = buffer.getIntLE(offset + 18);\n            if (valueOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Value\");\n            }\n\n            int posx = offset + 22 + valueOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Value\");\n            }\n\n            int valueLen = VarInt.peek(buffer, posx);\n            if (valueLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Value\");\n            }\n\n            if (valueLen > 4096000) {\n               return ValidationResult.error(\"Value exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += valueLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Value\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, BuilderToolArgGroup.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: BuilderToolArgGroup\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolEntityAction",
        "packetId": 401,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "entityId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "action",
            "type": "EntityToolAction",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolEntityAction\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 401;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 5;\n\n// === FIELDS ===\n@Nonnull int entityId;\n@Nonnull EntityToolAction action;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolEntityAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolEntityAction obj = new BuilderToolEntityAction();\n      obj.entityId = buf.getIntLE(offset + 0);\n      obj.action = EntityToolAction.fromValue(buf.getByte(offset + 4));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 5;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 5 ? ValidationResult.error(\"Buffer too small: expected at least 5 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, EntityToolAction.fromValue, buf.getByte\n// Types referenced: EntityToolAction\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolSetEntityTransform",
        "packetId": 402,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "entityId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "modelTransform",
            "type": "ModelTransform",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolSetEntityTransform\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 402;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 54;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 54;\npublic static final int MAX_SIZE = 54;\n\n// === FIELDS ===\n@Nonnull int entityId;\n@Nullable ModelTransform modelTransform;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolSetEntityTransform deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSetEntityTransform obj = new BuilderToolSetEntityTransform();\n      byte nullBits = buf.getByte(offset);\n      obj.entityId = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.modelTransform = ModelTransform.deserialize(buf, offset + 5);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static BuilderToolSetEntityTransform deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSetEntityTransform obj = new BuilderToolSetEntityTransform();\n      byte nullBits = buf.getByte(offset);\n      obj.entityId = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.modelTransform = ModelTransform.deserialize(buf, offset + 5);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 54;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 54 ? ValidationResult.error(\"Buffer too small: expected at least 54 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, ModelTransform.deserialize\n// Types referenced: ModelTransform\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolExtrudeAction",
        "packetId": 403,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "xNormal",
            "type": "int",
            "nullable": false
          },
          {
            "name": "yNormal",
            "type": "int",
            "nullable": false
          },
          {
            "name": "zNormal",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolExtrudeAction\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 403;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 24;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 24;\npublic static final int MAX_SIZE = 24;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n@Nonnull int xNormal;\n@Nonnull int yNormal;\n@Nonnull int zNormal;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolExtrudeAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolExtrudeAction obj = new BuilderToolExtrudeAction();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      obj.xNormal = buf.getIntLE(offset + 12);\n      obj.yNormal = buf.getIntLE(offset + 16);\n      obj.zNormal = buf.getIntLE(offset + 20);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 24;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 24 ? ValidationResult.error(\"Buffer too small: expected at least 24 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolStackArea",
        "packetId": 404,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "selectionMin",
            "type": "BlockPosition",
            "nullable": true
          },
          {
            "name": "selectionMax",
            "type": "BlockPosition",
            "nullable": true
          },
          {
            "name": "xNormal",
            "type": "int",
            "nullable": false
          },
          {
            "name": "yNormal",
            "type": "int",
            "nullable": false
          },
          {
            "name": "zNormal",
            "type": "int",
            "nullable": false
          },
          {
            "name": "numStacks",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolStackArea\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 404;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 41;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 41;\npublic static final int MAX_SIZE = 41;\n\n// === FIELDS ===\n@Nullable BlockPosition selectionMin;\n@Nullable BlockPosition selectionMax;\n@Nonnull int xNormal;\n@Nonnull int yNormal;\n@Nonnull int zNormal;\n@Nonnull int numStacks;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolStackArea deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolStackArea obj = new BuilderToolStackArea();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.selectionMin = BlockPosition.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 2) != 0) {\n         obj.selectionMax = BlockPosition.deserialize(buf, offset + 13);\n      }\n\n      obj.xNormal = buf.getIntLE(offset + 25);\n      obj.yNormal = buf.getIntLE(offset + 29);\n      obj.zNormal = buf.getIntLE(offset + 33);\n      obj.numStacks = buf.getIntLE(offset + 37);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static BuilderToolStackArea deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolStackArea obj = new BuilderToolStackArea();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.selectionMin = BlockPosition.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 2) != 0) {\n         obj.selectionMax = BlockPosition.deserialize(buf, offset + 13);\n      }\n\n      obj.xNormal = buf.getIntLE(offset + 25);\n      obj.yNormal = buf.getIntLE(offset + 29);\n      obj.zNormal = buf.getIntLE(offset + 33);\n      obj.numStacks = buf.getIntLE(offset + 37);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 41;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 41 ? ValidationResult.error(\"Buffer too small: expected at least 41 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, BlockPosition.deserialize, buf.getIntLE\n// Types referenced: BlockPosition\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolSelectionTransform",
        "packetId": 405,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "transformationMatrix",
            "type": "float[]",
            "nullable": true
          },
          {
            "name": "initialSelectionMin",
            "type": "BlockPosition",
            "nullable": true
          },
          {
            "name": "initialSelectionMax",
            "type": "BlockPosition",
            "nullable": true
          },
          {
            "name": "initialRotationOrigin",
            "type": "Vector3f",
            "nullable": true
          },
          {
            "name": "cutOriginal",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "applyTransformationToSelectionMinMax",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "isExitingTransformMode",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "initialPastePointForClipboardPaste",
            "type": "BlockPosition",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolSelectionTransform\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 405;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 52;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 52;\npublic static final int MAX_SIZE = 16384057;\n\n// === FIELDS ===\n@Nullable float[] transformationMatrix;\n@Nullable BlockPosition initialSelectionMin;\n@Nullable BlockPosition initialSelectionMax;\n@Nullable Vector3f initialRotationOrigin;\n@Nonnull boolean cutOriginal;\n@Nonnull boolean applyTransformationToSelectionMinMax;\n@Nonnull boolean isExitingTransformMode;\n@Nullable BlockPosition initialPastePointForClipboardPaste;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolSelectionTransform deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSelectionTransform obj = new BuilderToolSelectionTransform();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 2) != 0) {\n         obj.initialSelectionMin = BlockPosition.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         obj.initialSelectionMax = BlockPosition.deserialize(buf, offset + 13);\n      }\n\n      if ((nullBits & 8) != 0) {\n         obj.initialRotationOrigin = Vector3f.deserialize(buf, offset + 25);\n      }\n\n      obj.cutOriginal = buf.getByte(offset + 37) != 0;\n      obj.applyTransformationToSelectionMinMax = buf.getByte(offset + 38) != 0;\n      obj.isExitingTransformMode = buf.getByte(offset + 39) != 0;\n      if ((nullBits & 16) != 0) {\n         obj.initialPastePointForClipboardPaste = BlockPosition.deserialize(buf, offset + 40);\n      }\n\n      int pos = offset + 52;\n      if ((nullBits & 1) != 0) {\n         int transformationMatrixCount = VarInt.peek(buf, pos);\n         if (transformationMatrixCount < 0) {\n            throw ProtocolException.negativeLength(\"TransformationMatrix\", transformationMatrixCount);\n         }\n\n         if (transformationMatrixCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"TransformationMatrix\", transformationMatrixCount, 4096000);\n         }\n\n         int transformationMatrixVarLen = VarInt.size(transformationMatrixCount);\n         if ((long)(pos + transformationMatrixVarLen) + (long)transformationMatrixCount * 4L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\n               \"TransformationMatrix\", pos + transformationMatrixVarLen + transformationMatrixCount * 4, buf.readableBytes()\n            );\n         }\n\n         pos += transformationMatrixVarLen;\n         obj.transformationMatrix = new float[transformationMatrixCount];\n\n         for (int i = 0; i < transformationMatrixCount; i++) {\n            obj.transformationMatrix[i] = buf.getFloatLE(pos + i * 4);\n         }\n\n         pos += transformationMatrixCount * 4;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static BuilderToolSelectionTransform deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSelectionTransform obj = new BuilderToolSelectionTransform();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 2) != 0) {\n         obj.initialSelectionMin = BlockPosition.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         obj.initialSelectionMax = BlockPosition.deserialize(buf, offset + 13);\n      }\n\n      if ((nullBits & 8) != 0) {\n         obj.initialRotationOrigin = Vector3f.deserialize(buf, offset + 25);\n      }\n\n      obj.cutOriginal = buf.getByte(offset + 37) != 0;\n      obj.applyTransformationToSelectionMinMax = buf.getByte(offset + 38) != 0;\n      obj.isExitingTransformMode = buf.getByte(offset + 39) != 0;\n      if ((nullBits & 16) != 0) {\n         obj.initialPastePointForClipboardPaste = BlockPosition.deserialize(buf, offset + 40);\n      }\n\n      int pos = offset + 52;\n      if ((nullBits & 1) != 0) {\n         int transformationMatrixCount = VarInt.peek(buf, pos);\n         if (transformationMatrixCount < 0) {\n            throw ProtocolException.negativeLength(\"TransformationMatrix\", transformationMatrixCount);\n         }\n\n         if (transformationMatrixCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"TransformationMatrix\", transformationMatrixCount, 4096000);\n         }\n\n         int transformationMatrixVarLen = VarInt.size(transformationMatrixCount);\n         if ((long)(pos + transformationMatrixVarLen) + (long)transformationMatrixCount * 4L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\n               \"TransformationMatrix\", pos + transformationMatrixVarLen + transformationMatrixCount * 4, buf.readableBytes()\n            );\n         }\n\n         pos += transformationMatrixVarLen;\n         obj.transformationMatrix = new float[transformationMatrixCount];\n\n         for (int i = 0; i < transformationMatrixCount; i++) {\n            obj.transformationMatrix[i] = buf.getFloatLE(pos + i * 4);\n         }\n\n         pos += transformationMatrixCount * 4;\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 52;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 4;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 52) {\n         return ValidationResult.error(\"Buffer too small: expected at least 52 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 52;\n         if ((nullBits & 1) != 0) {\n            int transformationMatrixCount = VarInt.peek(buffer, pos);\n            if (transformationMatrixCount < 0) {\n               return ValidationResult.error(\"Invalid array count for TransformationMatrix\");\n            }\n\n            if (transformationMatrixCount > 4096000) {\n               return ValidationResult.error(\"TransformationMatrix exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += transformationMatrixCount * 4;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading TransformationMatrix\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, BlockPosition.deserialize, Vector3f.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, buf.getFloatLE\n// Types referenced: BlockPosition, Vector3f\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolRotateClipboard",
        "packetId": 406,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "angle",
            "type": "int",
            "nullable": false
          },
          {
            "name": "axis",
            "type": "Axis",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolRotateClipboard\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 406;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 5;\n\n// === FIELDS ===\n@Nonnull int angle;\n@Nonnull Axis axis;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolRotateClipboard deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolRotateClipboard obj = new BuilderToolRotateClipboard();\n      obj.angle = buf.getIntLE(offset + 0);\n      obj.axis = Axis.fromValue(buf.getByte(offset + 4));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 5;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 5 ? ValidationResult.error(\"Buffer too small: expected at least 5 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, Axis.fromValue, buf.getByte\n// Types referenced: Axis\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolPasteClipboard",
        "packetId": 407,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolPasteClipboard\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 407;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 12;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 12;\npublic static final int MAX_SIZE = 12;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolPasteClipboard deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolPasteClipboard obj = new BuilderToolPasteClipboard();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 12;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 12 ? ValidationResult.error(\"Buffer too small: expected at least 12 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolSetTransformationModeState",
        "packetId": 408,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "enabled",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolSetTransformationModeState\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 408;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean enabled;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolSetTransformationModeState deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSetTransformationModeState obj = new BuilderToolSetTransformationModeState();\n      obj.enabled = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolSelectionUpdate",
        "packetId": 409,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "xMin",
            "type": "int",
            "nullable": false
          },
          {
            "name": "yMin",
            "type": "int",
            "nullable": false
          },
          {
            "name": "zMin",
            "type": "int",
            "nullable": false
          },
          {
            "name": "xMax",
            "type": "int",
            "nullable": false
          },
          {
            "name": "yMax",
            "type": "int",
            "nullable": false
          },
          {
            "name": "zMax",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolSelectionUpdate\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 409;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 24;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 24;\npublic static final int MAX_SIZE = 24;\n\n// === FIELDS ===\n@Nonnull int xMin;\n@Nonnull int yMin;\n@Nonnull int zMin;\n@Nonnull int xMax;\n@Nonnull int yMax;\n@Nonnull int zMax;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolSelectionUpdate deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSelectionUpdate obj = new BuilderToolSelectionUpdate();\n      obj.xMin = buf.getIntLE(offset + 0);\n      obj.yMin = buf.getIntLE(offset + 4);\n      obj.zMin = buf.getIntLE(offset + 8);\n      obj.xMax = buf.getIntLE(offset + 12);\n      obj.yMax = buf.getIntLE(offset + 16);\n      obj.zMax = buf.getIntLE(offset + 20);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 24;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 24 ? ValidationResult.error(\"Buffer too small: expected at least 24 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolSelectionToolAskForClipboard",
        "packetId": 410,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [],
        "deserializeContext": "// Packet: BuilderToolSelectionToolAskForClipboard\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 410;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolSelectionToolAskForClipboard deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new BuilderToolSelectionToolAskForClipboard();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolSelectionToolReplyWithClipboard",
        "packetId": 411,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "blocksChange",
            "type": "BlockChange[]",
            "nullable": true
          },
          {
            "name": "fluidsChange",
            "type": "FluidChange[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolSelectionToolReplyWithClipboard\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 411;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 139264019;\n\n// === FIELDS ===\n@Nullable BlockChange[] blocksChange;\n@Nullable FluidChange[] fluidsChange;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolSelectionToolReplyWithClipboard deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSelectionToolReplyWithClipboard obj = new BuilderToolSelectionToolReplyWithClipboard();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int blocksChangeCount = VarInt.peek(buf, varPos0);\n         if (blocksChangeCount < 0) {\n            throw ProtocolException.negativeLength(\"BlocksChange\", blocksChangeCount);\n         }\n\n         if (blocksChangeCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"BlocksChange\", blocksChangeCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)blocksChangeCount * 17L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"BlocksChange\", varPos0 + varIntLen + blocksChangeCount * 17, buf.readableBytes());\n         }\n\n         obj.blocksChange = new BlockChange[blocksChangeCount];\n         int elemPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < blocksChangeCount; i++) {\n            obj.blocksChange[i] = BlockChange.deserialize(buf, elemPos);\n            elemPos += BlockChange.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int fluidsChangeCount = VarInt.peek(buf, varPos1);\n         if (fluidsChangeCount < 0) {\n            throw ProtocolException.negativeLength(\"FluidsChange\", fluidsChangeCount);\n         }\n\n         if (fluidsChangeCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"FluidsChange\", fluidsChangeCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)fluidsChangeCount * 17L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"FluidsChange\", varPos1 + varIntLen + fluidsChangeCount * 17, buf.readableBytes());\n         }\n\n         obj.fluidsChange = new FluidChange[fluidsChangeCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < fluidsChangeCount; i++) {\n            obj.fluidsChange[i] = FluidChange.deserialize(buf, elemPos);\n            elemPos += FluidChange.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static BuilderToolSelectionToolReplyWithClipboard deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSelectionToolReplyWithClipboard obj = new BuilderToolSelectionToolReplyWithClipboard();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int blocksChangeCount = VarInt.peek(buf, varPos0);\n         if (blocksChangeCount < 0) {\n            throw ProtocolException.negativeLength(\"BlocksChange\", blocksChangeCount);\n         }\n\n         if (blocksChangeCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"BlocksChange\", blocksChangeCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)blocksChangeCount * 17L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"BlocksChange\", varPos0 + varIntLen + blocksChangeCount * 17, buf.readableBytes());\n         }\n\n         obj.blocksChange = new BlockChange[blocksChangeCount];\n         int elemPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < blocksChangeCount; i++) {\n            obj.blocksChange[i] = BlockChange.deserialize(buf, elemPos);\n            elemPos += BlockChange.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int fluidsChangeCount = VarInt.peek(buf, varPos1);\n         if (fluidsChangeCount < 0) {\n            throw ProtocolException.negativeLength(\"FluidsChange\", fluidsChangeCount);\n         }\n\n         if (fluidsChangeCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"FluidsChange\", fluidsChangeCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)fluidsChangeCount * 17L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"FluidsChange\", varPos1 + varIntLen + fluidsChangeCount * 17, buf.readableBytes());\n         }\n\n         obj.fluidsChange = new FluidChange[fluidsChangeCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < fluidsChangeCount; i++) {\n            obj.fluidsChange[i] = FluidChange.deserialize(buf, elemPos);\n            elemPos += FluidChange.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         int arrLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos0 += BlockChange.computeBytesConsumed(buf, pos0);\n         }\n\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos1 += FluidChange.computeBytesConsumed(buf, pos1);\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int blocksChangeOffset = buffer.getIntLE(offset + 1);\n            if (blocksChangeOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for BlocksChange\");\n            }\n\n            int pos = offset + 9 + blocksChangeOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for BlocksChange\");\n            }\n\n            int blocksChangeCount = VarInt.peek(buffer, pos);\n            if (blocksChangeCount < 0) {\n               return ValidationResult.error(\"Invalid array count for BlocksChange\");\n            }\n\n            if (blocksChangeCount > 4096000) {\n               return ValidationResult.error(\"BlocksChange exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += blocksChangeCount * 17;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading BlocksChange\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int fluidsChangeOffset = buffer.getIntLE(offset + 5);\n            if (fluidsChangeOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for FluidsChange\");\n            }\n\n            int posx = offset + 9 + fluidsChangeOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for FluidsChange\");\n            }\n\n            int fluidsChangeCount = VarInt.peek(buffer, posx);\n            if (fluidsChangeCount < 0) {\n               return ValidationResult.error(\"Invalid array count for FluidsChange\");\n            }\n\n            if (fluidsChangeCount > 4096000) {\n               return ValidationResult.error(\"FluidsChange exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += fluidsChangeCount * 17;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading FluidsChange\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, BlockChange.deserialize, BlockChange.computeBytesConsumed, FluidChange.deserialize, FluidChange.computeBytesConsumed\n// Types referenced: BlockChange, FluidChange\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolGeneralAction",
        "packetId": 412,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "action",
            "type": "BuilderToolAction",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolGeneralAction\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 412;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull BuilderToolAction action;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolGeneralAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolGeneralAction obj = new BuilderToolGeneralAction();\n      obj.action = BuilderToolAction.fromValue(buf.getByte(offset + 0));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: BuilderToolAction.fromValue, buf.getByte\n// Types referenced: BuilderToolAction\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolOnUseInteraction",
        "packetId": 413,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "type",
            "type": "InteractionType",
            "nullable": false
          },
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "offsetForPaintModeX",
            "type": "int",
            "nullable": false
          },
          {
            "name": "offsetForPaintModeY",
            "type": "int",
            "nullable": false
          },
          {
            "name": "offsetForPaintModeZ",
            "type": "int",
            "nullable": false
          },
          {
            "name": "isAltPlaySculptBrushModDown",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "isHoldDownInteraction",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "isDoServerRaytraceForPosition",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "isShowEditNotifications",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "maxLengthToolIgnoreHistory",
            "type": "int",
            "nullable": false
          },
          {
            "name": "raycastOriginX",
            "type": "float",
            "nullable": false
          },
          {
            "name": "raycastOriginY",
            "type": "float",
            "nullable": false
          },
          {
            "name": "raycastOriginZ",
            "type": "float",
            "nullable": false
          },
          {
            "name": "raycastDirectionX",
            "type": "float",
            "nullable": false
          },
          {
            "name": "raycastDirectionY",
            "type": "float",
            "nullable": false
          },
          {
            "name": "raycastDirectionZ",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolOnUseInteraction\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 413;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 57;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 57;\npublic static final int MAX_SIZE = 57;\n\n// === FIELDS ===\n@Nonnull InteractionType type;\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n@Nonnull int offsetForPaintModeX;\n@Nonnull int offsetForPaintModeY;\n@Nonnull int offsetForPaintModeZ;\n@Nonnull boolean isAltPlaySculptBrushModDown;\n@Nonnull boolean isHoldDownInteraction;\n@Nonnull boolean isDoServerRaytraceForPosition;\n@Nonnull boolean isShowEditNotifications;\n@Nonnull int maxLengthToolIgnoreHistory;\n@Nonnull float raycastOriginX;\n@Nonnull float raycastOriginY;\n@Nonnull float raycastOriginZ;\n@Nonnull float raycastDirectionX;\n@Nonnull float raycastDirectionY;\n@Nonnull float raycastDirectionZ;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolOnUseInteraction deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolOnUseInteraction obj = new BuilderToolOnUseInteraction();\n      obj.type = InteractionType.fromValue(buf.getByte(offset + 0));\n      obj.x = buf.getIntLE(offset + 1);\n      obj.y = buf.getIntLE(offset + 5);\n      obj.z = buf.getIntLE(offset + 9);\n      obj.offsetForPaintModeX = buf.getIntLE(offset + 13);\n      obj.offsetForPaintModeY = buf.getIntLE(offset + 17);\n      obj.offsetForPaintModeZ = buf.getIntLE(offset + 21);\n      obj.isAltPlaySculptBrushModDown = buf.getByte(offset + 25) != 0;\n      obj.isHoldDownInteraction = buf.getByte(offset + 26) != 0;\n      obj.isDoServerRaytraceForPosition = buf.getByte(offset + 27) != 0;\n      obj.isShowEditNotifications = buf.getByte(offset + 28) != 0;\n      obj.maxLengthToolIgnoreHistory = buf.getIntLE(offset + 29);\n      obj.raycastOriginX = buf.getFloatLE(offset + 33);\n      obj.raycastOriginY = buf.getFloatLE(offset + 37);\n      obj.raycastOriginZ = buf.getFloatLE(offset + 41);\n      obj.raycastDirectionX = buf.getFloatLE(offset + 45);\n      obj.raycastDirectionY = buf.getFloatLE(offset + 49);\n      obj.raycastDirectionZ = buf.getFloatLE(offset + 53);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 57;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 57 ? ValidationResult.error(\"Buffer too small: expected at least 57 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: InteractionType.fromValue, buf.getByte, buf.getIntLE, buf.getFloatLE\n// Types referenced: InteractionType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolLineAction",
        "packetId": 414,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "xStart",
            "type": "int",
            "nullable": false
          },
          {
            "name": "yStart",
            "type": "int",
            "nullable": false
          },
          {
            "name": "zStart",
            "type": "int",
            "nullable": false
          },
          {
            "name": "xEnd",
            "type": "int",
            "nullable": false
          },
          {
            "name": "yEnd",
            "type": "int",
            "nullable": false
          },
          {
            "name": "zEnd",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolLineAction\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 414;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 24;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 24;\npublic static final int MAX_SIZE = 24;\n\n// === FIELDS ===\n@Nonnull int xStart;\n@Nonnull int yStart;\n@Nonnull int zStart;\n@Nonnull int xEnd;\n@Nonnull int yEnd;\n@Nonnull int zEnd;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolLineAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolLineAction obj = new BuilderToolLineAction();\n      obj.xStart = buf.getIntLE(offset + 0);\n      obj.yStart = buf.getIntLE(offset + 4);\n      obj.zStart = buf.getIntLE(offset + 8);\n      obj.xEnd = buf.getIntLE(offset + 12);\n      obj.yEnd = buf.getIntLE(offset + 16);\n      obj.zEnd = buf.getIntLE(offset + 20);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 24;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 24 ? ValidationResult.error(\"Buffer too small: expected at least 24 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolShowAnchor",
        "packetId": 415,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolShowAnchor\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 415;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 12;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 12;\npublic static final int MAX_SIZE = 12;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolShowAnchor deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolShowAnchor obj = new BuilderToolShowAnchor();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 12;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 12 ? ValidationResult.error(\"Buffer too small: expected at least 12 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolHideAnchors",
        "packetId": 416,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [],
        "deserializeContext": "// Packet: BuilderToolHideAnchors\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 416;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolHideAnchors deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new BuilderToolHideAnchors();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PrefabUnselectPrefab",
        "packetId": 417,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [],
        "deserializeContext": "// Packet: PrefabUnselectPrefab\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 417;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PrefabUnselectPrefab deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new PrefabUnselectPrefab();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolsSetSoundSet",
        "packetId": 418,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "soundSetIndex",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolsSetSoundSet\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 418;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int soundSetIndex;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolsSetSoundSet deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolsSetSoundSet obj = new BuilderToolsSetSoundSet();\n      obj.soundSetIndex = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolLaserPointer",
        "packetId": 419,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "playerNetworkId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "startX",
            "type": "float",
            "nullable": false
          },
          {
            "name": "startY",
            "type": "float",
            "nullable": false
          },
          {
            "name": "startZ",
            "type": "float",
            "nullable": false
          },
          {
            "name": "endX",
            "type": "float",
            "nullable": false
          },
          {
            "name": "endY",
            "type": "float",
            "nullable": false
          },
          {
            "name": "endZ",
            "type": "float",
            "nullable": false
          },
          {
            "name": "color",
            "type": "int",
            "nullable": false
          },
          {
            "name": "durationMs",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolLaserPointer\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 419;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 36;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 36;\npublic static final int MAX_SIZE = 36;\n\n// === FIELDS ===\n@Nonnull int playerNetworkId;\n@Nonnull float startX;\n@Nonnull float startY;\n@Nonnull float startZ;\n@Nonnull float endX;\n@Nonnull float endY;\n@Nonnull float endZ;\n@Nonnull int color;\n@Nonnull int durationMs;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolLaserPointer deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolLaserPointer obj = new BuilderToolLaserPointer();\n      obj.playerNetworkId = buf.getIntLE(offset + 0);\n      obj.startX = buf.getFloatLE(offset + 4);\n      obj.startY = buf.getFloatLE(offset + 8);\n      obj.startZ = buf.getFloatLE(offset + 12);\n      obj.endX = buf.getFloatLE(offset + 16);\n      obj.endY = buf.getFloatLE(offset + 20);\n      obj.endZ = buf.getFloatLE(offset + 24);\n      obj.color = buf.getIntLE(offset + 28);\n      obj.durationMs = buf.getIntLE(offset + 32);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 36;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 36 ? ValidationResult.error(\"Buffer too small: expected at least 36 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getFloatLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolSetEntityScale",
        "packetId": 420,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "entityId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "scale",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolSetEntityScale\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 420;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 8;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 8;\npublic static final int MAX_SIZE = 8;\n\n// === FIELDS ===\n@Nonnull int entityId;\n@Nonnull float scale;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolSetEntityScale deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSetEntityScale obj = new BuilderToolSetEntityScale();\n      obj.entityId = buf.getIntLE(offset + 0);\n      obj.scale = buf.getFloatLE(offset + 4);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 8;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 8 ? ValidationResult.error(\"Buffer too small: expected at least 8 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getFloatLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolSetEntityPickupEnabled",
        "packetId": 421,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "entityId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "enabled",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolSetEntityPickupEnabled\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 421;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 5;\n\n// === FIELDS ===\n@Nonnull int entityId;\n@Nonnull boolean enabled;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolSetEntityPickupEnabled deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSetEntityPickupEnabled obj = new BuilderToolSetEntityPickupEnabled();\n      obj.entityId = buf.getIntLE(offset + 0);\n      obj.enabled = buf.getByte(offset + 4) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 5;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 5 ? ValidationResult.error(\"Buffer too small: expected at least 5 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolSetEntityLight",
        "packetId": 422,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "entityId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "light",
            "type": "ColorLight",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: BuilderToolSetEntityLight\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 422;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 9;\n\n// === FIELDS ===\n@Nonnull int entityId;\n@Nullable ColorLight light;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolSetEntityLight deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSetEntityLight obj = new BuilderToolSetEntityLight();\n      byte nullBits = buf.getByte(offset);\n      obj.entityId = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.light = ColorLight.deserialize(buf, offset + 5);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static BuilderToolSetEntityLight deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSetEntityLight obj = new BuilderToolSetEntityLight();\n      byte nullBits = buf.getByte(offset);\n      obj.entityId = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.light = ColorLight.deserialize(buf, offset + 5);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 9;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 9 ? ValidationResult.error(\"Buffer too small: expected at least 9 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, ColorLight.deserialize\n// Types referenced: ColorLight\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BuilderToolSetNPCDebug",
        "packetId": 423,
        "package": "com.hypixel.hytale.protocol.packets.buildertools",
        "fields": [
          {
            "name": "entityId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "enabled",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BuilderToolSetNPCDebug\n// Package: com.hypixel.hytale.protocol.packets.buildertools\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 423;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 5;\n\n// === FIELDS ===\n@Nonnull int entityId;\n@Nonnull boolean enabled;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BuilderToolSetNPCDebug deserialize(@Nonnull ByteBuf buf, int offset) {\n      BuilderToolSetNPCDebug obj = new BuilderToolSetNPCDebug();\n      obj.entityId = buf.getIntLE(offset + 0);\n      obj.enabled = buf.getByte(offset + 4) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 5;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 5 ? ValidationResult.error(\"Buffer too small: expected at least 5 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "player": [
      {
        "name": "SetClientId",
        "packetId": 100,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "clientId",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetClientId\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 100;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int clientId;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetClientId deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetClientId obj = new SetClientId();\n      obj.clientId = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetGameMode",
        "packetId": 101,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "gameMode",
            "type": "GameMode",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetGameMode\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 101;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull GameMode gameMode;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetGameMode deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetGameMode obj = new SetGameMode();\n      obj.gameMode = GameMode.fromValue(buf.getByte(offset + 0));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: GameMode.fromValue, buf.getByte\n// Types referenced: GameMode\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetMovementStates",
        "packetId": 102,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "movementStates",
            "type": "SavedMovementStates",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SetMovementStates\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 102;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 2;\n\n// === FIELDS ===\n@Nullable SavedMovementStates movementStates;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetMovementStates deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetMovementStates obj = new SetMovementStates();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.movementStates = SavedMovementStates.deserialize(buf, offset + 1);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SetMovementStates deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetMovementStates obj = new SetMovementStates();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.movementStates = SavedMovementStates.deserialize(buf, offset + 1);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 2;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 2 ? ValidationResult.error(\"Buffer too small: expected at least 2 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, SavedMovementStates.deserialize\n// Types referenced: SavedMovementStates\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetBlockPlacementOverride",
        "packetId": 103,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "enabled",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetBlockPlacementOverride\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 103;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean enabled;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetBlockPlacementOverride deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetBlockPlacementOverride obj = new SetBlockPlacementOverride();\n      obj.enabled = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "JoinWorld",
        "packetId": 104,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "clearWorld",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "fadeInOut",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "worldUuid",
            "type": "UUID",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: JoinWorld\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 104;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 18;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 18;\npublic static final int MAX_SIZE = 18;\n\n// === FIELDS ===\n@Nonnull boolean clearWorld;\n@Nonnull boolean fadeInOut;\n@Nonnull UUID worldUuid;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static JoinWorld deserialize(@Nonnull ByteBuf buf, int offset) {\n      JoinWorld obj = new JoinWorld();\n      obj.clearWorld = buf.getByte(offset + 0) != 0;\n      obj.fadeInOut = buf.getByte(offset + 1) != 0;\n      obj.worldUuid = PacketIO.readUUID(buf, offset + 2);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 18;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 18 ? ValidationResult.error(\"Buffer too small: expected at least 18 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, PacketIO.readUUID\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ClientReady",
        "packetId": 105,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "readyForChunks",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "readyForGameplay",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ClientReady\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 105;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 2;\n\n// === FIELDS ===\n@Nonnull boolean readyForChunks;\n@Nonnull boolean readyForGameplay;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ClientReady deserialize(@Nonnull ByteBuf buf, int offset) {\n      ClientReady obj = new ClientReady();\n      obj.readyForChunks = buf.getByte(offset + 0) != 0;\n      obj.readyForGameplay = buf.getByte(offset + 1) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 2;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 2 ? ValidationResult.error(\"Buffer too small: expected at least 2 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "LoadHotbar",
        "packetId": 106,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "inventoryRow",
            "type": "byte",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: LoadHotbar\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 106;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull byte inventoryRow;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static LoadHotbar deserialize(@Nonnull ByteBuf buf, int offset) {\n      LoadHotbar obj = new LoadHotbar();\n      obj.inventoryRow = buf.getByte(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SaveHotbar",
        "packetId": 107,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "inventoryRow",
            "type": "byte",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SaveHotbar\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 107;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull byte inventoryRow;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SaveHotbar deserialize(@Nonnull ByteBuf buf, int offset) {\n      SaveHotbar obj = new SaveHotbar();\n      obj.inventoryRow = buf.getByte(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ClientMovement",
        "packetId": 108,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "movementStates",
            "type": "MovementStates",
            "nullable": true
          },
          {
            "name": "relativePosition",
            "type": "HalfFloatPosition",
            "nullable": true
          },
          {
            "name": "absolutePosition",
            "type": "Position",
            "nullable": true
          },
          {
            "name": "bodyOrientation",
            "type": "Direction",
            "nullable": true
          },
          {
            "name": "lookOrientation",
            "type": "Direction",
            "nullable": true
          },
          {
            "name": "teleportAck",
            "type": "TeleportAck",
            "nullable": true
          },
          {
            "name": "wishMovement",
            "type": "Position",
            "nullable": true
          },
          {
            "name": "velocity",
            "type": "Vector3d",
            "nullable": true
          },
          {
            "name": "mountedTo",
            "type": "int",
            "nullable": false
          },
          {
            "name": "riderMovementStates",
            "type": "MovementStates",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: ClientMovement\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 108;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 2;\npublic static final int FIXED_BLOCK_SIZE = 153;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 153;\npublic static final int MAX_SIZE = 153;\n\n// === FIELDS ===\n@Nullable MovementStates movementStates;\n@Nullable HalfFloatPosition relativePosition;\n@Nullable Position absolutePosition;\n@Nullable Direction bodyOrientation;\n@Nullable Direction lookOrientation;\n@Nullable TeleportAck teleportAck;\n@Nullable Position wishMovement;\n@Nullable Vector3d velocity;\n@Nonnull int mountedTo;\n@Nullable MovementStates riderMovementStates;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ClientMovement deserialize(@Nonnull ByteBuf buf, int offset) {\n      ClientMovement obj = new ClientMovement();\n      byte[] nullBits = PacketIO.readBytes(buf, offset, 2);\n      if ((nullBits[0] & 1) != 0) {\n         obj.movementStates = MovementStates.deserialize(buf, offset + 2);\n      }\n\n      if ((nullBits[0] & 2) != 0) {\n         obj.relativePosition = HalfFloatPosition.deserialize(buf, offset + 24);\n      }\n\n      if ((nullBits[0] & 4) != 0) {\n         obj.absolutePosition = Position.deserialize(buf, offset + 30);\n      }\n\n      if ((nullBits[0] & 8) != 0) {\n         obj.bodyOrientation = Direction.deserialize(buf, offset + 54);\n      }\n\n      if ((nullBits[0] & 16) != 0) {\n         obj.lookOrientation = Direction.deserialize(buf, offset + 66);\n      }\n\n      if ((nullBits[0] & 32) != 0) {\n         obj.teleportAck = TeleportAck.deserialize(buf, offset + 78);\n      }\n\n      if ((nullBits[0] & 64) != 0) {\n         obj.wishMovement = Position.deserialize(buf, offset + 79);\n      }\n\n      if ((nullBits[0] & 128) != 0) {\n         obj.velocity = Vector3d.deserialize(buf, offset + 103);\n      }\n\n      obj.mountedTo = buf.getIntLE(offset + 127);\n      if ((nullBits[1] & 1) != 0) {\n         obj.riderMovementStates = MovementStates.deserialize(buf, offset + 131);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static ClientMovement deserialize(@Nonnull ByteBuf buf, int offset) {\n      ClientMovement obj = new ClientMovement();\n      byte[] nullBits = PacketIO.readBytes(buf, offset, 2);\n      if ((nullBits[0] & 1) != 0) {\n         obj.movementStates = MovementStates.deserialize(buf, offset + 2);\n      }\n\n      if ((nullBits[0] & 2) != 0) {\n         obj.relativePosition = HalfFloatPosition.deserialize(buf, offset + 24);\n      }\n\n      if ((nullBits[0] & 4) != 0) {\n         obj.absolutePosition = Position.deserialize(buf, offset + 30);\n      }\n\n      if ((nullBits[0] & 8) != 0) {\n         obj.bodyOrientation = Direction.deserialize(buf, offset + 54);\n      }\n\n      if ((nullBits[0] & 16) != 0) {\n         obj.lookOrientation = Direction.deserialize(buf, offset + 66);\n      }\n\n      if ((nullBits[0] & 32) != 0) {\n         obj.teleportAck = TeleportAck.deserialize(buf, offset + 78);\n      }\n\n      if ((nullBits[0] & 64) != 0) {\n         obj.wishMovement = Position.deserialize(buf, offset + 79);\n      }\n\n      if ((nullBits[0] & 128) != 0) {\n         obj.velocity = Vector3d.deserialize(buf, offset + 103);\n      }\n\n      obj.mountedTo = buf.getIntLE(offset + 127);\n      if ((nullBits[1] & 1) != 0) {\n         obj.riderMovementStates = MovementStates.deserialize(buf, offset + 131);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 153;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 153 ? ValidationResult.error(\"Buffer too small: expected at least 153 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: PacketIO.readBytes, MovementStates.deserialize, HalfFloatPosition.deserialize, Position.deserialize, Direction.deserialize, TeleportAck.deserialize, Vector3d.deserialize, buf.getIntLE\n// Types referenced: MovementStates, HalfFloatPosition, Position, Direction, TeleportAck, Vector3d\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ClientTeleport",
        "packetId": 109,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "teleportId",
            "type": "byte",
            "nullable": false
          },
          {
            "name": "modelTransform",
            "type": "ModelTransform",
            "nullable": true
          },
          {
            "name": "resetVelocity",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ClientTeleport\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 109;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 52;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 52;\npublic static final int MAX_SIZE = 52;\n\n// === FIELDS ===\n@Nonnull byte teleportId;\n@Nullable ModelTransform modelTransform;\n@Nonnull boolean resetVelocity;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ClientTeleport deserialize(@Nonnull ByteBuf buf, int offset) {\n      ClientTeleport obj = new ClientTeleport();\n      byte nullBits = buf.getByte(offset);\n      obj.teleportId = buf.getByte(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.modelTransform = ModelTransform.deserialize(buf, offset + 2);\n      }\n\n      obj.resetVelocity = buf.getByte(offset + 51) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static ClientTeleport deserialize(@Nonnull ByteBuf buf, int offset) {\n      ClientTeleport obj = new ClientTeleport();\n      byte nullBits = buf.getByte(offset);\n      obj.teleportId = buf.getByte(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.modelTransform = ModelTransform.deserialize(buf, offset + 2);\n      }\n\n      obj.resetVelocity = buf.getByte(offset + 51) != 0;\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 52;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 52 ? ValidationResult.error(\"Buffer too small: expected at least 52 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, ModelTransform.deserialize\n// Types referenced: ModelTransform\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateMovementSettings",
        "packetId": 110,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "movementSettings",
            "type": "MovementSettings",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateMovementSettings\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 110;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 252;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 252;\npublic static final int MAX_SIZE = 252;\n\n// === FIELDS ===\n@Nullable MovementSettings movementSettings;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateMovementSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateMovementSettings obj = new UpdateMovementSettings();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.movementSettings = MovementSettings.deserialize(buf, offset + 1);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateMovementSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateMovementSettings obj = new UpdateMovementSettings();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.movementSettings = MovementSettings.deserialize(buf, offset + 1);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 252;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 252 ? ValidationResult.error(\"Buffer too small: expected at least 252 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, MovementSettings.deserialize\n// Types referenced: MovementSettings\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "MouseInteraction",
        "packetId": 111,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "clientTimestamp",
            "type": "long",
            "nullable": false
          },
          {
            "name": "activeSlot",
            "type": "int",
            "nullable": false
          },
          {
            "name": "itemInHandId",
            "type": "String",
            "nullable": true
          },
          {
            "name": "screenPoint",
            "type": "Vector2f",
            "nullable": true
          },
          {
            "name": "mouseButton",
            "type": "MouseButtonEvent",
            "nullable": true
          },
          {
            "name": "mouseMotion",
            "type": "MouseMotionEvent",
            "nullable": true
          },
          {
            "name": "worldInteraction",
            "type": "WorldInteraction",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: MouseInteraction\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 111;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 44;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 52;\npublic static final int MAX_SIZE = 20480071;\n\n// === FIELDS ===\n@Nonnull long clientTimestamp;\n@Nonnull int activeSlot;\n@Nullable String itemInHandId;\n@Nullable Vector2f screenPoint;\n@Nullable MouseButtonEvent mouseButton;\n@Nullable MouseMotionEvent mouseMotion;\n@Nullable WorldInteraction worldInteraction;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static MouseInteraction deserialize(@Nonnull ByteBuf buf, int offset) {\n      MouseInteraction obj = new MouseInteraction();\n      byte nullBits = buf.getByte(offset);\n      obj.clientTimestamp = buf.getLongLE(offset + 1);\n      obj.activeSlot = buf.getIntLE(offset + 9);\n      if ((nullBits & 2) != 0) {\n         obj.screenPoint = Vector2f.deserialize(buf, offset + 13);\n      }\n\n      if ((nullBits & 4) != 0) {\n         obj.mouseButton = MouseButtonEvent.deserialize(buf, offset + 21);\n      }\n\n      if ((nullBits & 16) != 0) {\n         obj.worldInteraction = WorldInteraction.deserialize(buf, offset + 24);\n      }\n\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 52 + buf.getIntLE(offset + 44);\n         int itemInHandIdLen = VarInt.peek(buf, varPos0);\n         if (itemInHandIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ItemInHandId\", itemInHandIdLen);\n         }\n\n         if (itemInHandIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ItemInHandId\", itemInHandIdLen, 4096000);\n         }\n\n         obj.itemInHandId = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos1 = offset + 52 + buf.getIntLE(offset + 48);\n         obj.mouseMotion = MouseMotionEvent.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static MouseInteraction deserialize(@Nonnull ByteBuf buf, int offset) {\n      MouseInteraction obj = new MouseInteraction();\n      byte nullBits = buf.getByte(offset);\n      obj.clientTimestamp = buf.getLongLE(offset + 1);\n      obj.activeSlot = buf.getIntLE(offset + 9);\n      if ((nullBits & 2) != 0) {\n         obj.screenPoint = Vector2f.deserialize(buf, offset + 13);\n      }\n\n      if ((nullBits & 4) != 0) {\n         obj.mouseButton = MouseButtonEvent.deserialize(buf, offset + 21);\n      }\n\n      if ((nullBits & 16) != 0) {\n         obj.worldInteraction = WorldInteraction.deserialize(buf, offset + 24);\n      }\n\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 52 + buf.getIntLE(offset + 44);\n         int itemInHandIdLen = VarInt.peek(buf, varPos0);\n         if (itemInHandIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ItemInHandId\", itemInHandIdLen);\n         }\n\n         if (itemInHandIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ItemInHandId\", itemInHandIdLen, 4096000);\n         }\n\n         obj.itemInHandId = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos1 = offset + 52 + buf.getIntLE(offset + 48);\n         obj.mouseMotion = MouseMotionEvent.deserialize(buf, varPos1);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 52;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 44);\n         int pos0 = offset + 52 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 48);\n         int pos1 = offset + 52 + fieldOffset1;\n         pos1 += MouseMotionEvent.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 52) {\n         return ValidationResult.error(\"Buffer too small: expected at least 52 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int itemInHandIdOffset = buffer.getIntLE(offset + 44);\n            if (itemInHandIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ItemInHandId\");\n            }\n\n            int pos = offset + 52 + itemInHandIdOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ItemInHandId\");\n            }\n\n            int itemInHandIdLen = VarInt.peek(buffer, pos);\n            if (itemInHandIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ItemInHandId\");\n            }\n\n            if (itemInHandIdLen > 4096000) {\n               return ValidationResult.error(\"ItemInHandId exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += itemInHandIdLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ItemInHandId\");\n            }\n         }\n\n         if ((nullBits & 8) != 0) {\n            int mouseMotionOffset = buffer.getIntLE(offset + 48);\n            if (mouseMotionOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for MouseMotion\");\n            }\n\n            int posx = offset + 52 + mouseMotionOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for MouseMotion\");\n            }\n\n            ValidationResult mouseMotionResult = MouseMotionEvent.validateStructure(buffer, posx);\n            if (!mouseMotionResult.isValid()) {\n               return ValidationResult.error(\"Invalid MouseMotion: \" + mouseMotionResult.error());\n            }\n\n            posx += MouseMotionEvent.computeBytesConsumed(buffer, posx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getLongLE, buf.getIntLE, Vector2f.deserialize, MouseButtonEvent.deserialize, WorldInteraction.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, MouseMotionEvent.deserialize\n// Types referenced: Vector2f, MouseButtonEvent, WorldInteraction, MouseMotionEvent\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "DamageInfo",
        "packetId": 112,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "damageSourcePosition",
            "type": "Vector3d",
            "nullable": true
          },
          {
            "name": "damageAmount",
            "type": "float",
            "nullable": false
          },
          {
            "name": "damageCause",
            "type": "DamageCause",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: DamageInfo\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 112;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 29;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 29;\npublic static final int MAX_SIZE = 32768048;\n\n// === FIELDS ===\n@Nullable Vector3d damageSourcePosition;\n@Nonnull float damageAmount;\n@Nullable DamageCause damageCause;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static DamageInfo deserialize(@Nonnull ByteBuf buf, int offset) {\n      DamageInfo obj = new DamageInfo();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.damageSourcePosition = Vector3d.deserialize(buf, offset + 1);\n      }\n\n      obj.damageAmount = buf.getFloatLE(offset + 25);\n      int pos = offset + 29;\n      if ((nullBits & 2) != 0) {\n         obj.damageCause = DamageCause.deserialize(buf, pos);\n         pos += DamageCause.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static DamageInfo deserialize(@Nonnull ByteBuf buf, int offset) {\n      DamageInfo obj = new DamageInfo();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.damageSourcePosition = Vector3d.deserialize(buf, offset + 1);\n      }\n\n      obj.damageAmount = buf.getFloatLE(offset + 25);\n      int pos = offset + 29;\n      if ((nullBits & 2) != 0) {\n         obj.damageCause = DamageCause.deserialize(buf, pos);\n         pos += DamageCause.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 29;\n      if ((nullBits & 2) != 0) {\n         pos += DamageCause.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 29) {\n         return ValidationResult.error(\"Buffer too small: expected at least 29 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 29;\n         if ((nullBits & 2) != 0) {\n            ValidationResult damageCauseResult = DamageCause.validateStructure(buffer, pos);\n            if (!damageCauseResult.isValid()) {\n               return ValidationResult.error(\"Invalid DamageCause: \" + damageCauseResult.error());\n            }\n\n            pos += DamageCause.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, Vector3d.deserialize, buf.getFloatLE, DamageCause.deserialize, DamageCause.computeBytesConsumed\n// Types referenced: Vector3d, DamageCause\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ReticleEvent",
        "packetId": 113,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "eventIndex",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ReticleEvent\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 113;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int eventIndex;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ReticleEvent deserialize(@Nonnull ByteBuf buf, int offset) {\n      ReticleEvent obj = new ReticleEvent();\n      obj.eventIndex = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "DisplayDebug",
        "packetId": 114,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "shape",
            "type": "DebugShape",
            "nullable": false
          },
          {
            "name": "matrix",
            "type": "float[]",
            "nullable": true
          },
          {
            "name": "color",
            "type": "Vector3f",
            "nullable": true
          },
          {
            "name": "time",
            "type": "float",
            "nullable": false
          },
          {
            "name": "fade",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "frustumProjection",
            "type": "float[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: DisplayDebug\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 114;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 19;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 27;\npublic static final int MAX_SIZE = 32768037;\n\n// === FIELDS ===\n@Nonnull DebugShape shape;\n@Nullable float[] matrix;\n@Nullable Vector3f color;\n@Nonnull float time;\n@Nonnull boolean fade;\n@Nullable float[] frustumProjection;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static DisplayDebug deserialize(@Nonnull ByteBuf buf, int offset) {\n      DisplayDebug obj = new DisplayDebug();\n      byte nullBits = buf.getByte(offset);\n      obj.shape = DebugShape.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 2) != 0) {\n         obj.color = Vector3f.deserialize(buf, offset + 2);\n      }\n\n      obj.time = buf.getFloatLE(offset + 14);\n      obj.fade = buf.getByte(offset + 18) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 27 + buf.getIntLE(offset + 19);\n         int matrixCount = VarInt.peek(buf, varPos0);\n         if (matrixCount < 0) {\n            throw ProtocolException.negativeLength(\"Matrix\", matrixCount);\n         }\n\n         if (matrixCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Matrix\", matrixCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)matrixCount * 4L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Matrix\", varPos0 + varIntLen + matrixCount * 4, buf.readableBytes());\n         }\n\n         obj.matrix = new float[matrixCount];\n\n         for (int i = 0; i < matrixCount; i++) {\n            obj.matrix[i] = buf.getFloatLE(varPos0 + varIntLen + i * 4);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos1 = offset + 27 + buf.getIntLE(offset + 23);\n         int frustumProjectionCount = VarInt.peek(buf, varPos1);\n         if (frustumProjectionCount < 0) {\n            throw ProtocolException.negativeLength(\"FrustumProjection\", frustumProjectionCount);\n         }\n\n         if (frustumProjectionCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"FrustumProjection\", frustumProjectionCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)frustumProjectionCount * 4L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"FrustumProjection\", varPos1 + varIntLen + frustumProjectionCount * 4, buf.readableBytes());\n         }\n\n         obj.frustumProjection = new float[frustumProjectionCount];\n\n         for (int i = 0; i < frustumProjectionCount; i++) {\n            obj.frustumProjection[i] = buf.getFloatLE(varPos1 + varIntLen + i * 4);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static DisplayDebug deserialize(@Nonnull ByteBuf buf, int offset) {\n      DisplayDebug obj = new DisplayDebug();\n      byte nullBits = buf.getByte(offset);\n      obj.shape = DebugShape.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 2) != 0) {\n         obj.color = Vector3f.deserialize(buf, offset + 2);\n      }\n\n      obj.time = buf.getFloatLE(offset + 14);\n      obj.fade = buf.getByte(offset + 18) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 27 + buf.getIntLE(offset + 19);\n         int matrixCount = VarInt.peek(buf, varPos0);\n         if (matrixCount < 0) {\n            throw ProtocolException.negativeLength(\"Matrix\", matrixCount);\n         }\n\n         if (matrixCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Matrix\", matrixCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)matrixCount * 4L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Matrix\", varPos0 + varIntLen + matrixCount * 4, buf.readableBytes());\n         }\n\n         obj.matrix = new float[matrixCount];\n\n         for (int i = 0; i < matrixCount; i++) {\n            obj.matrix[i] = buf.getFloatLE(varPos0 + varIntLen + i * 4);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos1 = offset + 27 + buf.getIntLE(offset + 23);\n         int frustumProjectionCount = VarInt.peek(buf, varPos1);\n         if (frustumProjectionCount < 0) {\n            throw ProtocolException.negativeLength(\"FrustumProjection\", frustumProjectionCount);\n         }\n\n         if (frustumProjectionCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"FrustumProjection\", frustumProjectionCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)frustumProjectionCount * 4L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"FrustumProjection\", varPos1 + varIntLen + frustumProjectionCount * 4, buf.readableBytes());\n         }\n\n         obj.frustumProjection = new float[frustumProjectionCount];\n\n         for (int i = 0; i < frustumProjectionCount; i++) {\n            obj.frustumProjection[i] = buf.getFloatLE(varPos1 + varIntLen + i * 4);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 27;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 19);\n         int pos0 = offset + 27 + fieldOffset0;\n         int arrLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + arrLen * 4;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 23);\n         int pos1 = offset + 27 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + arrLen * 4;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 27) {\n         return ValidationResult.error(\"Buffer too small: expected at least 27 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int matrixOffset = buffer.getIntLE(offset + 19);\n            if (matrixOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Matrix\");\n            }\n\n            int pos = offset + 27 + matrixOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Matrix\");\n            }\n\n            int matrixCount = VarInt.peek(buffer, pos);\n            if (matrixCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Matrix\");\n            }\n\n            if (matrixCount > 4096000) {\n               return ValidationResult.error(\"Matrix exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += matrixCount * 4;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Matrix\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int frustumProjectionOffset = buffer.getIntLE(offset + 23);\n            if (frustumProjectionOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for FrustumProjection\");\n            }\n\n            int posx = offset + 27 + frustumProjectionOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for FrustumProjection\");\n            }\n\n            int frustumProjectionCount = VarInt.peek(buffer, posx);\n            if (frustumProjectionCount < 0) {\n               return ValidationResult.error(\"Invalid array count for FrustumProjection\");\n            }\n\n            if (frustumProjectionCount > 4096000) {\n               return ValidationResult.error(\"FrustumProjection exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += frustumProjectionCount * 4;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading FrustumProjection\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, DebugShape.fromValue, Vector3f.deserialize, buf.getFloatLE, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall\n// Types referenced: DebugShape, Vector3f\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ClearDebugShapes",
        "packetId": 115,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [],
        "deserializeContext": "// Packet: ClearDebugShapes\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 115;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ClearDebugShapes deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new ClearDebugShapes();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SyncPlayerPreferences",
        "packetId": 116,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "showEntityMarkers",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "armorItemsPreferredPickupLocation",
            "type": "PickupLocation",
            "nullable": false
          },
          {
            "name": "weaponAndToolItemsPreferredPickupLocation",
            "type": "PickupLocation",
            "nullable": false
          },
          {
            "name": "usableItemsItemsPreferredPickupLocation",
            "type": "PickupLocation",
            "nullable": false
          },
          {
            "name": "solidBlockItemsPreferredPickupLocation",
            "type": "PickupLocation",
            "nullable": false
          },
          {
            "name": "miscItemsPreferredPickupLocation",
            "type": "PickupLocation",
            "nullable": false
          },
          {
            "name": "allowNPCDetection",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "respondToHit",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SyncPlayerPreferences\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 116;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 8;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 8;\npublic static final int MAX_SIZE = 8;\n\n// === FIELDS ===\n@Nonnull boolean showEntityMarkers;\n@Nonnull PickupLocation armorItemsPreferredPickupLocation;\n@Nonnull PickupLocation weaponAndToolItemsPreferredPickupLocation;\n@Nonnull PickupLocation usableItemsItemsPreferredPickupLocation;\n@Nonnull PickupLocation solidBlockItemsPreferredPickupLocation;\n@Nonnull PickupLocation miscItemsPreferredPickupLocation;\n@Nonnull boolean allowNPCDetection;\n@Nonnull boolean respondToHit;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SyncPlayerPreferences deserialize(@Nonnull ByteBuf buf, int offset) {\n      SyncPlayerPreferences obj = new SyncPlayerPreferences();\n      obj.showEntityMarkers = buf.getByte(offset + 0) != 0;\n      obj.armorItemsPreferredPickupLocation = PickupLocation.fromValue(buf.getByte(offset + 1));\n      obj.weaponAndToolItemsPreferredPickupLocation = PickupLocation.fromValue(buf.getByte(offset + 2));\n      obj.usableItemsItemsPreferredPickupLocation = PickupLocation.fromValue(buf.getByte(offset + 3));\n      obj.solidBlockItemsPreferredPickupLocation = PickupLocation.fromValue(buf.getByte(offset + 4));\n      obj.miscItemsPreferredPickupLocation = PickupLocation.fromValue(buf.getByte(offset + 5));\n      obj.allowNPCDetection = buf.getByte(offset + 6) != 0;\n      obj.respondToHit = buf.getByte(offset + 7) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 8;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 8 ? ValidationResult.error(\"Buffer too small: expected at least 8 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, PickupLocation.fromValue\n// Types referenced: PickupLocation\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ClientPlaceBlock",
        "packetId": 117,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "position",
            "type": "BlockPosition",
            "nullable": true
          },
          {
            "name": "rotation",
            "type": "BlockRotation",
            "nullable": true
          },
          {
            "name": "placedBlockId",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ClientPlaceBlock\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 117;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 20;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 20;\npublic static final int MAX_SIZE = 20;\n\n// === FIELDS ===\n@Nullable BlockPosition position;\n@Nullable BlockRotation rotation;\n@Nonnull int placedBlockId;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ClientPlaceBlock deserialize(@Nonnull ByteBuf buf, int offset) {\n      ClientPlaceBlock obj = new ClientPlaceBlock();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.position = BlockPosition.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 2) != 0) {\n         obj.rotation = BlockRotation.deserialize(buf, offset + 13);\n      }\n\n      obj.placedBlockId = buf.getIntLE(offset + 16);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static ClientPlaceBlock deserialize(@Nonnull ByteBuf buf, int offset) {\n      ClientPlaceBlock obj = new ClientPlaceBlock();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.position = BlockPosition.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 2) != 0) {\n         obj.rotation = BlockRotation.deserialize(buf, offset + 13);\n      }\n\n      obj.placedBlockId = buf.getIntLE(offset + 16);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 20;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 20 ? ValidationResult.error(\"Buffer too small: expected at least 20 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, BlockPosition.deserialize, BlockRotation.deserialize, buf.getIntLE\n// Types referenced: BlockPosition, BlockRotation\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateMemoriesFeatureStatus",
        "packetId": 118,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "isFeatureUnlocked",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateMemoriesFeatureStatus\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 118;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean isFeatureUnlocked;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateMemoriesFeatureStatus deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateMemoriesFeatureStatus obj = new UpdateMemoriesFeatureStatus();\n      obj.isFeatureUnlocked = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "RemoveMapMarker",
        "packetId": 119,
        "package": "com.hypixel.hytale.protocol.packets.player",
        "fields": [
          {
            "name": "markerId",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: RemoveMapMarker\n// Package: com.hypixel.hytale.protocol.packets.player\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 119;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String markerId;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static RemoveMapMarker deserialize(@Nonnull ByteBuf buf, int offset) {\n      RemoveMapMarker obj = new RemoveMapMarker();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int markerIdLen = VarInt.peek(buf, pos);\n         if (markerIdLen < 0) {\n            throw ProtocolException.negativeLength(\"MarkerId\", markerIdLen);\n         }\n\n         if (markerIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"MarkerId\", markerIdLen, 4096000);\n         }\n\n         int markerIdVarLen = VarInt.length(buf, pos);\n         obj.markerId = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += markerIdVarLen + markerIdLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int markerIdLen = VarInt.peek(buffer, pos);\n            if (markerIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for MarkerId\");\n            }\n\n            if (markerIdLen > 4096000) {\n               return ValidationResult.error(\"MarkerId exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += markerIdLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading MarkerId\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "connection": [
      {
        "name": "Connect",
        "packetId": 0,
        "package": "com.hypixel.hytale.protocol.packets.connection",
        "fields": [
          {
            "name": "protocolHash",
            "type": "String",
            "nullable": false
          },
          {
            "name": "clientType",
            "type": "ClientType",
            "nullable": false
          },
          {
            "name": "language",
            "type": "String",
            "nullable": true
          },
          {
            "name": "identityToken",
            "type": "String",
            "nullable": true
          },
          {
            "name": "uuid",
            "type": "UUID",
            "nullable": false
          },
          {
            "name": "username",
            "type": "String",
            "nullable": false
          },
          {
            "name": "referralData",
            "type": "byte[]",
            "nullable": true
          },
          {
            "name": "referralSource",
            "type": "HostAddress",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: Connect\n// Package: com.hypixel.hytale.protocol.packets.connection\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 0;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 82;\npublic static final int VARIABLE_FIELD_COUNT = 5;\npublic static final int VARIABLE_BLOCK_START = 102;\npublic static final int MAX_SIZE = 38161;\n\n// === FIELDS ===\n@Nonnull String protocolHash;\n@Nonnull ClientType clientType;\n@Nullable String language;\n@Nullable String identityToken;\n@Nonnull UUID uuid;\n@Nonnull String username;\n@Nullable byte[] referralData;\n@Nullable HostAddress referralSource;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static Connect deserialize(@Nonnull ByteBuf buf, int offset) {\n      Connect obj = new Connect();\n      byte nullBits = buf.getByte(offset);\n      obj.protocolHash = PacketIO.readFixedAsciiString(buf, offset + 1, 64);\n      obj.clientType = ClientType.fromValue(buf.getByte(offset + 65));\n      obj.uuid = PacketIO.readUUID(buf, offset + 66);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 102 + buf.getIntLE(offset + 82);\n         int languageLen = VarInt.peek(buf, varPos0);\n         if (languageLen < 0) {\n            throw ProtocolException.negativeLength(\"Language\", languageLen);\n         }\n\n         if (languageLen > 128) {\n            throw ProtocolException.stringTooLong(\"Language\", languageLen, 128);\n         }\n\n         obj.language = PacketIO.readVarString(buf, varPos0, PacketIO.ASCII);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 102 + buf.getIntLE(offset + 86);\n         int identityTokenLen = VarInt.peek(buf, varPos1);\n         if (identityTokenLen < 0) {\n            throw ProtocolException.negativeLength(\"IdentityToken\", identityTokenLen);\n         }\n\n         if (identityTokenLen > 8192) {\n            throw ProtocolException.stringTooLong(\"IdentityToken\", identityTokenLen, 8192);\n         }\n\n         obj.identityToken = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      int varPos2 = offset + 102 + buf.getIntLE(offset + 90);\n      int usernameLen = VarInt.peek(buf, varPos2);\n      if (usernameLen < 0) {\n         throw ProtocolException.negativeLength(\"Username\", usernameLen);\n      } else if (usernameLen > 16) {\n         throw ProtocolException.stringTooLong(\"Username\", usernameLen, 16);\n      } else {\n         obj.username = PacketIO.readVarString(buf, varPos2, PacketIO.ASCII);\n         if ((nullBits & 4) != 0) {\n            varPos2 = offset + 102 + buf.getIntLE(offset + 94);\n            usernameLen = VarInt.peek(buf, varPos2);\n            if (usernameLen < 0) {\n               throw ProtocolException.negativeLength(\"ReferralData\", usernameLen);\n            }\n\n            if (usernameLen > 4096) {\n               throw ProtocolException.arrayTooLong(\"ReferralData\", usernameLen, 4096);\n            }\n\n            int varIntLen = VarInt.length(buf, varPos2);\n            if ((long)(varPos2 + varIntLen) + (long)usernameLen * 1L > (long)buf.readableBytes()) {\n               throw ProtocolException.bufferTooSmall(\"ReferralData\", varPos2 + varIntLen + usernameLen * 1, buf.readableBytes());\n            }\n\n            obj.referralData = new byte[usernameLen];\n\n            for (int i = 0; i < usernameLen; i++) {\n               obj.referralData[i] = buf.getByte(varPos2 + varIntLen + i * 1);\n            }\n         }\n\n         if ((nullBits & 8) != 0) {\n            varPos2 = offset + 102 + buf.getIntLE(offset + 98);\n            obj.referralSource = HostAddress.deserialize(buf, varPos2);\n         }\n\n         return obj;\n      }\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static Connect deserialize(@Nonnull ByteBuf buf, int offset) {\n      Connect obj = new Connect();\n      byte nullBits = buf.getByte(offset);\n      obj.protocolHash = PacketIO.readFixedAsciiString(buf, offset + 1, 64);\n      obj.clientType = ClientType.fromValue(buf.getByte(offset + 65));\n      obj.uuid = PacketIO.readUUID(buf, offset + 66);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 102 + buf.getIntLE(offset + 82);\n         int languageLen = VarInt.peek(buf, varPos0);\n         if (languageLen < 0) {\n            throw ProtocolException.negativeLength(\"Language\", languageLen);\n         }\n\n         if (languageLen > 128) {\n            throw ProtocolException.stringTooLong(\"Language\", languageLen, 128);\n         }\n\n         obj.language = PacketIO.readVarString(buf, varPos0, PacketIO.ASCII);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 102 + buf.getIntLE(offset + 86);\n         int identityTokenLen = VarInt.peek(buf, varPos1);\n         if (identityTokenLen < 0) {\n            throw ProtocolException.negativeLength(\"IdentityToken\", identityTokenLen);\n         }\n\n         if (identityTokenLen > 8192) {\n            throw ProtocolException.stringTooLong(\"IdentityToken\", identityTokenLen, 8192);\n         }\n\n         obj.identityToken = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      int varPos2 = offset + 102 + buf.getIntLE(offset + 90);\n      int usernameLen = VarInt.peek(buf, varPos2);\n      if (usernameLen < 0) {\n         throw ProtocolException.negativeLength(\"Username\", usernameLen);\n      } else if (usernameLen > 16) {\n         throw ProtocolException.stringTooLong(\"Username\", usernameLen, 16);\n      } else {\n         obj.username = PacketIO.readVarString(buf, varPos2, PacketIO.ASCII);\n         if ((nullBits & 4) != 0) {\n            varPos2 = offset + 102 + buf.getIntLE(offset + 94);\n            usernameLen = VarInt.peek(buf, varPos2);\n            if (usernameLen < 0) {\n               throw ProtocolException.negativeLength(\"ReferralData\", usernameLen);\n            }\n\n            if (usernameLen > 4096) {\n               throw ProtocolException.arrayTooLong(\"ReferralData\", usernameLen, 4096);\n            }\n\n            int varIntLen = VarInt.length(buf, varPos2);\n            if ((long)(varPos2 + varIntLen) + (long)usernameLen * 1L > (long)buf.readableBytes()) {\n               throw ProtocolException.bufferTooSmall(\"ReferralData\", varPos2 + varIntLen + usernameLen * 1, buf.readableBytes());\n            }\n\n            obj.referralData = new byte[usernameLen];\n\n            for (int i = 0; i < usernameLen; i++) {\n               obj.referralData[i] = buf.getByte(varPos2 + varIntLen + i * 1);\n            }\n         }\n\n         if ((nullBits & 8) != 0) {\n            varPos2 = offset + 102 + buf.getIntLE(offset + 98);\n            obj.referralSource = HostAddress.deserialize(buf, varPos2);\n         }\n\n         return obj;\n      }\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 102;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 82);\n         int pos0 = offset + 102 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 86);\n         int pos1 = offset + 102 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      int fieldOffset2 = buf.getIntLE(offset + 90);\n      int pos2 = offset + 102 + fieldOffset2;\n      int sl = VarInt.peek(buf, pos2);\n      pos2 += VarInt.length(buf, pos2) + sl;\n      if (pos2 - offset > maxEnd) {\n         maxEnd = pos2 - offset;\n      }\n\n      if ((nullBits & 4) != 0) {\n         fieldOffset2 = buf.getIntLE(offset + 94);\n         pos2 = offset + 102 + fieldOffset2;\n         sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl * 1;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         fieldOffset2 = buf.getIntLE(offset + 98);\n         pos2 = offset + 102 + fieldOffset2;\n         pos2 += HostAddress.computeBytesConsumed(buf, pos2);\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 102) {\n         return ValidationResult.error(\"Buffer too small: expected at least 102 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int languageOffset = buffer.getIntLE(offset + 82);\n            if (languageOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Language\");\n            }\n\n            int pos = offset + 102 + languageOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Language\");\n            }\n\n            int languageLen = VarInt.peek(buffer, pos);\n            if (languageLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Language\");\n            }\n\n            if (languageLen > 128) {\n               return ValidationResult.error(\"Language exceeds max length 128\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += languageLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Language\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int identityTokenOffset = buffer.getIntLE(offset + 86);\n            if (identityTokenOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for IdentityToken\");\n            }\n\n            int posx = offset + 102 + identityTokenOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for IdentityToken\");\n            }\n\n            int identityTokenLen = VarInt.peek(buffer, posx);\n            if (identityTokenLen < 0) {\n               return ValidationResult.error(\"Invalid string length for IdentityToken\");\n            }\n\n            if (identityTokenLen > 8192) {\n               return ValidationResult.error(\"IdentityToken exceeds max length 8192\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += identityTokenLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading IdentityToken\");\n            }\n         }\n\n         int usernameOffset = buffer.getIntLE(offset + 90);\n         if (usernameOffset < 0) {\n            return ValidationResult.error(\"Invalid offset for Username\");\n         } else {\n            int posxx = offset + 102 + usernameOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Username\");\n            } else {\n               int usernameLen = VarInt.peek(buffer, posxx);\n               if (usernameLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for Username\");\n               } else if (usernameLen > 16) {\n                  return ValidationResult.error(\"Username exceeds max length 16\");\n               } else {\n                  posxx += VarInt.length(buffer, posxx);\n                  posxx += usernameLen;\n                  if (posxx > buffer.writerIndex()) {\n                     return ValidationResult.error(\"Buffer overflow reading Username\");\n                  } else {\n                     if ((nullBits & 4) != 0) {\n                        usernameOffset = buffer.getIntLE(offset + 94);\n                        if (usernameOffset < 0) {\n                           return ValidationResult.error(\"Invalid offset for ReferralData\");\n                        }\n\n                        posxx = offset + 102 + usernameOffset;\n                        if (posxx >= buffer.writerIndex()) {\n                           return ValidationResult.error(\"Offset out of bounds for ReferralData\");\n                        }\n\n                        usernameLen = VarInt.peek(buffer, posxx);\n                        if (usernameLen < 0) {\n                           return ValidationResult.error(\"Invalid array count for ReferralData\");\n                        }\n\n                        if (usernameLen > 4096) {\n                           return ValidationResult.error(\"ReferralData exceeds max length 4096\");\n                        }\n\n                        posxx += VarInt.length(buffer, posxx);\n                        posxx += usernameLen * 1;\n                        if (posxx > buffer.writerIndex()) {\n                           return ValidationResult.error(\"Buffer overflow reading ReferralData\");\n                        }\n                     }\n\n                     if ((nullBits & 8) != 0) {\n                        usernameOffset = buffer.getIntLE(offset + 98);\n                        if (usernameOffset < 0) {\n                           return ValidationResult.error(\"Invalid offset for ReferralSource\");\n                        }\n\n                        posxx = offset + 102 + usernameOffset;\n                        if (posxx >= buffer.writerIndex()) {\n                           return ValidationResult.error(\"Offset out of bounds for ReferralSource\");\n                        }\n\n                        ValidationResult referralSourceResult = HostAddress.validateStructure(buffer, posxx);\n                        if (!referralSourceResult.isValid()) {\n                           return ValidationResult.error(\"Invalid ReferralSource: \" + referralSourceResult.error());\n                        }\n\n                        posxx += HostAddress.computeBytesConsumed(buffer, posxx);\n                     }\n\n                     return ValidationResult.OK;\n                  }\n               }\n            }\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, PacketIO.readFixedAsciiString, ClientType.fromValue, PacketIO.readUUID, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, HostAddress.deserialize\n// Types referenced: ClientType, HostAddress\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "Disconnect",
        "packetId": 1,
        "package": "com.hypixel.hytale.protocol.packets.connection",
        "fields": [
          {
            "name": "reason",
            "type": "String",
            "nullable": true
          },
          {
            "name": "type",
            "type": "DisconnectType",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: Disconnect\n// Package: com.hypixel.hytale.protocol.packets.connection\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 1;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 16384007;\n\n// === FIELDS ===\n@Nullable String reason;\n@Nonnull DisconnectType type;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static Disconnect deserialize(@Nonnull ByteBuf buf, int offset) {\n      Disconnect obj = new Disconnect();\n      byte nullBits = buf.getByte(offset);\n      obj.type = DisconnectType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int reasonLen = VarInt.peek(buf, pos);\n         if (reasonLen < 0) {\n            throw ProtocolException.negativeLength(\"Reason\", reasonLen);\n         }\n\n         if (reasonLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Reason\", reasonLen, 4096000);\n         }\n\n         int reasonVarLen = VarInt.length(buf, pos);\n         obj.reason = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += reasonVarLen + reasonLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int reasonLen = VarInt.peek(buffer, pos);\n            if (reasonLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Reason\");\n            }\n\n            if (reasonLen > 4096000) {\n               return ValidationResult.error(\"Reason exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += reasonLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Reason\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, DisconnectType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n// Types referenced: DisconnectType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "Ping",
        "packetId": 2,
        "package": "com.hypixel.hytale.protocol.packets.connection",
        "fields": [
          {
            "name": "id",
            "type": "int",
            "nullable": false
          },
          {
            "name": "time",
            "type": "InstantData",
            "nullable": true
          },
          {
            "name": "lastPingValueRaw",
            "type": "int",
            "nullable": false
          },
          {
            "name": "lastPingValueDirect",
            "type": "int",
            "nullable": false
          },
          {
            "name": "lastPingValueTick",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: Ping\n// Package: com.hypixel.hytale.protocol.packets.connection\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 2;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 29;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 29;\npublic static final int MAX_SIZE = 29;\n\n// === FIELDS ===\n@Nonnull int id;\n@Nullable InstantData time;\n@Nonnull int lastPingValueRaw;\n@Nonnull int lastPingValueDirect;\n@Nonnull int lastPingValueTick;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static Ping deserialize(@Nonnull ByteBuf buf, int offset) {\n      Ping obj = new Ping();\n      byte nullBits = buf.getByte(offset);\n      obj.id = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.time = InstantData.deserialize(buf, offset + 5);\n      }\n\n      obj.lastPingValueRaw = buf.getIntLE(offset + 17);\n      obj.lastPingValueDirect = buf.getIntLE(offset + 21);\n      obj.lastPingValueTick = buf.getIntLE(offset + 25);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static Ping deserialize(@Nonnull ByteBuf buf, int offset) {\n      Ping obj = new Ping();\n      byte nullBits = buf.getByte(offset);\n      obj.id = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.time = InstantData.deserialize(buf, offset + 5);\n      }\n\n      obj.lastPingValueRaw = buf.getIntLE(offset + 17);\n      obj.lastPingValueDirect = buf.getIntLE(offset + 21);\n      obj.lastPingValueTick = buf.getIntLE(offset + 25);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 29;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 29 ? ValidationResult.error(\"Buffer too small: expected at least 29 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, InstantData.deserialize\n// Types referenced: InstantData\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "Pong",
        "packetId": 3,
        "package": "com.hypixel.hytale.protocol.packets.connection",
        "fields": [
          {
            "name": "id",
            "type": "int",
            "nullable": false
          },
          {
            "name": "time",
            "type": "InstantData",
            "nullable": true
          },
          {
            "name": "type",
            "type": "PongType",
            "nullable": false
          },
          {
            "name": "packetQueueSize",
            "type": "short",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: Pong\n// Package: com.hypixel.hytale.protocol.packets.connection\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 3;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 20;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 20;\npublic static final int MAX_SIZE = 20;\n\n// === FIELDS ===\n@Nonnull int id;\n@Nullable InstantData time;\n@Nonnull PongType type;\n@Nonnull short packetQueueSize;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static Pong deserialize(@Nonnull ByteBuf buf, int offset) {\n      Pong obj = new Pong();\n      byte nullBits = buf.getByte(offset);\n      obj.id = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.time = InstantData.deserialize(buf, offset + 5);\n      }\n\n      obj.type = PongType.fromValue(buf.getByte(offset + 17));\n      obj.packetQueueSize = buf.getShortLE(offset + 18);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static Pong deserialize(@Nonnull ByteBuf buf, int offset) {\n      Pong obj = new Pong();\n      byte nullBits = buf.getByte(offset);\n      obj.id = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         obj.time = InstantData.deserialize(buf, offset + 5);\n      }\n\n      obj.type = PongType.fromValue(buf.getByte(offset + 17));\n      obj.packetQueueSize = buf.getShortLE(offset + 18);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 20;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 20 ? ValidationResult.error(\"Buffer too small: expected at least 20 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, InstantData.deserialize, PongType.fromValue, buf.getShortLE\n// Types referenced: InstantData, PongType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "assets": [
      {
        "name": "UpdateBlockTypes",
        "packetId": 40,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "blockTypes",
            "type": "Map<Integer, BlockType>",
            "nullable": true
          },
          {
            "name": "updateBlockTextures",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "updateModelTextures",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "updateModels",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "updateMapGeometry",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateBlockTypes\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 40;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 10;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 10;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, BlockType> blockTypes;\n@Nonnull boolean updateBlockTextures;\n@Nonnull boolean updateModelTextures;\n@Nonnull boolean updateModels;\n@Nonnull boolean updateMapGeometry;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateBlockTypes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockTypes obj = new UpdateBlockTypes();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      obj.updateBlockTextures = buf.getByte(offset + 6) != 0;\n      obj.updateModelTextures = buf.getByte(offset + 7) != 0;\n      obj.updateModels = buf.getByte(offset + 8) != 0;\n      obj.updateMapGeometry = buf.getByte(offset + 9) != 0;\n      int pos = offset + 10;\n      if ((nullBits & 1) != 0) {\n         int blockTypesCount = VarInt.peek(buf, pos);\n         if (blockTypesCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockTypes\", blockTypesCount);\n         }\n\n         if (blockTypesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockTypes\", blockTypesCount, 4096000);\n         }\n\n         pos += VarInt.size(blockTypesCount);\n         obj.blockTypes = new HashMap<>(blockTypesCount);\n\n         for (int i = 0; i < blockTypesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            BlockType val = BlockType.deserialize(buf, pos);\n            pos += BlockType.computeBytesConsumed(buf, pos);\n            if (obj.blockTypes.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockTypes\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateBlockTypes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockTypes obj = new UpdateBlockTypes();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      obj.updateBlockTextures = buf.getByte(offset + 6) != 0;\n      obj.updateModelTextures = buf.getByte(offset + 7) != 0;\n      obj.updateModels = buf.getByte(offset + 8) != 0;\n      obj.updateMapGeometry = buf.getByte(offset + 9) != 0;\n      int pos = offset + 10;\n      if ((nullBits & 1) != 0) {\n         int blockTypesCount = VarInt.peek(buf, pos);\n         if (blockTypesCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockTypes\", blockTypesCount);\n         }\n\n         if (blockTypesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockTypes\", blockTypesCount, 4096000);\n         }\n\n         pos += VarInt.size(blockTypesCount);\n         obj.blockTypes = new HashMap<>(blockTypesCount);\n\n         for (int i = 0; i < blockTypesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            BlockType val = BlockType.deserialize(buf, pos);\n            pos += BlockType.computeBytesConsumed(buf, pos);\n            if (obj.blockTypes.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockTypes\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 10;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += BlockType.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 10) {\n         return ValidationResult.error(\"Buffer too small: expected at least 10 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 10;\n         if ((nullBits & 1) != 0) {\n            int blockTypesCount = VarInt.peek(buffer, pos);\n            if (blockTypesCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for BlockTypes\");\n            }\n\n            if (blockTypesCount > 4096000) {\n               return ValidationResult.error(\"BlockTypes exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < blockTypesCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += BlockType.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, BlockType.deserialize, BlockType.computeBytesConsumed, obj.blockTypes.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, BlockType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateBlockHitboxes",
        "packetId": 41,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "blockBaseHitboxes",
            "type": "Map<Integer, Hitbox[]>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateBlockHitboxes\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 41;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, Hitbox[]> blockBaseHitboxes;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateBlockHitboxes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockHitboxes obj = new UpdateBlockHitboxes();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int blockBaseHitboxesCount = VarInt.peek(buf, pos);\n         if (blockBaseHitboxesCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockBaseHitboxes\", blockBaseHitboxesCount);\n         }\n\n         if (blockBaseHitboxesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockBaseHitboxes\", blockBaseHitboxesCount, 4096000);\n         }\n\n         pos += VarInt.size(blockBaseHitboxesCount);\n         obj.blockBaseHitboxes = new HashMap<>(blockBaseHitboxesCount);\n\n         for (int i = 0; i < blockBaseHitboxesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            int valLen = VarInt.peek(buf, pos);\n            if (valLen < 0) {\n               throw ProtocolException.negativeLength(\"val\", valLen);\n            }\n\n            if (valLen > 64) {\n               throw ProtocolException.arrayTooLong(\"val\", valLen, 64);\n            }\n\n            int valVarLen = VarInt.length(buf, pos);\n            if ((long)(pos + valVarLen) + (long)valLen * 24L > (long)buf.readableBytes()) {\n               throw ProtocolException.bufferTooSmall(\"val\", pos + valVarLen + valLen * 24, buf.readableBytes());\n            }\n\n            pos += valVarLen;\n            Hitbox[] val = new Hitbox[valLen];\n\n            for (int valIdx = 0; valIdx < valLen; valIdx++) {\n               val[valIdx] = Hitbox.deserialize(buf, pos);\n               pos += Hitbox.computeBytesConsumed(buf, pos);\n            }\n\n            if (obj.blockBaseHitboxes.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockBaseHitboxes\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateBlockHitboxes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockHitboxes obj = new UpdateBlockHitboxes();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int blockBaseHitboxesCount = VarInt.peek(buf, pos);\n         if (blockBaseHitboxesCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockBaseHitboxes\", blockBaseHitboxesCount);\n         }\n\n         if (blockBaseHitboxesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockBaseHitboxes\", blockBaseHitboxesCount, 4096000);\n         }\n\n         pos += VarInt.size(blockBaseHitboxesCount);\n         obj.blockBaseHitboxes = new HashMap<>(blockBaseHitboxesCount);\n\n         for (int i = 0; i < blockBaseHitboxesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            int valLen = VarInt.peek(buf, pos);\n            if (valLen < 0) {\n               throw ProtocolException.negativeLength(\"val\", valLen);\n            }\n\n            if (valLen > 64) {\n               throw ProtocolException.arrayTooLong(\"val\", valLen, 64);\n            }\n\n            int valVarLen = VarInt.length(buf, pos);\n            if ((long)(pos + valVarLen) + (long)valLen * 24L > (long)buf.readableBytes()) {\n               throw ProtocolException.bufferTooSmall(\"val\", pos + valVarLen + valLen * 24, buf.readableBytes());\n            }\n\n            pos += valVarLen;\n            Hitbox[] val = new Hitbox[valLen];\n\n            for (int valIdx = 0; valIdx < valLen; valIdx++) {\n               val[valIdx] = Hitbox.deserialize(buf, pos);\n               pos += Hitbox.computeBytesConsumed(buf, pos);\n            }\n\n            if (obj.blockBaseHitboxes.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockBaseHitboxes\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            int al = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos);\n\n            for (int j = 0; j < al; j++) {\n               pos += Hitbox.computeBytesConsumed(buf, pos);\n            }\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int blockBaseHitboxesCount = VarInt.peek(buffer, pos);\n            if (blockBaseHitboxesCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for BlockBaseHitboxes\");\n            }\n\n            if (blockBaseHitboxesCount > 4096000) {\n               return ValidationResult.error(\"BlockBaseHitboxes exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < blockBaseHitboxesCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               int valueArrCount = VarInt.peek(buffer, pos);\n               if (valueArrCount < 0) {\n                  return ValidationResult.error(\"Invalid array count for value\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n\n               for (int valueArrIdx = 0; valueArrIdx < valueArrCount; valueArrIdx++) {\n                  pos += 24;\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, Hitbox.deserialize, Hitbox.computeBytesConsumed, obj.blockBaseHitboxes.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, Hitbox\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateBlockSoundSets",
        "packetId": 42,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "blockSoundSets",
            "type": "Map<Integer, BlockSoundSet>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateBlockSoundSets\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 42;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, BlockSoundSet> blockSoundSets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateBlockSoundSets deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockSoundSets obj = new UpdateBlockSoundSets();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int blockSoundSetsCount = VarInt.peek(buf, pos);\n         if (blockSoundSetsCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockSoundSets\", blockSoundSetsCount);\n         }\n\n         if (blockSoundSetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockSoundSets\", blockSoundSetsCount, 4096000);\n         }\n\n         pos += VarInt.size(blockSoundSetsCount);\n         obj.blockSoundSets = new HashMap<>(blockSoundSetsCount);\n\n         for (int i = 0; i < blockSoundSetsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            BlockSoundSet val = BlockSoundSet.deserialize(buf, pos);\n            pos += BlockSoundSet.computeBytesConsumed(buf, pos);\n            if (obj.blockSoundSets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockSoundSets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateBlockSoundSets deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockSoundSets obj = new UpdateBlockSoundSets();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int blockSoundSetsCount = VarInt.peek(buf, pos);\n         if (blockSoundSetsCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockSoundSets\", blockSoundSetsCount);\n         }\n\n         if (blockSoundSetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockSoundSets\", blockSoundSetsCount, 4096000);\n         }\n\n         pos += VarInt.size(blockSoundSetsCount);\n         obj.blockSoundSets = new HashMap<>(blockSoundSetsCount);\n\n         for (int i = 0; i < blockSoundSetsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            BlockSoundSet val = BlockSoundSet.deserialize(buf, pos);\n            pos += BlockSoundSet.computeBytesConsumed(buf, pos);\n            if (obj.blockSoundSets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockSoundSets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += BlockSoundSet.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int blockSoundSetsCount = VarInt.peek(buffer, pos);\n            if (blockSoundSetsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for BlockSoundSets\");\n            }\n\n            if (blockSoundSetsCount > 4096000) {\n               return ValidationResult.error(\"BlockSoundSets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < blockSoundSetsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += BlockSoundSet.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, BlockSoundSet.deserialize, BlockSoundSet.computeBytesConsumed, obj.blockSoundSets.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, BlockSoundSet\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateItemSoundSets",
        "packetId": 43,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "itemSoundSets",
            "type": "Map<Integer, ItemSoundSet>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateItemSoundSets\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 43;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, ItemSoundSet> itemSoundSets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateItemSoundSets deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItemSoundSets obj = new UpdateItemSoundSets();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int itemSoundSetsCount = VarInt.peek(buf, pos);\n         if (itemSoundSetsCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemSoundSets\", itemSoundSetsCount);\n         }\n\n         if (itemSoundSetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ItemSoundSets\", itemSoundSetsCount, 4096000);\n         }\n\n         pos += VarInt.size(itemSoundSetsCount);\n         obj.itemSoundSets = new HashMap<>(itemSoundSetsCount);\n\n         for (int i = 0; i < itemSoundSetsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            ItemSoundSet val = ItemSoundSet.deserialize(buf, pos);\n            pos += ItemSoundSet.computeBytesConsumed(buf, pos);\n            if (obj.itemSoundSets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"itemSoundSets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateItemSoundSets deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItemSoundSets obj = new UpdateItemSoundSets();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int itemSoundSetsCount = VarInt.peek(buf, pos);\n         if (itemSoundSetsCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemSoundSets\", itemSoundSetsCount);\n         }\n\n         if (itemSoundSetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ItemSoundSets\", itemSoundSetsCount, 4096000);\n         }\n\n         pos += VarInt.size(itemSoundSetsCount);\n         obj.itemSoundSets = new HashMap<>(itemSoundSetsCount);\n\n         for (int i = 0; i < itemSoundSetsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            ItemSoundSet val = ItemSoundSet.deserialize(buf, pos);\n            pos += ItemSoundSet.computeBytesConsumed(buf, pos);\n            if (obj.itemSoundSets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"itemSoundSets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += ItemSoundSet.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int itemSoundSetsCount = VarInt.peek(buffer, pos);\n            if (itemSoundSetsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for ItemSoundSets\");\n            }\n\n            if (itemSoundSetsCount > 4096000) {\n               return ValidationResult.error(\"ItemSoundSets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < itemSoundSetsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ItemSoundSet.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ItemSoundSet.deserialize, ItemSoundSet.computeBytesConsumed, obj.itemSoundSets.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, ItemSoundSet\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateBlockParticleSets",
        "packetId": 44,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "blockParticleSets",
            "type": "Map<String, BlockParticleSet>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateBlockParticleSets\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 44;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, BlockParticleSet> blockParticleSets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateBlockParticleSets deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockParticleSets obj = new UpdateBlockParticleSets();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int blockParticleSetsCount = VarInt.peek(buf, pos);\n         if (blockParticleSetsCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockParticleSets\", blockParticleSetsCount);\n         }\n\n         if (blockParticleSetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockParticleSets\", blockParticleSetsCount, 4096000);\n         }\n\n         pos += VarInt.size(blockParticleSetsCount);\n         obj.blockParticleSets = new HashMap<>(blockParticleSetsCount);\n\n         for (int i = 0; i < blockParticleSetsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            BlockParticleSet val = BlockParticleSet.deserialize(buf, pos);\n            pos += BlockParticleSet.computeBytesConsumed(buf, pos);\n            if (obj.blockParticleSets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockParticleSets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateBlockParticleSets deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockParticleSets obj = new UpdateBlockParticleSets();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int blockParticleSetsCount = VarInt.peek(buf, pos);\n         if (blockParticleSetsCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockParticleSets\", blockParticleSetsCount);\n         }\n\n         if (blockParticleSetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockParticleSets\", blockParticleSetsCount, 4096000);\n         }\n\n         pos += VarInt.size(blockParticleSetsCount);\n         obj.blockParticleSets = new HashMap<>(blockParticleSetsCount);\n\n         for (int i = 0; i < blockParticleSetsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            BlockParticleSet val = BlockParticleSet.deserialize(buf, pos);\n            pos += BlockParticleSet.computeBytesConsumed(buf, pos);\n            if (obj.blockParticleSets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockParticleSets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            pos += BlockParticleSet.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int blockParticleSetsCount = VarInt.peek(buffer, pos);\n            if (blockParticleSetsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for BlockParticleSets\");\n            }\n\n            if (blockParticleSetsCount > 4096000) {\n               return ValidationResult.error(\"BlockParticleSets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < blockParticleSetsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += BlockParticleSet.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, BlockParticleSet.deserialize, BlockParticleSet.computeBytesConsumed, obj.blockParticleSets.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, BlockParticleSet\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateBlockBreakingDecals",
        "packetId": 45,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "blockBreakingDecals",
            "type": "Map<String, BlockBreakingDecal>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateBlockBreakingDecals\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 45;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, BlockBreakingDecal> blockBreakingDecals;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateBlockBreakingDecals deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockBreakingDecals obj = new UpdateBlockBreakingDecals();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int blockBreakingDecalsCount = VarInt.peek(buf, pos);\n         if (blockBreakingDecalsCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockBreakingDecals\", blockBreakingDecalsCount);\n         }\n\n         if (blockBreakingDecalsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockBreakingDecals\", blockBreakingDecalsCount, 4096000);\n         }\n\n         pos += VarInt.size(blockBreakingDecalsCount);\n         obj.blockBreakingDecals = new HashMap<>(blockBreakingDecalsCount);\n\n         for (int i = 0; i < blockBreakingDecalsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            BlockBreakingDecal val = BlockBreakingDecal.deserialize(buf, pos);\n            pos += BlockBreakingDecal.computeBytesConsumed(buf, pos);\n            if (obj.blockBreakingDecals.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockBreakingDecals\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateBlockBreakingDecals deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockBreakingDecals obj = new UpdateBlockBreakingDecals();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int blockBreakingDecalsCount = VarInt.peek(buf, pos);\n         if (blockBreakingDecalsCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockBreakingDecals\", blockBreakingDecalsCount);\n         }\n\n         if (blockBreakingDecalsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockBreakingDecals\", blockBreakingDecalsCount, 4096000);\n         }\n\n         pos += VarInt.size(blockBreakingDecalsCount);\n         obj.blockBreakingDecals = new HashMap<>(blockBreakingDecalsCount);\n\n         for (int i = 0; i < blockBreakingDecalsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            BlockBreakingDecal val = BlockBreakingDecal.deserialize(buf, pos);\n            pos += BlockBreakingDecal.computeBytesConsumed(buf, pos);\n            if (obj.blockBreakingDecals.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockBreakingDecals\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            pos += BlockBreakingDecal.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int blockBreakingDecalsCount = VarInt.peek(buffer, pos);\n            if (blockBreakingDecalsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for BlockBreakingDecals\");\n            }\n\n            if (blockBreakingDecalsCount > 4096000) {\n               return ValidationResult.error(\"BlockBreakingDecals exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < blockBreakingDecalsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += BlockBreakingDecal.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, BlockBreakingDecal.deserialize, BlockBreakingDecal.computeBytesConsumed, obj.blockBreakingDecals.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, BlockBreakingDecal\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateBlockSets",
        "packetId": 46,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "blockSets",
            "type": "Map<String, BlockSet>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateBlockSets\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 46;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, BlockSet> blockSets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateBlockSets deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockSets obj = new UpdateBlockSets();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int blockSetsCount = VarInt.peek(buf, pos);\n         if (blockSetsCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockSets\", blockSetsCount);\n         }\n\n         if (blockSetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockSets\", blockSetsCount, 4096000);\n         }\n\n         pos += VarInt.size(blockSetsCount);\n         obj.blockSets = new HashMap<>(blockSetsCount);\n\n         for (int i = 0; i < blockSetsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            BlockSet val = BlockSet.deserialize(buf, pos);\n            pos += BlockSet.computeBytesConsumed(buf, pos);\n            if (obj.blockSets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockSets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateBlockSets deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockSets obj = new UpdateBlockSets();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int blockSetsCount = VarInt.peek(buf, pos);\n         if (blockSetsCount < 0) {\n            throw ProtocolException.negativeLength(\"BlockSets\", blockSetsCount);\n         }\n\n         if (blockSetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BlockSets\", blockSetsCount, 4096000);\n         }\n\n         pos += VarInt.size(blockSetsCount);\n         obj.blockSets = new HashMap<>(blockSetsCount);\n\n         for (int i = 0; i < blockSetsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            BlockSet val = BlockSet.deserialize(buf, pos);\n            pos += BlockSet.computeBytesConsumed(buf, pos);\n            if (obj.blockSets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"blockSets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            pos += BlockSet.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int blockSetsCount = VarInt.peek(buffer, pos);\n            if (blockSetsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for BlockSets\");\n            }\n\n            if (blockSetsCount > 4096000) {\n               return ValidationResult.error(\"BlockSets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < blockSetsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += BlockSet.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, BlockSet.deserialize, BlockSet.computeBytesConsumed, obj.blockSets.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, BlockSet\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateWeathers",
        "packetId": 47,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "weathers",
            "type": "Map<Integer, Weather>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateWeathers\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 47;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, Weather> weathers;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateWeathers deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateWeathers obj = new UpdateWeathers();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int weathersCount = VarInt.peek(buf, pos);\n         if (weathersCount < 0) {\n            throw ProtocolException.negativeLength(\"Weathers\", weathersCount);\n         }\n\n         if (weathersCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Weathers\", weathersCount, 4096000);\n         }\n\n         pos += VarInt.size(weathersCount);\n         obj.weathers = new HashMap<>(weathersCount);\n\n         for (int i = 0; i < weathersCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            Weather val = Weather.deserialize(buf, pos);\n            pos += Weather.computeBytesConsumed(buf, pos);\n            if (obj.weathers.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"weathers\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateWeathers deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateWeathers obj = new UpdateWeathers();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int weathersCount = VarInt.peek(buf, pos);\n         if (weathersCount < 0) {\n            throw ProtocolException.negativeLength(\"Weathers\", weathersCount);\n         }\n\n         if (weathersCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Weathers\", weathersCount, 4096000);\n         }\n\n         pos += VarInt.size(weathersCount);\n         obj.weathers = new HashMap<>(weathersCount);\n\n         for (int i = 0; i < weathersCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            Weather val = Weather.deserialize(buf, pos);\n            pos += Weather.computeBytesConsumed(buf, pos);\n            if (obj.weathers.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"weathers\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += Weather.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int weathersCount = VarInt.peek(buffer, pos);\n            if (weathersCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Weathers\");\n            }\n\n            if (weathersCount > 4096000) {\n               return ValidationResult.error(\"Weathers exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < weathersCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += Weather.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, Weather.deserialize, Weather.computeBytesConsumed, obj.weathers.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, Weather\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateTrails",
        "packetId": 48,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "trails",
            "type": "Map<String, Trail>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateTrails\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 48;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, Trail> trails;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateTrails deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateTrails obj = new UpdateTrails();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int trailsCount = VarInt.peek(buf, pos);\n         if (trailsCount < 0) {\n            throw ProtocolException.negativeLength(\"Trails\", trailsCount);\n         }\n\n         if (trailsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Trails\", trailsCount, 4096000);\n         }\n\n         pos += VarInt.size(trailsCount);\n         obj.trails = new HashMap<>(trailsCount);\n\n         for (int i = 0; i < trailsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            Trail val = Trail.deserialize(buf, pos);\n            pos += Trail.computeBytesConsumed(buf, pos);\n            if (obj.trails.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"trails\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateTrails deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateTrails obj = new UpdateTrails();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int trailsCount = VarInt.peek(buf, pos);\n         if (trailsCount < 0) {\n            throw ProtocolException.negativeLength(\"Trails\", trailsCount);\n         }\n\n         if (trailsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Trails\", trailsCount, 4096000);\n         }\n\n         pos += VarInt.size(trailsCount);\n         obj.trails = new HashMap<>(trailsCount);\n\n         for (int i = 0; i < trailsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            Trail val = Trail.deserialize(buf, pos);\n            pos += Trail.computeBytesConsumed(buf, pos);\n            if (obj.trails.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"trails\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            pos += Trail.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int trailsCount = VarInt.peek(buffer, pos);\n            if (trailsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Trails\");\n            }\n\n            if (trailsCount > 4096000) {\n               return ValidationResult.error(\"Trails exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < trailsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += Trail.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, Trail.deserialize, Trail.computeBytesConsumed, obj.trails.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, Trail\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateParticleSystems",
        "packetId": 49,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "particleSystems",
            "type": "Map<String, ParticleSystem>",
            "nullable": true
          },
          {
            "name": "removedParticleSystems",
            "type": "String[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateParticleSystems\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 49;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 10;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, ParticleSystem> particleSystems;\n@Nullable String[] removedParticleSystems;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateParticleSystems deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateParticleSystems obj = new UpdateParticleSystems();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 10 + buf.getIntLE(offset + 2);\n         int particleSystemsCount = VarInt.peek(buf, varPos0);\n         if (particleSystemsCount < 0) {\n            throw ProtocolException.negativeLength(\"ParticleSystems\", particleSystemsCount);\n         }\n\n         if (particleSystemsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ParticleSystems\", particleSystemsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         obj.particleSystems = new HashMap<>(particleSystemsCount);\n         int dictPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < particleSystemsCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            ParticleSystem val = ParticleSystem.deserialize(buf, dictPos);\n            dictPos += ParticleSystem.computeBytesConsumed(buf, dictPos);\n            if (obj.particleSystems.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"particleSystems\", key);\n            }\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 10 + buf.getIntLE(offset + 6);\n         int removedParticleSystemsCount = VarInt.peek(buf, varPos1);\n         if (removedParticleSystemsCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedParticleSystems\", removedParticleSystemsCount);\n         }\n\n         if (removedParticleSystemsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedParticleSystems\", removedParticleSystemsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)removedParticleSystemsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedParticleSystems\", varPos1 + varIntLen + removedParticleSystemsCount * 1, buf.readableBytes());\n         }\n\n         obj.removedParticleSystems = new String[removedParticleSystemsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < removedParticleSystemsCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedParticleSystems[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedParticleSystems[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedParticleSystems[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateParticleSystems deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateParticleSystems obj = new UpdateParticleSystems();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 10 + buf.getIntLE(offset + 2);\n         int particleSystemsCount = VarInt.peek(buf, varPos0);\n         if (particleSystemsCount < 0) {\n            throw ProtocolException.negativeLength(\"ParticleSystems\", particleSystemsCount);\n         }\n\n         if (particleSystemsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ParticleSystems\", particleSystemsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         obj.particleSystems = new HashMap<>(particleSystemsCount);\n         int dictPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < particleSystemsCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            ParticleSystem val = ParticleSystem.deserialize(buf, dictPos);\n            dictPos += ParticleSystem.computeBytesConsumed(buf, dictPos);\n            if (obj.particleSystems.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"particleSystems\", key);\n            }\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 10 + buf.getIntLE(offset + 6);\n         int removedParticleSystemsCount = VarInt.peek(buf, varPos1);\n         if (removedParticleSystemsCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedParticleSystems\", removedParticleSystemsCount);\n         }\n\n         if (removedParticleSystemsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedParticleSystems\", removedParticleSystemsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)removedParticleSystemsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedParticleSystems\", varPos1 + varIntLen + removedParticleSystemsCount * 1, buf.readableBytes());\n         }\n\n         obj.removedParticleSystems = new String[removedParticleSystemsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < removedParticleSystemsCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedParticleSystems[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedParticleSystems[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedParticleSystems[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 10;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 2);\n         int pos0 = offset + 10 + fieldOffset0;\n         int dictLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos0);\n            pos0 += VarInt.length(buf, pos0) + sl;\n            pos0 += ParticleSystem.computeBytesConsumed(buf, pos0);\n         }\n\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 6);\n         int pos1 = offset + 10 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos1);\n            pos1 += VarInt.length(buf, pos1) + sl;\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 10) {\n         return ValidationResult.error(\"Buffer too small: expected at least 10 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int particleSystemsOffset = buffer.getIntLE(offset + 2);\n            if (particleSystemsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ParticleSystems\");\n            }\n\n            int pos = offset + 10 + particleSystemsOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ParticleSystems\");\n            }\n\n            int particleSystemsCount = VarInt.peek(buffer, pos);\n            if (particleSystemsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for ParticleSystems\");\n            }\n\n            if (particleSystemsCount > 4096000) {\n               return ValidationResult.error(\"ParticleSystems exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < particleSystemsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ParticleSystem.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int removedParticleSystemsOffset = buffer.getIntLE(offset + 6);\n            if (removedParticleSystemsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for RemovedParticleSystems\");\n            }\n\n            int posx = offset + 10 + removedParticleSystemsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for RemovedParticleSystems\");\n            }\n\n            int removedParticleSystemsCount = VarInt.peek(buffer, posx);\n            if (removedParticleSystemsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for RemovedParticleSystems\");\n            }\n\n            if (removedParticleSystemsCount > 4096000) {\n               return ValidationResult.error(\"RemovedParticleSystems exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < removedParticleSystemsCount; i++) {\n               int strLen = VarInt.peek(buffer, posx);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in RemovedParticleSystems\");\n               }\n\n               posx += VarInt.length(buffer, posx);\n               posx += strLen;\n               if (posx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in RemovedParticleSystems\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.length, ProtocolException.stringTooLong, PacketIO.readVarString, ParticleSystem.deserialize, ParticleSystem.computeBytesConsumed, obj.particleSystems.put, ProtocolException.duplicateKey, ProtocolException.arrayTooLong, buf.readableBytes, ProtocolException.bufferTooSmall\n// Types referenced: UpdateType, ParticleSystem\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateParticleSpawners",
        "packetId": 50,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "particleSpawners",
            "type": "Map<String, ParticleSpawner>",
            "nullable": true
          },
          {
            "name": "removedParticleSpawners",
            "type": "String[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateParticleSpawners\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 50;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 10;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, ParticleSpawner> particleSpawners;\n@Nullable String[] removedParticleSpawners;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateParticleSpawners deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateParticleSpawners obj = new UpdateParticleSpawners();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 10 + buf.getIntLE(offset + 2);\n         int particleSpawnersCount = VarInt.peek(buf, varPos0);\n         if (particleSpawnersCount < 0) {\n            throw ProtocolException.negativeLength(\"ParticleSpawners\", particleSpawnersCount);\n         }\n\n         if (particleSpawnersCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ParticleSpawners\", particleSpawnersCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         obj.particleSpawners = new HashMap<>(particleSpawnersCount);\n         int dictPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < particleSpawnersCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            ParticleSpawner val = ParticleSpawner.deserialize(buf, dictPos);\n            dictPos += ParticleSpawner.computeBytesConsumed(buf, dictPos);\n            if (obj.particleSpawners.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"particleSpawners\", key);\n            }\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 10 + buf.getIntLE(offset + 6);\n         int removedParticleSpawnersCount = VarInt.peek(buf, varPos1);\n         if (removedParticleSpawnersCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedParticleSpawners\", removedParticleSpawnersCount);\n         }\n\n         if (removedParticleSpawnersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedParticleSpawners\", removedParticleSpawnersCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)removedParticleSpawnersCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedParticleSpawners\", varPos1 + varIntLen + removedParticleSpawnersCount * 1, buf.readableBytes());\n         }\n\n         obj.removedParticleSpawners = new String[removedParticleSpawnersCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < removedParticleSpawnersCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedParticleSpawners[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedParticleSpawners[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedParticleSpawners[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateParticleSpawners deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateParticleSpawners obj = new UpdateParticleSpawners();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 10 + buf.getIntLE(offset + 2);\n         int particleSpawnersCount = VarInt.peek(buf, varPos0);\n         if (particleSpawnersCount < 0) {\n            throw ProtocolException.negativeLength(\"ParticleSpawners\", particleSpawnersCount);\n         }\n\n         if (particleSpawnersCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ParticleSpawners\", particleSpawnersCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         obj.particleSpawners = new HashMap<>(particleSpawnersCount);\n         int dictPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < particleSpawnersCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            ParticleSpawner val = ParticleSpawner.deserialize(buf, dictPos);\n            dictPos += ParticleSpawner.computeBytesConsumed(buf, dictPos);\n            if (obj.particleSpawners.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"particleSpawners\", key);\n            }\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 10 + buf.getIntLE(offset + 6);\n         int removedParticleSpawnersCount = VarInt.peek(buf, varPos1);\n         if (removedParticleSpawnersCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedParticleSpawners\", removedParticleSpawnersCount);\n         }\n\n         if (removedParticleSpawnersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedParticleSpawners\", removedParticleSpawnersCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)removedParticleSpawnersCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedParticleSpawners\", varPos1 + varIntLen + removedParticleSpawnersCount * 1, buf.readableBytes());\n         }\n\n         obj.removedParticleSpawners = new String[removedParticleSpawnersCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < removedParticleSpawnersCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedParticleSpawners[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedParticleSpawners[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedParticleSpawners[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 10;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 2);\n         int pos0 = offset + 10 + fieldOffset0;\n         int dictLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos0);\n            pos0 += VarInt.length(buf, pos0) + sl;\n            pos0 += ParticleSpawner.computeBytesConsumed(buf, pos0);\n         }\n\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 6);\n         int pos1 = offset + 10 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos1);\n            pos1 += VarInt.length(buf, pos1) + sl;\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 10) {\n         return ValidationResult.error(\"Buffer too small: expected at least 10 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int particleSpawnersOffset = buffer.getIntLE(offset + 2);\n            if (particleSpawnersOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ParticleSpawners\");\n            }\n\n            int pos = offset + 10 + particleSpawnersOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ParticleSpawners\");\n            }\n\n            int particleSpawnersCount = VarInt.peek(buffer, pos);\n            if (particleSpawnersCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for ParticleSpawners\");\n            }\n\n            if (particleSpawnersCount > 4096000) {\n               return ValidationResult.error(\"ParticleSpawners exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < particleSpawnersCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ParticleSpawner.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int removedParticleSpawnersOffset = buffer.getIntLE(offset + 6);\n            if (removedParticleSpawnersOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for RemovedParticleSpawners\");\n            }\n\n            int posx = offset + 10 + removedParticleSpawnersOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for RemovedParticleSpawners\");\n            }\n\n            int removedParticleSpawnersCount = VarInt.peek(buffer, posx);\n            if (removedParticleSpawnersCount < 0) {\n               return ValidationResult.error(\"Invalid array count for RemovedParticleSpawners\");\n            }\n\n            if (removedParticleSpawnersCount > 4096000) {\n               return ValidationResult.error(\"RemovedParticleSpawners exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < removedParticleSpawnersCount; i++) {\n               int strLen = VarInt.peek(buffer, posx);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in RemovedParticleSpawners\");\n               }\n\n               posx += VarInt.length(buffer, posx);\n               posx += strLen;\n               if (posx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in RemovedParticleSpawners\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.length, ProtocolException.stringTooLong, PacketIO.readVarString, ParticleSpawner.deserialize, ParticleSpawner.computeBytesConsumed, obj.particleSpawners.put, ProtocolException.duplicateKey, ProtocolException.arrayTooLong, buf.readableBytes, ProtocolException.bufferTooSmall\n// Types referenced: UpdateType, ParticleSpawner\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateEntityEffects",
        "packetId": 51,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "entityEffects",
            "type": "Map<Integer, EntityEffect>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateEntityEffects\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 51;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, EntityEffect> entityEffects;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateEntityEffects deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEntityEffects obj = new UpdateEntityEffects();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int entityEffectsCount = VarInt.peek(buf, pos);\n         if (entityEffectsCount < 0) {\n            throw ProtocolException.negativeLength(\"EntityEffects\", entityEffectsCount);\n         }\n\n         if (entityEffectsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"EntityEffects\", entityEffectsCount, 4096000);\n         }\n\n         pos += VarInt.size(entityEffectsCount);\n         obj.entityEffects = new HashMap<>(entityEffectsCount);\n\n         for (int i = 0; i < entityEffectsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            EntityEffect val = EntityEffect.deserialize(buf, pos);\n            pos += EntityEffect.computeBytesConsumed(buf, pos);\n            if (obj.entityEffects.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"entityEffects\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateEntityEffects deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEntityEffects obj = new UpdateEntityEffects();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int entityEffectsCount = VarInt.peek(buf, pos);\n         if (entityEffectsCount < 0) {\n            throw ProtocolException.negativeLength(\"EntityEffects\", entityEffectsCount);\n         }\n\n         if (entityEffectsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"EntityEffects\", entityEffectsCount, 4096000);\n         }\n\n         pos += VarInt.size(entityEffectsCount);\n         obj.entityEffects = new HashMap<>(entityEffectsCount);\n\n         for (int i = 0; i < entityEffectsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            EntityEffect val = EntityEffect.deserialize(buf, pos);\n            pos += EntityEffect.computeBytesConsumed(buf, pos);\n            if (obj.entityEffects.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"entityEffects\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += EntityEffect.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int entityEffectsCount = VarInt.peek(buffer, pos);\n            if (entityEffectsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for EntityEffects\");\n            }\n\n            if (entityEffectsCount > 4096000) {\n               return ValidationResult.error(\"EntityEffects exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < entityEffectsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += EntityEffect.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, EntityEffect.deserialize, EntityEffect.computeBytesConsumed, obj.entityEffects.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, EntityEffect\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateItemPlayerAnimations",
        "packetId": 52,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "itemPlayerAnimations",
            "type": "Map<String, ItemPlayerAnimations>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateItemPlayerAnimations\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 52;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, ItemPlayerAnimations> itemPlayerAnimations;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateItemPlayerAnimations deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItemPlayerAnimations obj = new UpdateItemPlayerAnimations();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int itemPlayerAnimationsCount = VarInt.peek(buf, pos);\n         if (itemPlayerAnimationsCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemPlayerAnimations\", itemPlayerAnimationsCount);\n         }\n\n         if (itemPlayerAnimationsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ItemPlayerAnimations\", itemPlayerAnimationsCount, 4096000);\n         }\n\n         pos += VarInt.size(itemPlayerAnimationsCount);\n         obj.itemPlayerAnimations = new HashMap<>(itemPlayerAnimationsCount);\n\n         for (int i = 0; i < itemPlayerAnimationsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            ItemPlayerAnimations val = ItemPlayerAnimations.deserialize(buf, pos);\n            pos += ItemPlayerAnimations.computeBytesConsumed(buf, pos);\n            if (obj.itemPlayerAnimations.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"itemPlayerAnimations\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateItemPlayerAnimations deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItemPlayerAnimations obj = new UpdateItemPlayerAnimations();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int itemPlayerAnimationsCount = VarInt.peek(buf, pos);\n         if (itemPlayerAnimationsCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemPlayerAnimations\", itemPlayerAnimationsCount);\n         }\n\n         if (itemPlayerAnimationsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ItemPlayerAnimations\", itemPlayerAnimationsCount, 4096000);\n         }\n\n         pos += VarInt.size(itemPlayerAnimationsCount);\n         obj.itemPlayerAnimations = new HashMap<>(itemPlayerAnimationsCount);\n\n         for (int i = 0; i < itemPlayerAnimationsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            ItemPlayerAnimations val = ItemPlayerAnimations.deserialize(buf, pos);\n            pos += ItemPlayerAnimations.computeBytesConsumed(buf, pos);\n            if (obj.itemPlayerAnimations.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"itemPlayerAnimations\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            pos += ItemPlayerAnimations.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int itemPlayerAnimationsCount = VarInt.peek(buffer, pos);\n            if (itemPlayerAnimationsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for ItemPlayerAnimations\");\n            }\n\n            if (itemPlayerAnimationsCount > 4096000) {\n               return ValidationResult.error(\"ItemPlayerAnimations exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < itemPlayerAnimationsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ItemPlayerAnimations.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, ItemPlayerAnimations.deserialize, ItemPlayerAnimations.computeBytesConsumed, obj.itemPlayerAnimations.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, ItemPlayerAnimations\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateModelvfxs",
        "packetId": 53,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "modelVFXs",
            "type": "Map<Integer, ModelVFX>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateModelvfxs\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 53;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, ModelVFX> modelVFXs;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateModelvfxs deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateModelvfxs obj = new UpdateModelvfxs();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int modelVFXsCount = VarInt.peek(buf, pos);\n         if (modelVFXsCount < 0) {\n            throw ProtocolException.negativeLength(\"ModelVFXs\", modelVFXsCount);\n         }\n\n         if (modelVFXsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ModelVFXs\", modelVFXsCount, 4096000);\n         }\n\n         pos += VarInt.size(modelVFXsCount);\n         obj.modelVFXs = new HashMap<>(modelVFXsCount);\n\n         for (int i = 0; i < modelVFXsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            ModelVFX val = ModelVFX.deserialize(buf, pos);\n            pos += ModelVFX.computeBytesConsumed(buf, pos);\n            if (obj.modelVFXs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"modelVFXs\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateModelvfxs deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateModelvfxs obj = new UpdateModelvfxs();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int modelVFXsCount = VarInt.peek(buf, pos);\n         if (modelVFXsCount < 0) {\n            throw ProtocolException.negativeLength(\"ModelVFXs\", modelVFXsCount);\n         }\n\n         if (modelVFXsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ModelVFXs\", modelVFXsCount, 4096000);\n         }\n\n         pos += VarInt.size(modelVFXsCount);\n         obj.modelVFXs = new HashMap<>(modelVFXsCount);\n\n         for (int i = 0; i < modelVFXsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            ModelVFX val = ModelVFX.deserialize(buf, pos);\n            pos += ModelVFX.computeBytesConsumed(buf, pos);\n            if (obj.modelVFXs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"modelVFXs\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += ModelVFX.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int modelVFXsCount = VarInt.peek(buffer, pos);\n            if (modelVFXsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for ModelVFXs\");\n            }\n\n            if (modelVFXsCount > 4096000) {\n               return ValidationResult.error(\"ModelVFXs exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < modelVFXsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ModelVFX.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ModelVFX.deserialize, ModelVFX.computeBytesConsumed, obj.modelVFXs.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, ModelVFX\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateItems",
        "packetId": 54,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "items",
            "type": "Map<String, ItemBase>",
            "nullable": true
          },
          {
            "name": "removedItems",
            "type": "String[]",
            "nullable": true
          },
          {
            "name": "updateModels",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "updateIcons",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateItems\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 54;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 12;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, ItemBase> items;\n@Nullable String[] removedItems;\n@Nonnull boolean updateModels;\n@Nonnull boolean updateIcons;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateItems deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItems obj = new UpdateItems();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.updateModels = buf.getByte(offset + 2) != 0;\n      obj.updateIcons = buf.getByte(offset + 3) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 12 + buf.getIntLE(offset + 4);\n         int itemsCount = VarInt.peek(buf, varPos0);\n         if (itemsCount < 0) {\n            throw ProtocolException.negativeLength(\"Items\", itemsCount);\n         }\n\n         if (itemsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Items\", itemsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         obj.items = new HashMap<>(itemsCount);\n         int dictPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < itemsCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            ItemBase val = ItemBase.deserialize(buf, dictPos);\n            dictPos += ItemBase.computeBytesConsumed(buf, dictPos);\n            if (obj.items.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"items\", key);\n            }\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 12 + buf.getIntLE(offset + 8);\n         int removedItemsCount = VarInt.peek(buf, varPos1);\n         if (removedItemsCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedItems\", removedItemsCount);\n         }\n\n         if (removedItemsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedItems\", removedItemsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)removedItemsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedItems\", varPos1 + varIntLen + removedItemsCount * 1, buf.readableBytes());\n         }\n\n         obj.removedItems = new String[removedItemsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < removedItemsCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedItems[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedItems[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedItems[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateItems deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItems obj = new UpdateItems();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.updateModels = buf.getByte(offset + 2) != 0;\n      obj.updateIcons = buf.getByte(offset + 3) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 12 + buf.getIntLE(offset + 4);\n         int itemsCount = VarInt.peek(buf, varPos0);\n         if (itemsCount < 0) {\n            throw ProtocolException.negativeLength(\"Items\", itemsCount);\n         }\n\n         if (itemsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Items\", itemsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         obj.items = new HashMap<>(itemsCount);\n         int dictPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < itemsCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            ItemBase val = ItemBase.deserialize(buf, dictPos);\n            dictPos += ItemBase.computeBytesConsumed(buf, dictPos);\n            if (obj.items.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"items\", key);\n            }\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 12 + buf.getIntLE(offset + 8);\n         int removedItemsCount = VarInt.peek(buf, varPos1);\n         if (removedItemsCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedItems\", removedItemsCount);\n         }\n\n         if (removedItemsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedItems\", removedItemsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)removedItemsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedItems\", varPos1 + varIntLen + removedItemsCount * 1, buf.readableBytes());\n         }\n\n         obj.removedItems = new String[removedItemsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < removedItemsCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedItems[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedItems[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedItems[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 12;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 4);\n         int pos0 = offset + 12 + fieldOffset0;\n         int dictLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos0);\n            pos0 += VarInt.length(buf, pos0) + sl;\n            pos0 += ItemBase.computeBytesConsumed(buf, pos0);\n         }\n\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 8);\n         int pos1 = offset + 12 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos1);\n            pos1 += VarInt.length(buf, pos1) + sl;\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 12) {\n         return ValidationResult.error(\"Buffer too small: expected at least 12 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int itemsOffset = buffer.getIntLE(offset + 4);\n            if (itemsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Items\");\n            }\n\n            int pos = offset + 12 + itemsOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Items\");\n            }\n\n            int itemsCount = VarInt.peek(buffer, pos);\n            if (itemsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Items\");\n            }\n\n            if (itemsCount > 4096000) {\n               return ValidationResult.error(\"Items exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < itemsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ItemBase.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int removedItemsOffset = buffer.getIntLE(offset + 8);\n            if (removedItemsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for RemovedItems\");\n            }\n\n            int posx = offset + 12 + removedItemsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for RemovedItems\");\n            }\n\n            int removedItemsCount = VarInt.peek(buffer, posx);\n            if (removedItemsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for RemovedItems\");\n            }\n\n            if (removedItemsCount > 4096000) {\n               return ValidationResult.error(\"RemovedItems exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < removedItemsCount; i++) {\n               int strLen = VarInt.peek(buffer, posx);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in RemovedItems\");\n               }\n\n               posx += VarInt.length(buffer, posx);\n               posx += strLen;\n               if (posx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in RemovedItems\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.length, ProtocolException.stringTooLong, PacketIO.readVarString, ItemBase.deserialize, ItemBase.computeBytesConsumed, obj.items.put, ProtocolException.duplicateKey, ProtocolException.arrayTooLong, buf.readableBytes, ProtocolException.bufferTooSmall\n// Types referenced: UpdateType, ItemBase\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateItemQualities",
        "packetId": 55,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "itemQualities",
            "type": "Map<Integer, ItemQuality>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateItemQualities\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 55;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, ItemQuality> itemQualities;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateItemQualities deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItemQualities obj = new UpdateItemQualities();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int itemQualitiesCount = VarInt.peek(buf, pos);\n         if (itemQualitiesCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemQualities\", itemQualitiesCount);\n         }\n\n         if (itemQualitiesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ItemQualities\", itemQualitiesCount, 4096000);\n         }\n\n         pos += VarInt.size(itemQualitiesCount);\n         obj.itemQualities = new HashMap<>(itemQualitiesCount);\n\n         for (int i = 0; i < itemQualitiesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            ItemQuality val = ItemQuality.deserialize(buf, pos);\n            pos += ItemQuality.computeBytesConsumed(buf, pos);\n            if (obj.itemQualities.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"itemQualities\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateItemQualities deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItemQualities obj = new UpdateItemQualities();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int itemQualitiesCount = VarInt.peek(buf, pos);\n         if (itemQualitiesCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemQualities\", itemQualitiesCount);\n         }\n\n         if (itemQualitiesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ItemQualities\", itemQualitiesCount, 4096000);\n         }\n\n         pos += VarInt.size(itemQualitiesCount);\n         obj.itemQualities = new HashMap<>(itemQualitiesCount);\n\n         for (int i = 0; i < itemQualitiesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            ItemQuality val = ItemQuality.deserialize(buf, pos);\n            pos += ItemQuality.computeBytesConsumed(buf, pos);\n            if (obj.itemQualities.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"itemQualities\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += ItemQuality.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int itemQualitiesCount = VarInt.peek(buffer, pos);\n            if (itemQualitiesCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for ItemQualities\");\n            }\n\n            if (itemQualitiesCount > 4096000) {\n               return ValidationResult.error(\"ItemQualities exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < itemQualitiesCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ItemQuality.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ItemQuality.deserialize, ItemQuality.computeBytesConsumed, obj.itemQualities.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, ItemQuality\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateItemCategories",
        "packetId": 56,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "itemCategories",
            "type": "ItemCategory[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateItemCategories\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 56;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable ItemCategory[] itemCategories;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateItemCategories deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItemCategories obj = new UpdateItemCategories();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int itemCategoriesCount = VarInt.peek(buf, pos);\n         if (itemCategoriesCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemCategories\", itemCategoriesCount);\n         }\n\n         if (itemCategoriesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"ItemCategories\", itemCategoriesCount, 4096000);\n         }\n\n         int itemCategoriesVarLen = VarInt.size(itemCategoriesCount);\n         if ((long)(pos + itemCategoriesVarLen) + (long)itemCategoriesCount * 6L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"ItemCategories\", pos + itemCategoriesVarLen + itemCategoriesCount * 6, buf.readableBytes());\n         }\n\n         pos += itemCategoriesVarLen;\n         obj.itemCategories = new ItemCategory[itemCategoriesCount];\n\n         for (int i = 0; i < itemCategoriesCount; i++) {\n            obj.itemCategories[i] = ItemCategory.deserialize(buf, pos);\n            pos += ItemCategory.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateItemCategories deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItemCategories obj = new UpdateItemCategories();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int itemCategoriesCount = VarInt.peek(buf, pos);\n         if (itemCategoriesCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemCategories\", itemCategoriesCount);\n         }\n\n         if (itemCategoriesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"ItemCategories\", itemCategoriesCount, 4096000);\n         }\n\n         int itemCategoriesVarLen = VarInt.size(itemCategoriesCount);\n         if ((long)(pos + itemCategoriesVarLen) + (long)itemCategoriesCount * 6L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"ItemCategories\", pos + itemCategoriesVarLen + itemCategoriesCount * 6, buf.readableBytes());\n         }\n\n         pos += itemCategoriesVarLen;\n         obj.itemCategories = new ItemCategory[itemCategoriesCount];\n\n         for (int i = 0; i < itemCategoriesCount; i++) {\n            obj.itemCategories[i] = ItemCategory.deserialize(buf, pos);\n            pos += ItemCategory.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += ItemCategory.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int itemCategoriesCount = VarInt.peek(buffer, pos);\n            if (itemCategoriesCount < 0) {\n               return ValidationResult.error(\"Invalid array count for ItemCategories\");\n            }\n\n            if (itemCategoriesCount > 4096000) {\n               return ValidationResult.error(\"ItemCategories exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < itemCategoriesCount; i++) {\n               ValidationResult structResult = ItemCategory.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid ItemCategory in ItemCategories[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += ItemCategory.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, ItemCategory.deserialize, ItemCategory.computeBytesConsumed\n// Types referenced: UpdateType, ItemCategory\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateItemReticles",
        "packetId": 57,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "itemReticleConfigs",
            "type": "Map<Integer, ItemReticleConfig>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateItemReticles\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 57;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, ItemReticleConfig> itemReticleConfigs;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateItemReticles deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItemReticles obj = new UpdateItemReticles();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int itemReticleConfigsCount = VarInt.peek(buf, pos);\n         if (itemReticleConfigsCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemReticleConfigs\", itemReticleConfigsCount);\n         }\n\n         if (itemReticleConfigsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ItemReticleConfigs\", itemReticleConfigsCount, 4096000);\n         }\n\n         pos += VarInt.size(itemReticleConfigsCount);\n         obj.itemReticleConfigs = new HashMap<>(itemReticleConfigsCount);\n\n         for (int i = 0; i < itemReticleConfigsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            ItemReticleConfig val = ItemReticleConfig.deserialize(buf, pos);\n            pos += ItemReticleConfig.computeBytesConsumed(buf, pos);\n            if (obj.itemReticleConfigs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"itemReticleConfigs\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateItemReticles deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateItemReticles obj = new UpdateItemReticles();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int itemReticleConfigsCount = VarInt.peek(buf, pos);\n         if (itemReticleConfigsCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemReticleConfigs\", itemReticleConfigsCount);\n         }\n\n         if (itemReticleConfigsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ItemReticleConfigs\", itemReticleConfigsCount, 4096000);\n         }\n\n         pos += VarInt.size(itemReticleConfigsCount);\n         obj.itemReticleConfigs = new HashMap<>(itemReticleConfigsCount);\n\n         for (int i = 0; i < itemReticleConfigsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            ItemReticleConfig val = ItemReticleConfig.deserialize(buf, pos);\n            pos += ItemReticleConfig.computeBytesConsumed(buf, pos);\n            if (obj.itemReticleConfigs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"itemReticleConfigs\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += ItemReticleConfig.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int itemReticleConfigsCount = VarInt.peek(buffer, pos);\n            if (itemReticleConfigsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for ItemReticleConfigs\");\n            }\n\n            if (itemReticleConfigsCount > 4096000) {\n               return ValidationResult.error(\"ItemReticleConfigs exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < itemReticleConfigsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ItemReticleConfig.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ItemReticleConfig.deserialize, ItemReticleConfig.computeBytesConsumed, obj.itemReticleConfigs.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, ItemReticleConfig\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateFieldcraftCategories",
        "packetId": 58,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "itemCategories",
            "type": "ItemCategory[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateFieldcraftCategories\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 58;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable ItemCategory[] itemCategories;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateFieldcraftCategories deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateFieldcraftCategories obj = new UpdateFieldcraftCategories();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int itemCategoriesCount = VarInt.peek(buf, pos);\n         if (itemCategoriesCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemCategories\", itemCategoriesCount);\n         }\n\n         if (itemCategoriesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"ItemCategories\", itemCategoriesCount, 4096000);\n         }\n\n         int itemCategoriesVarLen = VarInt.size(itemCategoriesCount);\n         if ((long)(pos + itemCategoriesVarLen) + (long)itemCategoriesCount * 6L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"ItemCategories\", pos + itemCategoriesVarLen + itemCategoriesCount * 6, buf.readableBytes());\n         }\n\n         pos += itemCategoriesVarLen;\n         obj.itemCategories = new ItemCategory[itemCategoriesCount];\n\n         for (int i = 0; i < itemCategoriesCount; i++) {\n            obj.itemCategories[i] = ItemCategory.deserialize(buf, pos);\n            pos += ItemCategory.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateFieldcraftCategories deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateFieldcraftCategories obj = new UpdateFieldcraftCategories();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int itemCategoriesCount = VarInt.peek(buf, pos);\n         if (itemCategoriesCount < 0) {\n            throw ProtocolException.negativeLength(\"ItemCategories\", itemCategoriesCount);\n         }\n\n         if (itemCategoriesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"ItemCategories\", itemCategoriesCount, 4096000);\n         }\n\n         int itemCategoriesVarLen = VarInt.size(itemCategoriesCount);\n         if ((long)(pos + itemCategoriesVarLen) + (long)itemCategoriesCount * 6L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"ItemCategories\", pos + itemCategoriesVarLen + itemCategoriesCount * 6, buf.readableBytes());\n         }\n\n         pos += itemCategoriesVarLen;\n         obj.itemCategories = new ItemCategory[itemCategoriesCount];\n\n         for (int i = 0; i < itemCategoriesCount; i++) {\n            obj.itemCategories[i] = ItemCategory.deserialize(buf, pos);\n            pos += ItemCategory.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += ItemCategory.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int itemCategoriesCount = VarInt.peek(buffer, pos);\n            if (itemCategoriesCount < 0) {\n               return ValidationResult.error(\"Invalid array count for ItemCategories\");\n            }\n\n            if (itemCategoriesCount > 4096000) {\n               return ValidationResult.error(\"ItemCategories exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < itemCategoriesCount; i++) {\n               ValidationResult structResult = ItemCategory.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid ItemCategory in ItemCategories[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += ItemCategory.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, ItemCategory.deserialize, ItemCategory.computeBytesConsumed\n// Types referenced: UpdateType, ItemCategory\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateResourceTypes",
        "packetId": 59,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "resourceTypes",
            "type": "Map<String, ResourceType>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateResourceTypes\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 59;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, ResourceType> resourceTypes;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateResourceTypes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateResourceTypes obj = new UpdateResourceTypes();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int resourceTypesCount = VarInt.peek(buf, pos);\n         if (resourceTypesCount < 0) {\n            throw ProtocolException.negativeLength(\"ResourceTypes\", resourceTypesCount);\n         }\n\n         if (resourceTypesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ResourceTypes\", resourceTypesCount, 4096000);\n         }\n\n         pos += VarInt.size(resourceTypesCount);\n         obj.resourceTypes = new HashMap<>(resourceTypesCount);\n\n         for (int i = 0; i < resourceTypesCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            ResourceType val = ResourceType.deserialize(buf, pos);\n            pos += ResourceType.computeBytesConsumed(buf, pos);\n            if (obj.resourceTypes.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"resourceTypes\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateResourceTypes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateResourceTypes obj = new UpdateResourceTypes();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int resourceTypesCount = VarInt.peek(buf, pos);\n         if (resourceTypesCount < 0) {\n            throw ProtocolException.negativeLength(\"ResourceTypes\", resourceTypesCount);\n         }\n\n         if (resourceTypesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"ResourceTypes\", resourceTypesCount, 4096000);\n         }\n\n         pos += VarInt.size(resourceTypesCount);\n         obj.resourceTypes = new HashMap<>(resourceTypesCount);\n\n         for (int i = 0; i < resourceTypesCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            ResourceType val = ResourceType.deserialize(buf, pos);\n            pos += ResourceType.computeBytesConsumed(buf, pos);\n            if (obj.resourceTypes.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"resourceTypes\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            pos += ResourceType.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int resourceTypesCount = VarInt.peek(buffer, pos);\n            if (resourceTypesCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for ResourceTypes\");\n            }\n\n            if (resourceTypesCount > 4096000) {\n               return ValidationResult.error(\"ResourceTypes exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < resourceTypesCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ResourceType.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, ResourceType.deserialize, ResourceType.computeBytesConsumed, obj.resourceTypes.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, ResourceType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateRecipes",
        "packetId": 60,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "recipes",
            "type": "Map<String, CraftingRecipe>",
            "nullable": true
          },
          {
            "name": "removedRecipes",
            "type": "String[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateRecipes\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 60;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 10;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, CraftingRecipe> recipes;\n@Nullable String[] removedRecipes;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateRecipes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateRecipes obj = new UpdateRecipes();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 10 + buf.getIntLE(offset + 2);\n         int recipesCount = VarInt.peek(buf, varPos0);\n         if (recipesCount < 0) {\n            throw ProtocolException.negativeLength(\"Recipes\", recipesCount);\n         }\n\n         if (recipesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Recipes\", recipesCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         obj.recipes = new HashMap<>(recipesCount);\n         int dictPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < recipesCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            CraftingRecipe val = CraftingRecipe.deserialize(buf, dictPos);\n            dictPos += CraftingRecipe.computeBytesConsumed(buf, dictPos);\n            if (obj.recipes.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"recipes\", key);\n            }\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 10 + buf.getIntLE(offset + 6);\n         int removedRecipesCount = VarInt.peek(buf, varPos1);\n         if (removedRecipesCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedRecipes\", removedRecipesCount);\n         }\n\n         if (removedRecipesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedRecipes\", removedRecipesCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)removedRecipesCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedRecipes\", varPos1 + varIntLen + removedRecipesCount * 1, buf.readableBytes());\n         }\n\n         obj.removedRecipes = new String[removedRecipesCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < removedRecipesCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedRecipes[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedRecipes[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedRecipes[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateRecipes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateRecipes obj = new UpdateRecipes();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 10 + buf.getIntLE(offset + 2);\n         int recipesCount = VarInt.peek(buf, varPos0);\n         if (recipesCount < 0) {\n            throw ProtocolException.negativeLength(\"Recipes\", recipesCount);\n         }\n\n         if (recipesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Recipes\", recipesCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         obj.recipes = new HashMap<>(recipesCount);\n         int dictPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < recipesCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            CraftingRecipe val = CraftingRecipe.deserialize(buf, dictPos);\n            dictPos += CraftingRecipe.computeBytesConsumed(buf, dictPos);\n            if (obj.recipes.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"recipes\", key);\n            }\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 10 + buf.getIntLE(offset + 6);\n         int removedRecipesCount = VarInt.peek(buf, varPos1);\n         if (removedRecipesCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedRecipes\", removedRecipesCount);\n         }\n\n         if (removedRecipesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedRecipes\", removedRecipesCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)removedRecipesCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedRecipes\", varPos1 + varIntLen + removedRecipesCount * 1, buf.readableBytes());\n         }\n\n         obj.removedRecipes = new String[removedRecipesCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < removedRecipesCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedRecipes[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedRecipes[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedRecipes[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 10;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 2);\n         int pos0 = offset + 10 + fieldOffset0;\n         int dictLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos0);\n            pos0 += VarInt.length(buf, pos0) + sl;\n            pos0 += CraftingRecipe.computeBytesConsumed(buf, pos0);\n         }\n\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 6);\n         int pos1 = offset + 10 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos1);\n            pos1 += VarInt.length(buf, pos1) + sl;\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 10) {\n         return ValidationResult.error(\"Buffer too small: expected at least 10 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int recipesOffset = buffer.getIntLE(offset + 2);\n            if (recipesOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Recipes\");\n            }\n\n            int pos = offset + 10 + recipesOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Recipes\");\n            }\n\n            int recipesCount = VarInt.peek(buffer, pos);\n            if (recipesCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Recipes\");\n            }\n\n            if (recipesCount > 4096000) {\n               return ValidationResult.error(\"Recipes exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < recipesCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += CraftingRecipe.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int removedRecipesOffset = buffer.getIntLE(offset + 6);\n            if (removedRecipesOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for RemovedRecipes\");\n            }\n\n            int posx = offset + 10 + removedRecipesOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for RemovedRecipes\");\n            }\n\n            int removedRecipesCount = VarInt.peek(buffer, posx);\n            if (removedRecipesCount < 0) {\n               return ValidationResult.error(\"Invalid array count for RemovedRecipes\");\n            }\n\n            if (removedRecipesCount > 4096000) {\n               return ValidationResult.error(\"RemovedRecipes exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < removedRecipesCount; i++) {\n               int strLen = VarInt.peek(buffer, posx);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in RemovedRecipes\");\n               }\n\n               posx += VarInt.length(buffer, posx);\n               posx += strLen;\n               if (posx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in RemovedRecipes\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.length, ProtocolException.stringTooLong, PacketIO.readVarString, CraftingRecipe.deserialize, CraftingRecipe.computeBytesConsumed, obj.recipes.put, ProtocolException.duplicateKey, ProtocolException.arrayTooLong, buf.readableBytes, ProtocolException.bufferTooSmall\n// Types referenced: UpdateType, CraftingRecipe\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateEnvironments",
        "packetId": 61,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "environments",
            "type": "Map<Integer, WorldEnvironment>",
            "nullable": true
          },
          {
            "name": "rebuildMapGeometry",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateEnvironments\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 61;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 7;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 7;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, WorldEnvironment> environments;\n@Nonnull boolean rebuildMapGeometry;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateEnvironments deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEnvironments obj = new UpdateEnvironments();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      obj.rebuildMapGeometry = buf.getByte(offset + 6) != 0;\n      int pos = offset + 7;\n      if ((nullBits & 1) != 0) {\n         int environmentsCount = VarInt.peek(buf, pos);\n         if (environmentsCount < 0) {\n            throw ProtocolException.negativeLength(\"Environments\", environmentsCount);\n         }\n\n         if (environmentsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Environments\", environmentsCount, 4096000);\n         }\n\n         pos += VarInt.size(environmentsCount);\n         obj.environments = new HashMap<>(environmentsCount);\n\n         for (int i = 0; i < environmentsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            WorldEnvironment val = WorldEnvironment.deserialize(buf, pos);\n            pos += WorldEnvironment.computeBytesConsumed(buf, pos);\n            if (obj.environments.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"environments\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateEnvironments deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEnvironments obj = new UpdateEnvironments();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      obj.rebuildMapGeometry = buf.getByte(offset + 6) != 0;\n      int pos = offset + 7;\n      if ((nullBits & 1) != 0) {\n         int environmentsCount = VarInt.peek(buf, pos);\n         if (environmentsCount < 0) {\n            throw ProtocolException.negativeLength(\"Environments\", environmentsCount);\n         }\n\n         if (environmentsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Environments\", environmentsCount, 4096000);\n         }\n\n         pos += VarInt.size(environmentsCount);\n         obj.environments = new HashMap<>(environmentsCount);\n\n         for (int i = 0; i < environmentsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            WorldEnvironment val = WorldEnvironment.deserialize(buf, pos);\n            pos += WorldEnvironment.computeBytesConsumed(buf, pos);\n            if (obj.environments.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"environments\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 7;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += WorldEnvironment.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 7) {\n         return ValidationResult.error(\"Buffer too small: expected at least 7 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 7;\n         if ((nullBits & 1) != 0) {\n            int environmentsCount = VarInt.peek(buffer, pos);\n            if (environmentsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Environments\");\n            }\n\n            if (environmentsCount > 4096000) {\n               return ValidationResult.error(\"Environments exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < environmentsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += WorldEnvironment.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, WorldEnvironment.deserialize, WorldEnvironment.computeBytesConsumed, obj.environments.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, WorldEnvironment\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateAmbienceFX",
        "packetId": 62,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "ambienceFX",
            "type": "Map<Integer, AmbienceFX>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateAmbienceFX\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 62;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, AmbienceFX> ambienceFX;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateAmbienceFX deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateAmbienceFX obj = new UpdateAmbienceFX();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int ambienceFXCount = VarInt.peek(buf, pos);\n         if (ambienceFXCount < 0) {\n            throw ProtocolException.negativeLength(\"AmbienceFX\", ambienceFXCount);\n         }\n\n         if (ambienceFXCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"AmbienceFX\", ambienceFXCount, 4096000);\n         }\n\n         pos += VarInt.size(ambienceFXCount);\n         obj.ambienceFX = new HashMap<>(ambienceFXCount);\n\n         for (int i = 0; i < ambienceFXCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            AmbienceFX val = AmbienceFX.deserialize(buf, pos);\n            pos += AmbienceFX.computeBytesConsumed(buf, pos);\n            if (obj.ambienceFX.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"ambienceFX\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateAmbienceFX deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateAmbienceFX obj = new UpdateAmbienceFX();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int ambienceFXCount = VarInt.peek(buf, pos);\n         if (ambienceFXCount < 0) {\n            throw ProtocolException.negativeLength(\"AmbienceFX\", ambienceFXCount);\n         }\n\n         if (ambienceFXCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"AmbienceFX\", ambienceFXCount, 4096000);\n         }\n\n         pos += VarInt.size(ambienceFXCount);\n         obj.ambienceFX = new HashMap<>(ambienceFXCount);\n\n         for (int i = 0; i < ambienceFXCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            AmbienceFX val = AmbienceFX.deserialize(buf, pos);\n            pos += AmbienceFX.computeBytesConsumed(buf, pos);\n            if (obj.ambienceFX.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"ambienceFX\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += AmbienceFX.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int ambienceFXCount = VarInt.peek(buffer, pos);\n            if (ambienceFXCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for AmbienceFX\");\n            }\n\n            if (ambienceFXCount > 4096000) {\n               return ValidationResult.error(\"AmbienceFX exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < ambienceFXCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += AmbienceFX.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, AmbienceFX.deserialize, AmbienceFX.computeBytesConsumed, obj.ambienceFX.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, AmbienceFX\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateFluidFX",
        "packetId": 63,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "fluidFX",
            "type": "Map<Integer, FluidFX>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateFluidFX\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 63;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, FluidFX> fluidFX;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateFluidFX deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateFluidFX obj = new UpdateFluidFX();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int fluidFXCount = VarInt.peek(buf, pos);\n         if (fluidFXCount < 0) {\n            throw ProtocolException.negativeLength(\"FluidFX\", fluidFXCount);\n         }\n\n         if (fluidFXCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"FluidFX\", fluidFXCount, 4096000);\n         }\n\n         pos += VarInt.size(fluidFXCount);\n         obj.fluidFX = new HashMap<>(fluidFXCount);\n\n         for (int i = 0; i < fluidFXCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            FluidFX val = FluidFX.deserialize(buf, pos);\n            pos += FluidFX.computeBytesConsumed(buf, pos);\n            if (obj.fluidFX.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"fluidFX\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateFluidFX deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateFluidFX obj = new UpdateFluidFX();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int fluidFXCount = VarInt.peek(buf, pos);\n         if (fluidFXCount < 0) {\n            throw ProtocolException.negativeLength(\"FluidFX\", fluidFXCount);\n         }\n\n         if (fluidFXCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"FluidFX\", fluidFXCount, 4096000);\n         }\n\n         pos += VarInt.size(fluidFXCount);\n         obj.fluidFX = new HashMap<>(fluidFXCount);\n\n         for (int i = 0; i < fluidFXCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            FluidFX val = FluidFX.deserialize(buf, pos);\n            pos += FluidFX.computeBytesConsumed(buf, pos);\n            if (obj.fluidFX.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"fluidFX\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += FluidFX.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int fluidFXCount = VarInt.peek(buffer, pos);\n            if (fluidFXCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for FluidFX\");\n            }\n\n            if (fluidFXCount > 4096000) {\n               return ValidationResult.error(\"FluidFX exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < fluidFXCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += FluidFX.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, FluidFX.deserialize, FluidFX.computeBytesConsumed, obj.fluidFX.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, FluidFX\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateTranslations",
        "packetId": 64,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "translations",
            "type": "Map<String, String>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateTranslations\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 64;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, String> translations;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateTranslations deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateTranslations obj = new UpdateTranslations();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int translationsCount = VarInt.peek(buf, pos);\n         if (translationsCount < 0) {\n            throw ProtocolException.negativeLength(\"Translations\", translationsCount);\n         }\n\n         if (translationsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Translations\", translationsCount, 4096000);\n         }\n\n         pos += VarInt.size(translationsCount);\n         obj.translations = new HashMap<>(translationsCount);\n\n         for (int i = 0; i < translationsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            int valLen = VarInt.peek(buf, pos);\n            if (valLen < 0) {\n               throw ProtocolException.negativeLength(\"val\", valLen);\n            }\n\n            if (valLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"val\", valLen, 4096000);\n            }\n\n            int valVarLen = VarInt.length(buf, pos);\n            String val = PacketIO.readVarString(buf, pos);\n            pos += valVarLen + valLen;\n            if (obj.translations.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"translations\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int translationsCount = VarInt.peek(buffer, pos);\n            if (translationsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Translations\");\n            }\n\n            if (translationsCount > 4096000) {\n               return ValidationResult.error(\"Translations exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < translationsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               int valueLen = VarInt.peek(buffer, pos);\n               if (valueLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for value\");\n               }\n\n               if (valueLen > 4096000) {\n                  return ValidationResult.error(\"value exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += valueLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading value\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, obj.translations.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateSoundEvents",
        "packetId": 65,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "soundEvents",
            "type": "Map<Integer, SoundEvent>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateSoundEvents\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 65;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, SoundEvent> soundEvents;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateSoundEvents deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateSoundEvents obj = new UpdateSoundEvents();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int soundEventsCount = VarInt.peek(buf, pos);\n         if (soundEventsCount < 0) {\n            throw ProtocolException.negativeLength(\"SoundEvents\", soundEventsCount);\n         }\n\n         if (soundEventsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"SoundEvents\", soundEventsCount, 4096000);\n         }\n\n         pos += VarInt.size(soundEventsCount);\n         obj.soundEvents = new HashMap<>(soundEventsCount);\n\n         for (int i = 0; i < soundEventsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            SoundEvent val = SoundEvent.deserialize(buf, pos);\n            pos += SoundEvent.computeBytesConsumed(buf, pos);\n            if (obj.soundEvents.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"soundEvents\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateSoundEvents deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateSoundEvents obj = new UpdateSoundEvents();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int soundEventsCount = VarInt.peek(buf, pos);\n         if (soundEventsCount < 0) {\n            throw ProtocolException.negativeLength(\"SoundEvents\", soundEventsCount);\n         }\n\n         if (soundEventsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"SoundEvents\", soundEventsCount, 4096000);\n         }\n\n         pos += VarInt.size(soundEventsCount);\n         obj.soundEvents = new HashMap<>(soundEventsCount);\n\n         for (int i = 0; i < soundEventsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            SoundEvent val = SoundEvent.deserialize(buf, pos);\n            pos += SoundEvent.computeBytesConsumed(buf, pos);\n            if (obj.soundEvents.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"soundEvents\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += SoundEvent.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int soundEventsCount = VarInt.peek(buffer, pos);\n            if (soundEventsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for SoundEvents\");\n            }\n\n            if (soundEventsCount > 4096000) {\n               return ValidationResult.error(\"SoundEvents exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < soundEventsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += SoundEvent.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, SoundEvent.deserialize, SoundEvent.computeBytesConsumed, obj.soundEvents.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, SoundEvent\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateInteractions",
        "packetId": 66,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "interactions",
            "type": "Map<Integer, Interaction>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateInteractions\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 66;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, Interaction> interactions;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateInteractions deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateInteractions obj = new UpdateInteractions();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int interactionsCount = VarInt.peek(buf, pos);\n         if (interactionsCount < 0) {\n            throw ProtocolException.negativeLength(\"Interactions\", interactionsCount);\n         }\n\n         if (interactionsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Interactions\", interactionsCount, 4096000);\n         }\n\n         pos += VarInt.size(interactionsCount);\n         obj.interactions = new HashMap<>(interactionsCount);\n\n         for (int i = 0; i < interactionsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            Interaction val = Interaction.deserialize(buf, pos);\n            pos += Interaction.computeBytesConsumed(buf, pos);\n            if (obj.interactions.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"interactions\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateInteractions deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateInteractions obj = new UpdateInteractions();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int interactionsCount = VarInt.peek(buf, pos);\n         if (interactionsCount < 0) {\n            throw ProtocolException.negativeLength(\"Interactions\", interactionsCount);\n         }\n\n         if (interactionsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Interactions\", interactionsCount, 4096000);\n         }\n\n         pos += VarInt.size(interactionsCount);\n         obj.interactions = new HashMap<>(interactionsCount);\n\n         for (int i = 0; i < interactionsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            Interaction val = Interaction.deserialize(buf, pos);\n            pos += Interaction.computeBytesConsumed(buf, pos);\n            if (obj.interactions.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"interactions\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += Interaction.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int interactionsCount = VarInt.peek(buffer, pos);\n            if (interactionsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Interactions\");\n            }\n\n            if (interactionsCount > 4096000) {\n               return ValidationResult.error(\"Interactions exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < interactionsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += Interaction.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, Interaction.deserialize, Interaction.computeBytesConsumed, obj.interactions.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, Interaction\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateRootInteractions",
        "packetId": 67,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "interactions",
            "type": "Map<Integer, RootInteraction>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateRootInteractions\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 67;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, RootInteraction> interactions;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateRootInteractions deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateRootInteractions obj = new UpdateRootInteractions();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int interactionsCount = VarInt.peek(buf, pos);\n         if (interactionsCount < 0) {\n            throw ProtocolException.negativeLength(\"Interactions\", interactionsCount);\n         }\n\n         if (interactionsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Interactions\", interactionsCount, 4096000);\n         }\n\n         pos += VarInt.size(interactionsCount);\n         obj.interactions = new HashMap<>(interactionsCount);\n\n         for (int i = 0; i < interactionsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            RootInteraction val = RootInteraction.deserialize(buf, pos);\n            pos += RootInteraction.computeBytesConsumed(buf, pos);\n            if (obj.interactions.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"interactions\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateRootInteractions deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateRootInteractions obj = new UpdateRootInteractions();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int interactionsCount = VarInt.peek(buf, pos);\n         if (interactionsCount < 0) {\n            throw ProtocolException.negativeLength(\"Interactions\", interactionsCount);\n         }\n\n         if (interactionsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Interactions\", interactionsCount, 4096000);\n         }\n\n         pos += VarInt.size(interactionsCount);\n         obj.interactions = new HashMap<>(interactionsCount);\n\n         for (int i = 0; i < interactionsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            RootInteraction val = RootInteraction.deserialize(buf, pos);\n            pos += RootInteraction.computeBytesConsumed(buf, pos);\n            if (obj.interactions.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"interactions\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += RootInteraction.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int interactionsCount = VarInt.peek(buffer, pos);\n            if (interactionsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Interactions\");\n            }\n\n            if (interactionsCount > 4096000) {\n               return ValidationResult.error(\"Interactions exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < interactionsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += RootInteraction.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, RootInteraction.deserialize, RootInteraction.computeBytesConsumed, obj.interactions.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, RootInteraction\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateUnarmedInteractions",
        "packetId": 68,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "interactions",
            "type": "Map<InteractionType, Integer>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateUnarmedInteractions\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 68;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 20480007;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<InteractionType, Integer> interactions;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateUnarmedInteractions deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateUnarmedInteractions obj = new UpdateUnarmedInteractions();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int interactionsCount = VarInt.peek(buf, pos);\n         if (interactionsCount < 0) {\n            throw ProtocolException.negativeLength(\"Interactions\", interactionsCount);\n         }\n\n         if (interactionsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Interactions\", interactionsCount, 4096000);\n         }\n\n         pos += VarInt.size(interactionsCount);\n         obj.interactions = new HashMap<>(interactionsCount);\n\n         for (int i = 0; i < interactionsCount; i++) {\n            InteractionType key = InteractionType.fromValue(buf.getByte(pos));\n            int val = buf.getIntLE(++pos);\n            pos += 4;\n            if (obj.interactions.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"interactions\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos = ++pos + 4;\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int interactionsCount = VarInt.peek(buffer, pos);\n            if (interactionsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Interactions\");\n            }\n\n            if (interactionsCount > 4096000) {\n               return ValidationResult.error(\"Interactions exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < interactionsCount; i++) {\n               pos = ++pos + 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading value\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, InteractionType.fromValue, buf.getIntLE, obj.interactions.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, InteractionType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "TrackOrUpdateObjective",
        "packetId": 69,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "objective",
            "type": "Objective",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: TrackOrUpdateObjective\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 69;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable Objective objective;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static TrackOrUpdateObjective deserialize(@Nonnull ByteBuf buf, int offset) {\n      TrackOrUpdateObjective obj = new TrackOrUpdateObjective();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         obj.objective = Objective.deserialize(buf, pos);\n         pos += Objective.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static TrackOrUpdateObjective deserialize(@Nonnull ByteBuf buf, int offset) {\n      TrackOrUpdateObjective obj = new TrackOrUpdateObjective();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         obj.objective = Objective.deserialize(buf, pos);\n         pos += Objective.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         pos += Objective.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            ValidationResult objectiveResult = Objective.validateStructure(buffer, pos);\n            if (!objectiveResult.isValid()) {\n               return ValidationResult.error(\"Invalid Objective: \" + objectiveResult.error());\n            }\n\n            pos += Objective.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, Objective.deserialize, Objective.computeBytesConsumed\n// Types referenced: Objective\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UntrackObjective",
        "packetId": 70,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "objectiveUuid",
            "type": "UUID",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UntrackObjective\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 70;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 16;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 16;\npublic static final int MAX_SIZE = 16;\n\n// === FIELDS ===\n@Nonnull UUID objectiveUuid;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UntrackObjective deserialize(@Nonnull ByteBuf buf, int offset) {\n      UntrackObjective obj = new UntrackObjective();\n      obj.objectiveUuid = PacketIO.readUUID(buf, offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 16;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 16 ? ValidationResult.error(\"Buffer too small: expected at least 16 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: PacketIO.readUUID\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateObjectiveTask",
        "packetId": 71,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "objectiveUuid",
            "type": "UUID",
            "nullable": false
          },
          {
            "name": "taskIndex",
            "type": "int",
            "nullable": false
          },
          {
            "name": "task",
            "type": "ObjectiveTask",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateObjectiveTask\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 71;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 21;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 21;\npublic static final int MAX_SIZE = 16384035;\n\n// === FIELDS ===\n@Nonnull UUID objectiveUuid;\n@Nonnull int taskIndex;\n@Nullable ObjectiveTask task;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateObjectiveTask deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateObjectiveTask obj = new UpdateObjectiveTask();\n      byte nullBits = buf.getByte(offset);\n      obj.objectiveUuid = PacketIO.readUUID(buf, offset + 1);\n      obj.taskIndex = buf.getIntLE(offset + 17);\n      int pos = offset + 21;\n      if ((nullBits & 1) != 0) {\n         obj.task = ObjectiveTask.deserialize(buf, pos);\n         pos += ObjectiveTask.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateObjectiveTask deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateObjectiveTask obj = new UpdateObjectiveTask();\n      byte nullBits = buf.getByte(offset);\n      obj.objectiveUuid = PacketIO.readUUID(buf, offset + 1);\n      obj.taskIndex = buf.getIntLE(offset + 17);\n      int pos = offset + 21;\n      if ((nullBits & 1) != 0) {\n         obj.task = ObjectiveTask.deserialize(buf, pos);\n         pos += ObjectiveTask.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 21;\n      if ((nullBits & 1) != 0) {\n         pos += ObjectiveTask.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 21) {\n         return ValidationResult.error(\"Buffer too small: expected at least 21 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 21;\n         if ((nullBits & 1) != 0) {\n            ValidationResult taskResult = ObjectiveTask.validateStructure(buffer, pos);\n            if (!taskResult.isValid()) {\n               return ValidationResult.error(\"Invalid Task: \" + taskResult.error());\n            }\n\n            pos += ObjectiveTask.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, PacketIO.readUUID, buf.getIntLE, ObjectiveTask.deserialize, ObjectiveTask.computeBytesConsumed\n// Types referenced: ObjectiveTask\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateEntityStatTypes",
        "packetId": 72,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "types",
            "type": "Map<Integer, EntityStatType>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateEntityStatTypes\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 72;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, EntityStatType> types;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateEntityStatTypes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEntityStatTypes obj = new UpdateEntityStatTypes();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int typesCount = VarInt.peek(buf, pos);\n         if (typesCount < 0) {\n            throw ProtocolException.negativeLength(\"Types\", typesCount);\n         }\n\n         if (typesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Types\", typesCount, 4096000);\n         }\n\n         pos += VarInt.size(typesCount);\n         obj.types = new HashMap<>(typesCount);\n\n         for (int i = 0; i < typesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            EntityStatType val = EntityStatType.deserialize(buf, pos);\n            pos += EntityStatType.computeBytesConsumed(buf, pos);\n            if (obj.types.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"types\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateEntityStatTypes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEntityStatTypes obj = new UpdateEntityStatTypes();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int typesCount = VarInt.peek(buf, pos);\n         if (typesCount < 0) {\n            throw ProtocolException.negativeLength(\"Types\", typesCount);\n         }\n\n         if (typesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Types\", typesCount, 4096000);\n         }\n\n         pos += VarInt.size(typesCount);\n         obj.types = new HashMap<>(typesCount);\n\n         for (int i = 0; i < typesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            EntityStatType val = EntityStatType.deserialize(buf, pos);\n            pos += EntityStatType.computeBytesConsumed(buf, pos);\n            if (obj.types.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"types\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += EntityStatType.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int typesCount = VarInt.peek(buffer, pos);\n            if (typesCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Types\");\n            }\n\n            if (typesCount > 4096000) {\n               return ValidationResult.error(\"Types exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < typesCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += EntityStatType.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, EntityStatType.deserialize, EntityStatType.computeBytesConsumed, obj.types.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, EntityStatType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateEntityUIComponents",
        "packetId": 73,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "components",
            "type": "Map<Integer, EntityUIComponent>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateEntityUIComponents\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 73;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, EntityUIComponent> components;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateEntityUIComponents deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEntityUIComponents obj = new UpdateEntityUIComponents();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int componentsCount = VarInt.peek(buf, pos);\n         if (componentsCount < 0) {\n            throw ProtocolException.negativeLength(\"Components\", componentsCount);\n         }\n\n         if (componentsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Components\", componentsCount, 4096000);\n         }\n\n         pos += VarInt.size(componentsCount);\n         obj.components = new HashMap<>(componentsCount);\n\n         for (int i = 0; i < componentsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            EntityUIComponent val = EntityUIComponent.deserialize(buf, pos);\n            pos += EntityUIComponent.computeBytesConsumed(buf, pos);\n            if (obj.components.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"components\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateEntityUIComponents deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEntityUIComponents obj = new UpdateEntityUIComponents();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int componentsCount = VarInt.peek(buf, pos);\n         if (componentsCount < 0) {\n            throw ProtocolException.negativeLength(\"Components\", componentsCount);\n         }\n\n         if (componentsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Components\", componentsCount, 4096000);\n         }\n\n         pos += VarInt.size(componentsCount);\n         obj.components = new HashMap<>(componentsCount);\n\n         for (int i = 0; i < componentsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            EntityUIComponent val = EntityUIComponent.deserialize(buf, pos);\n            pos += EntityUIComponent.computeBytesConsumed(buf, pos);\n            if (obj.components.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"components\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += EntityUIComponent.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int componentsCount = VarInt.peek(buffer, pos);\n            if (componentsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Components\");\n            }\n\n            if (componentsCount > 4096000) {\n               return ValidationResult.error(\"Components exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < componentsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += EntityUIComponent.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, EntityUIComponent.deserialize, EntityUIComponent.computeBytesConsumed, obj.components.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, EntityUIComponent\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateHitboxCollisionConfig",
        "packetId": 74,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "hitboxCollisionConfigs",
            "type": "Map<Integer, HitboxCollisionConfig>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateHitboxCollisionConfig\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 74;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 36864011;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, HitboxCollisionConfig> hitboxCollisionConfigs;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateHitboxCollisionConfig deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateHitboxCollisionConfig obj = new UpdateHitboxCollisionConfig();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int hitboxCollisionConfigsCount = VarInt.peek(buf, pos);\n         if (hitboxCollisionConfigsCount < 0) {\n            throw ProtocolException.negativeLength(\"HitboxCollisionConfigs\", hitboxCollisionConfigsCount);\n         }\n\n         if (hitboxCollisionConfigsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"HitboxCollisionConfigs\", hitboxCollisionConfigsCount, 4096000);\n         }\n\n         pos += VarInt.size(hitboxCollisionConfigsCount);\n         obj.hitboxCollisionConfigs = new HashMap<>(hitboxCollisionConfigsCount);\n\n         for (int i = 0; i < hitboxCollisionConfigsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            HitboxCollisionConfig val = HitboxCollisionConfig.deserialize(buf, pos);\n            pos += HitboxCollisionConfig.computeBytesConsumed(buf, pos);\n            if (obj.hitboxCollisionConfigs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"hitboxCollisionConfigs\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateHitboxCollisionConfig deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateHitboxCollisionConfig obj = new UpdateHitboxCollisionConfig();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int hitboxCollisionConfigsCount = VarInt.peek(buf, pos);\n         if (hitboxCollisionConfigsCount < 0) {\n            throw ProtocolException.negativeLength(\"HitboxCollisionConfigs\", hitboxCollisionConfigsCount);\n         }\n\n         if (hitboxCollisionConfigsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"HitboxCollisionConfigs\", hitboxCollisionConfigsCount, 4096000);\n         }\n\n         pos += VarInt.size(hitboxCollisionConfigsCount);\n         obj.hitboxCollisionConfigs = new HashMap<>(hitboxCollisionConfigsCount);\n\n         for (int i = 0; i < hitboxCollisionConfigsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            HitboxCollisionConfig val = HitboxCollisionConfig.deserialize(buf, pos);\n            pos += HitboxCollisionConfig.computeBytesConsumed(buf, pos);\n            if (obj.hitboxCollisionConfigs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"hitboxCollisionConfigs\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += HitboxCollisionConfig.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int hitboxCollisionConfigsCount = VarInt.peek(buffer, pos);\n            if (hitboxCollisionConfigsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for HitboxCollisionConfigs\");\n            }\n\n            if (hitboxCollisionConfigsCount > 4096000) {\n               return ValidationResult.error(\"HitboxCollisionConfigs exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < hitboxCollisionConfigsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += 5;\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, HitboxCollisionConfig.deserialize, HitboxCollisionConfig.computeBytesConsumed, obj.hitboxCollisionConfigs.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, HitboxCollisionConfig\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateRepulsionConfig",
        "packetId": 75,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "repulsionConfigs",
            "type": "Map<Integer, RepulsionConfig>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateRepulsionConfig\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 75;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 65536011;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, RepulsionConfig> repulsionConfigs;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateRepulsionConfig deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateRepulsionConfig obj = new UpdateRepulsionConfig();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int repulsionConfigsCount = VarInt.peek(buf, pos);\n         if (repulsionConfigsCount < 0) {\n            throw ProtocolException.negativeLength(\"RepulsionConfigs\", repulsionConfigsCount);\n         }\n\n         if (repulsionConfigsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"RepulsionConfigs\", repulsionConfigsCount, 4096000);\n         }\n\n         pos += VarInt.size(repulsionConfigsCount);\n         obj.repulsionConfigs = new HashMap<>(repulsionConfigsCount);\n\n         for (int i = 0; i < repulsionConfigsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            RepulsionConfig val = RepulsionConfig.deserialize(buf, pos);\n            pos += RepulsionConfig.computeBytesConsumed(buf, pos);\n            if (obj.repulsionConfigs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"repulsionConfigs\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateRepulsionConfig deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateRepulsionConfig obj = new UpdateRepulsionConfig();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int repulsionConfigsCount = VarInt.peek(buf, pos);\n         if (repulsionConfigsCount < 0) {\n            throw ProtocolException.negativeLength(\"RepulsionConfigs\", repulsionConfigsCount);\n         }\n\n         if (repulsionConfigsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"RepulsionConfigs\", repulsionConfigsCount, 4096000);\n         }\n\n         pos += VarInt.size(repulsionConfigsCount);\n         obj.repulsionConfigs = new HashMap<>(repulsionConfigsCount);\n\n         for (int i = 0; i < repulsionConfigsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            RepulsionConfig val = RepulsionConfig.deserialize(buf, pos);\n            pos += RepulsionConfig.computeBytesConsumed(buf, pos);\n            if (obj.repulsionConfigs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"repulsionConfigs\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += RepulsionConfig.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int repulsionConfigsCount = VarInt.peek(buffer, pos);\n            if (repulsionConfigsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for RepulsionConfigs\");\n            }\n\n            if (repulsionConfigsCount > 4096000) {\n               return ValidationResult.error(\"RepulsionConfigs exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < repulsionConfigsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += 12;\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, RepulsionConfig.deserialize, RepulsionConfig.computeBytesConsumed, obj.repulsionConfigs.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, RepulsionConfig\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateViewBobbing",
        "packetId": 76,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "profiles",
            "type": "Map<MovementType, ViewBobbing>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateViewBobbing\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 76;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<MovementType, ViewBobbing> profiles;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateViewBobbing deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateViewBobbing obj = new UpdateViewBobbing();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int profilesCount = VarInt.peek(buf, pos);\n         if (profilesCount < 0) {\n            throw ProtocolException.negativeLength(\"Profiles\", profilesCount);\n         }\n\n         if (profilesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Profiles\", profilesCount, 4096000);\n         }\n\n         pos += VarInt.size(profilesCount);\n         obj.profiles = new HashMap<>(profilesCount);\n\n         for (int i = 0; i < profilesCount; i++) {\n            MovementType key = MovementType.fromValue(buf.getByte(pos));\n            ViewBobbing val = ViewBobbing.deserialize(buf, ++pos);\n            pos += ViewBobbing.computeBytesConsumed(buf, pos);\n            if (obj.profiles.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"profiles\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateViewBobbing deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateViewBobbing obj = new UpdateViewBobbing();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int profilesCount = VarInt.peek(buf, pos);\n         if (profilesCount < 0) {\n            throw ProtocolException.negativeLength(\"Profiles\", profilesCount);\n         }\n\n         if (profilesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Profiles\", profilesCount, 4096000);\n         }\n\n         pos += VarInt.size(profilesCount);\n         obj.profiles = new HashMap<>(profilesCount);\n\n         for (int i = 0; i < profilesCount; i++) {\n            MovementType key = MovementType.fromValue(buf.getByte(pos));\n            ViewBobbing val = ViewBobbing.deserialize(buf, ++pos);\n            pos += ViewBobbing.computeBytesConsumed(buf, pos);\n            if (obj.profiles.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"profiles\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos = ++pos + ViewBobbing.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int profilesCount = VarInt.peek(buffer, pos);\n            if (profilesCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Profiles\");\n            }\n\n            if (profilesCount > 4096000) {\n               return ValidationResult.error(\"Profiles exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < profilesCount; i++) {\n               pos = ++pos + ViewBobbing.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, MovementType.fromValue, ViewBobbing.deserialize, ViewBobbing.computeBytesConsumed, obj.profiles.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, MovementType, ViewBobbing\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateCameraShake",
        "packetId": 77,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "profiles",
            "type": "Map<Integer, CameraShake>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateCameraShake\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 77;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<Integer, CameraShake> profiles;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateCameraShake deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateCameraShake obj = new UpdateCameraShake();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int profilesCount = VarInt.peek(buf, pos);\n         if (profilesCount < 0) {\n            throw ProtocolException.negativeLength(\"Profiles\", profilesCount);\n         }\n\n         if (profilesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Profiles\", profilesCount, 4096000);\n         }\n\n         pos += VarInt.size(profilesCount);\n         obj.profiles = new HashMap<>(profilesCount);\n\n         for (int i = 0; i < profilesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            CameraShake val = CameraShake.deserialize(buf, pos);\n            pos += CameraShake.computeBytesConsumed(buf, pos);\n            if (obj.profiles.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"profiles\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateCameraShake deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateCameraShake obj = new UpdateCameraShake();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int profilesCount = VarInt.peek(buf, pos);\n         if (profilesCount < 0) {\n            throw ProtocolException.negativeLength(\"Profiles\", profilesCount);\n         }\n\n         if (profilesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Profiles\", profilesCount, 4096000);\n         }\n\n         pos += VarInt.size(profilesCount);\n         obj.profiles = new HashMap<>(profilesCount);\n\n         for (int i = 0; i < profilesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            CameraShake val = CameraShake.deserialize(buf, pos);\n            pos += CameraShake.computeBytesConsumed(buf, pos);\n            if (obj.profiles.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"profiles\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += CameraShake.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int profilesCount = VarInt.peek(buffer, pos);\n            if (profilesCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Profiles\");\n            }\n\n            if (profilesCount > 4096000) {\n               return ValidationResult.error(\"Profiles exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < profilesCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += CameraShake.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, buf.getIntLE, CameraShake.deserialize, CameraShake.computeBytesConsumed, obj.profiles.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, CameraShake\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateBlockGroups",
        "packetId": 78,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "groups",
            "type": "Map<String, BlockGroup>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateBlockGroups\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 78;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, BlockGroup> groups;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateBlockGroups deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockGroups obj = new UpdateBlockGroups();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int groupsCount = VarInt.peek(buf, pos);\n         if (groupsCount < 0) {\n            throw ProtocolException.negativeLength(\"Groups\", groupsCount);\n         }\n\n         if (groupsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Groups\", groupsCount, 4096000);\n         }\n\n         pos += VarInt.size(groupsCount);\n         obj.groups = new HashMap<>(groupsCount);\n\n         for (int i = 0; i < groupsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            BlockGroup val = BlockGroup.deserialize(buf, pos);\n            pos += BlockGroup.computeBytesConsumed(buf, pos);\n            if (obj.groups.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"groups\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateBlockGroups deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockGroups obj = new UpdateBlockGroups();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int groupsCount = VarInt.peek(buf, pos);\n         if (groupsCount < 0) {\n            throw ProtocolException.negativeLength(\"Groups\", groupsCount);\n         }\n\n         if (groupsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Groups\", groupsCount, 4096000);\n         }\n\n         pos += VarInt.size(groupsCount);\n         obj.groups = new HashMap<>(groupsCount);\n\n         for (int i = 0; i < groupsCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            BlockGroup val = BlockGroup.deserialize(buf, pos);\n            pos += BlockGroup.computeBytesConsumed(buf, pos);\n            if (obj.groups.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"groups\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            pos += BlockGroup.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int groupsCount = VarInt.peek(buffer, pos);\n            if (groupsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Groups\");\n            }\n\n            if (groupsCount > 4096000) {\n               return ValidationResult.error(\"Groups exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < groupsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += BlockGroup.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, BlockGroup.deserialize, BlockGroup.computeBytesConsumed, obj.groups.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, BlockGroup\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateSoundSets",
        "packetId": 79,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "soundSets",
            "type": "Map<Integer, SoundSet>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateSoundSets\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 79;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, SoundSet> soundSets;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateSoundSets deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateSoundSets obj = new UpdateSoundSets();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int soundSetsCount = VarInt.peek(buf, pos);\n         if (soundSetsCount < 0) {\n            throw ProtocolException.negativeLength(\"SoundSets\", soundSetsCount);\n         }\n\n         if (soundSetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"SoundSets\", soundSetsCount, 4096000);\n         }\n\n         pos += VarInt.size(soundSetsCount);\n         obj.soundSets = new HashMap<>(soundSetsCount);\n\n         for (int i = 0; i < soundSetsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            SoundSet val = SoundSet.deserialize(buf, pos);\n            pos += SoundSet.computeBytesConsumed(buf, pos);\n            if (obj.soundSets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"soundSets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateSoundSets deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateSoundSets obj = new UpdateSoundSets();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int soundSetsCount = VarInt.peek(buf, pos);\n         if (soundSetsCount < 0) {\n            throw ProtocolException.negativeLength(\"SoundSets\", soundSetsCount);\n         }\n\n         if (soundSetsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"SoundSets\", soundSetsCount, 4096000);\n         }\n\n         pos += VarInt.size(soundSetsCount);\n         obj.soundSets = new HashMap<>(soundSetsCount);\n\n         for (int i = 0; i < soundSetsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            SoundSet val = SoundSet.deserialize(buf, pos);\n            pos += SoundSet.computeBytesConsumed(buf, pos);\n            if (obj.soundSets.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"soundSets\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += SoundSet.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int soundSetsCount = VarInt.peek(buffer, pos);\n            if (soundSetsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for SoundSets\");\n            }\n\n            if (soundSetsCount > 4096000) {\n               return ValidationResult.error(\"SoundSets exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < soundSetsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += SoundSet.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, SoundSet.deserialize, SoundSet.computeBytesConsumed, obj.soundSets.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, SoundSet\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateAudioCategories",
        "packetId": 80,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "categories",
            "type": "Map<Integer, AudioCategory>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateAudioCategories\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 80;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, AudioCategory> categories;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateAudioCategories deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateAudioCategories obj = new UpdateAudioCategories();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int categoriesCount = VarInt.peek(buf, pos);\n         if (categoriesCount < 0) {\n            throw ProtocolException.negativeLength(\"Categories\", categoriesCount);\n         }\n\n         if (categoriesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Categories\", categoriesCount, 4096000);\n         }\n\n         pos += VarInt.size(categoriesCount);\n         obj.categories = new HashMap<>(categoriesCount);\n\n         for (int i = 0; i < categoriesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            AudioCategory val = AudioCategory.deserialize(buf, pos);\n            pos += AudioCategory.computeBytesConsumed(buf, pos);\n            if (obj.categories.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"categories\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateAudioCategories deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateAudioCategories obj = new UpdateAudioCategories();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int categoriesCount = VarInt.peek(buf, pos);\n         if (categoriesCount < 0) {\n            throw ProtocolException.negativeLength(\"Categories\", categoriesCount);\n         }\n\n         if (categoriesCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Categories\", categoriesCount, 4096000);\n         }\n\n         pos += VarInt.size(categoriesCount);\n         obj.categories = new HashMap<>(categoriesCount);\n\n         for (int i = 0; i < categoriesCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            AudioCategory val = AudioCategory.deserialize(buf, pos);\n            pos += AudioCategory.computeBytesConsumed(buf, pos);\n            if (obj.categories.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"categories\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += AudioCategory.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int categoriesCount = VarInt.peek(buffer, pos);\n            if (categoriesCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Categories\");\n            }\n\n            if (categoriesCount > 4096000) {\n               return ValidationResult.error(\"Categories exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < categoriesCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += AudioCategory.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, AudioCategory.deserialize, AudioCategory.computeBytesConsumed, obj.categories.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, AudioCategory\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateReverbEffects",
        "packetId": 81,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "effects",
            "type": "Map<Integer, ReverbEffect>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateReverbEffects\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 81;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, ReverbEffect> effects;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateReverbEffects deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateReverbEffects obj = new UpdateReverbEffects();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int effectsCount = VarInt.peek(buf, pos);\n         if (effectsCount < 0) {\n            throw ProtocolException.negativeLength(\"Effects\", effectsCount);\n         }\n\n         if (effectsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Effects\", effectsCount, 4096000);\n         }\n\n         pos += VarInt.size(effectsCount);\n         obj.effects = new HashMap<>(effectsCount);\n\n         for (int i = 0; i < effectsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            ReverbEffect val = ReverbEffect.deserialize(buf, pos);\n            pos += ReverbEffect.computeBytesConsumed(buf, pos);\n            if (obj.effects.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"effects\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateReverbEffects deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateReverbEffects obj = new UpdateReverbEffects();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int effectsCount = VarInt.peek(buf, pos);\n         if (effectsCount < 0) {\n            throw ProtocolException.negativeLength(\"Effects\", effectsCount);\n         }\n\n         if (effectsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Effects\", effectsCount, 4096000);\n         }\n\n         pos += VarInt.size(effectsCount);\n         obj.effects = new HashMap<>(effectsCount);\n\n         for (int i = 0; i < effectsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            ReverbEffect val = ReverbEffect.deserialize(buf, pos);\n            pos += ReverbEffect.computeBytesConsumed(buf, pos);\n            if (obj.effects.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"effects\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += ReverbEffect.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int effectsCount = VarInt.peek(buffer, pos);\n            if (effectsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Effects\");\n            }\n\n            if (effectsCount > 4096000) {\n               return ValidationResult.error(\"Effects exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < effectsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ReverbEffect.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ReverbEffect.deserialize, ReverbEffect.computeBytesConsumed, obj.effects.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, ReverbEffect\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateEqualizerEffects",
        "packetId": 82,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "effects",
            "type": "Map<Integer, EqualizerEffect>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateEqualizerEffects\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 82;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, EqualizerEffect> effects;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateEqualizerEffects deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEqualizerEffects obj = new UpdateEqualizerEffects();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int effectsCount = VarInt.peek(buf, pos);\n         if (effectsCount < 0) {\n            throw ProtocolException.negativeLength(\"Effects\", effectsCount);\n         }\n\n         if (effectsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Effects\", effectsCount, 4096000);\n         }\n\n         pos += VarInt.size(effectsCount);\n         obj.effects = new HashMap<>(effectsCount);\n\n         for (int i = 0; i < effectsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            EqualizerEffect val = EqualizerEffect.deserialize(buf, pos);\n            pos += EqualizerEffect.computeBytesConsumed(buf, pos);\n            if (obj.effects.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"effects\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateEqualizerEffects deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEqualizerEffects obj = new UpdateEqualizerEffects();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int effectsCount = VarInt.peek(buf, pos);\n         if (effectsCount < 0) {\n            throw ProtocolException.negativeLength(\"Effects\", effectsCount);\n         }\n\n         if (effectsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Effects\", effectsCount, 4096000);\n         }\n\n         pos += VarInt.size(effectsCount);\n         obj.effects = new HashMap<>(effectsCount);\n\n         for (int i = 0; i < effectsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            EqualizerEffect val = EqualizerEffect.deserialize(buf, pos);\n            pos += EqualizerEffect.computeBytesConsumed(buf, pos);\n            if (obj.effects.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"effects\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += EqualizerEffect.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int effectsCount = VarInt.peek(buffer, pos);\n            if (effectsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Effects\");\n            }\n\n            if (effectsCount > 4096000) {\n               return ValidationResult.error(\"Effects exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < effectsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += EqualizerEffect.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, EqualizerEffect.deserialize, EqualizerEffect.computeBytesConsumed, obj.effects.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, EqualizerEffect\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateFluids",
        "packetId": 83,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "fluids",
            "type": "Map<Integer, Fluid>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateFluids\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 83;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, Fluid> fluids;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateFluids deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateFluids obj = new UpdateFluids();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int fluidsCount = VarInt.peek(buf, pos);\n         if (fluidsCount < 0) {\n            throw ProtocolException.negativeLength(\"Fluids\", fluidsCount);\n         }\n\n         if (fluidsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Fluids\", fluidsCount, 4096000);\n         }\n\n         pos += VarInt.size(fluidsCount);\n         obj.fluids = new HashMap<>(fluidsCount);\n\n         for (int i = 0; i < fluidsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            Fluid val = Fluid.deserialize(buf, pos);\n            pos += Fluid.computeBytesConsumed(buf, pos);\n            if (obj.fluids.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"fluids\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateFluids deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateFluids obj = new UpdateFluids();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int fluidsCount = VarInt.peek(buf, pos);\n         if (fluidsCount < 0) {\n            throw ProtocolException.negativeLength(\"Fluids\", fluidsCount);\n         }\n\n         if (fluidsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Fluids\", fluidsCount, 4096000);\n         }\n\n         pos += VarInt.size(fluidsCount);\n         obj.fluids = new HashMap<>(fluidsCount);\n\n         for (int i = 0; i < fluidsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            Fluid val = Fluid.deserialize(buf, pos);\n            pos += Fluid.computeBytesConsumed(buf, pos);\n            if (obj.fluids.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"fluids\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += Fluid.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int fluidsCount = VarInt.peek(buffer, pos);\n            if (fluidsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Fluids\");\n            }\n\n            if (fluidsCount > 4096000) {\n               return ValidationResult.error(\"Fluids exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < fluidsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += Fluid.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, Fluid.deserialize, Fluid.computeBytesConsumed, obj.fluids.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, Fluid\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateTagPatterns",
        "packetId": 84,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "maxId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "patterns",
            "type": "Map<Integer, TagPattern>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateTagPatterns\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 84;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nonnull int maxId;\n@Nullable Map<Integer, TagPattern> patterns;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateTagPatterns deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateTagPatterns obj = new UpdateTagPatterns();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int patternsCount = VarInt.peek(buf, pos);\n         if (patternsCount < 0) {\n            throw ProtocolException.negativeLength(\"Patterns\", patternsCount);\n         }\n\n         if (patternsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Patterns\", patternsCount, 4096000);\n         }\n\n         pos += VarInt.size(patternsCount);\n         obj.patterns = new HashMap<>(patternsCount);\n\n         for (int i = 0; i < patternsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            TagPattern val = TagPattern.deserialize(buf, pos);\n            pos += TagPattern.computeBytesConsumed(buf, pos);\n            if (obj.patterns.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"patterns\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateTagPatterns deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateTagPatterns obj = new UpdateTagPatterns();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      obj.maxId = buf.getIntLE(offset + 2);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int patternsCount = VarInt.peek(buf, pos);\n         if (patternsCount < 0) {\n            throw ProtocolException.negativeLength(\"Patterns\", patternsCount);\n         }\n\n         if (patternsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Patterns\", patternsCount, 4096000);\n         }\n\n         pos += VarInt.size(patternsCount);\n         obj.patterns = new HashMap<>(patternsCount);\n\n         for (int i = 0; i < patternsCount; i++) {\n            int key = buf.getIntLE(pos);\n            pos += 4;\n            TagPattern val = TagPattern.deserialize(buf, pos);\n            pos += TagPattern.computeBytesConsumed(buf, pos);\n            if (obj.patterns.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"patterns\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 4;\n            pos += TagPattern.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 1) != 0) {\n            int patternsCount = VarInt.peek(buffer, pos);\n            if (patternsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Patterns\");\n            }\n\n            if (patternsCount > 4096000) {\n               return ValidationResult.error(\"Patterns exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < patternsCount; i++) {\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += TagPattern.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, TagPattern.deserialize, TagPattern.computeBytesConsumed, obj.patterns.put, ProtocolException.duplicateKey\n// Types referenced: UpdateType, TagPattern\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateProjectileConfigs",
        "packetId": 85,
        "package": "com.hypixel.hytale.protocol.packets.assets",
        "fields": [
          {
            "name": "type",
            "type": "UpdateType",
            "nullable": false
          },
          {
            "name": "configs",
            "type": "Map<String, ProjectileConfig>",
            "nullable": true
          },
          {
            "name": "removedConfigs",
            "type": "String[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateProjectileConfigs\n// Package: com.hypixel.hytale.protocol.packets.assets\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 85;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 10;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull UpdateType type;\n@Nullable Map<String, ProjectileConfig> configs;\n@Nullable String[] removedConfigs;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateProjectileConfigs deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateProjectileConfigs obj = new UpdateProjectileConfigs();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 10 + buf.getIntLE(offset + 2);\n         int configsCount = VarInt.peek(buf, varPos0);\n         if (configsCount < 0) {\n            throw ProtocolException.negativeLength(\"Configs\", configsCount);\n         }\n\n         if (configsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Configs\", configsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         obj.configs = new HashMap<>(configsCount);\n         int dictPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < configsCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            ProjectileConfig val = ProjectileConfig.deserialize(buf, dictPos);\n            dictPos += ProjectileConfig.computeBytesConsumed(buf, dictPos);\n            if (obj.configs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"configs\", key);\n            }\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 10 + buf.getIntLE(offset + 6);\n         int removedConfigsCount = VarInt.peek(buf, varPos1);\n         if (removedConfigsCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedConfigs\", removedConfigsCount);\n         }\n\n         if (removedConfigsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedConfigs\", removedConfigsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)removedConfigsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedConfigs\", varPos1 + varIntLen + removedConfigsCount * 1, buf.readableBytes());\n         }\n\n         obj.removedConfigs = new String[removedConfigsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < removedConfigsCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedConfigs[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedConfigs[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedConfigs[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateProjectileConfigs deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateProjectileConfigs obj = new UpdateProjectileConfigs();\n      byte nullBits = buf.getByte(offset);\n      obj.type = UpdateType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 10 + buf.getIntLE(offset + 2);\n         int configsCount = VarInt.peek(buf, varPos0);\n         if (configsCount < 0) {\n            throw ProtocolException.negativeLength(\"Configs\", configsCount);\n         }\n\n         if (configsCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Configs\", configsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         obj.configs = new HashMap<>(configsCount);\n         int dictPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < configsCount; i++) {\n            int keyLen = VarInt.peek(buf, dictPos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, dictPos);\n            String key = PacketIO.readVarString(buf, dictPos);\n            dictPos += keyVarLen + keyLen;\n            ProjectileConfig val = ProjectileConfig.deserialize(buf, dictPos);\n            dictPos += ProjectileConfig.computeBytesConsumed(buf, dictPos);\n            if (obj.configs.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"configs\", key);\n            }\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 10 + buf.getIntLE(offset + 6);\n         int removedConfigsCount = VarInt.peek(buf, varPos1);\n         if (removedConfigsCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedConfigs\", removedConfigsCount);\n         }\n\n         if (removedConfigsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedConfigs\", removedConfigsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)removedConfigsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedConfigs\", varPos1 + varIntLen + removedConfigsCount * 1, buf.readableBytes());\n         }\n\n         obj.removedConfigs = new String[removedConfigsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < removedConfigsCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedConfigs[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedConfigs[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedConfigs[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 10;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 2);\n         int pos0 = offset + 10 + fieldOffset0;\n         int dictLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos0);\n            pos0 += VarInt.length(buf, pos0) + sl;\n            pos0 += ProjectileConfig.computeBytesConsumed(buf, pos0);\n         }\n\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 6);\n         int pos1 = offset + 10 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos1);\n            pos1 += VarInt.length(buf, pos1) + sl;\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 10) {\n         return ValidationResult.error(\"Buffer too small: expected at least 10 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int configsOffset = buffer.getIntLE(offset + 2);\n            if (configsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Configs\");\n            }\n\n            int pos = offset + 10 + configsOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Configs\");\n            }\n\n            int configsCount = VarInt.peek(buffer, pos);\n            if (configsCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Configs\");\n            }\n\n            if (configsCount > 4096000) {\n               return ValidationResult.error(\"Configs exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < configsCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += ProjectileConfig.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int removedConfigsOffset = buffer.getIntLE(offset + 6);\n            if (removedConfigsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for RemovedConfigs\");\n            }\n\n            int posx = offset + 10 + removedConfigsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for RemovedConfigs\");\n            }\n\n            int removedConfigsCount = VarInt.peek(buffer, posx);\n            if (removedConfigsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for RemovedConfigs\");\n            }\n\n            if (removedConfigsCount > 4096000) {\n               return ValidationResult.error(\"RemovedConfigs exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < removedConfigsCount; i++) {\n               int strLen = VarInt.peek(buffer, posx);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in RemovedConfigs\");\n               }\n\n               posx += VarInt.length(buffer, posx);\n               posx += strLen;\n               if (posx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in RemovedConfigs\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, UpdateType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.length, ProtocolException.stringTooLong, PacketIO.readVarString, ProjectileConfig.deserialize, ProjectileConfig.computeBytesConsumed, obj.configs.put, ProtocolException.duplicateKey, ProtocolException.arrayTooLong, buf.readableBytes, ProtocolException.bufferTooSmall\n// Types referenced: UpdateType, ProjectileConfig\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "entities": [
      {
        "name": "SetEntitySeed",
        "packetId": 160,
        "package": "com.hypixel.hytale.protocol.packets.entities",
        "fields": [
          {
            "name": "entitySeed",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetEntitySeed\n// Package: com.hypixel.hytale.protocol.packets.entities\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 160;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int entitySeed;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetEntitySeed deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetEntitySeed obj = new SetEntitySeed();\n      obj.entitySeed = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "EntityUpdates",
        "packetId": 161,
        "package": "com.hypixel.hytale.protocol.packets.entities",
        "fields": [
          {
            "name": "removed",
            "type": "int[]",
            "nullable": true
          },
          {
            "name": "updates",
            "type": "EntityUpdate[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: EntityUpdates\n// Package: com.hypixel.hytale.protocol.packets.entities\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 161;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable int[] removed;\n@Nullable EntityUpdate[] updates;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static EntityUpdates deserialize(@Nonnull ByteBuf buf, int offset) {\n      EntityUpdates obj = new EntityUpdates();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int removedCount = VarInt.peek(buf, varPos0);\n         if (removedCount < 0) {\n            throw ProtocolException.negativeLength(\"Removed\", removedCount);\n         }\n\n         if (removedCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Removed\", removedCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)removedCount * 4L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Removed\", varPos0 + varIntLen + removedCount * 4, buf.readableBytes());\n         }\n\n         obj.removed = new int[removedCount];\n\n         for (int i = 0; i < removedCount; i++) {\n            obj.removed[i] = buf.getIntLE(varPos0 + varIntLen + i * 4);\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int updatesCount = VarInt.peek(buf, varPos1);\n         if (updatesCount < 0) {\n            throw ProtocolException.negativeLength(\"Updates\", updatesCount);\n         }\n\n         if (updatesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Updates\", updatesCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)updatesCount * 5L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Updates\", varPos1 + varIntLen + updatesCount * 5, buf.readableBytes());\n         }\n\n         obj.updates = new EntityUpdate[updatesCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < updatesCount; i++) {\n            obj.updates[i] = EntityUpdate.deserialize(buf, elemPos);\n            elemPos += EntityUpdate.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static EntityUpdates deserialize(@Nonnull ByteBuf buf, int offset) {\n      EntityUpdates obj = new EntityUpdates();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int removedCount = VarInt.peek(buf, varPos0);\n         if (removedCount < 0) {\n            throw ProtocolException.negativeLength(\"Removed\", removedCount);\n         }\n\n         if (removedCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Removed\", removedCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)removedCount * 4L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Removed\", varPos0 + varIntLen + removedCount * 4, buf.readableBytes());\n         }\n\n         obj.removed = new int[removedCount];\n\n         for (int i = 0; i < removedCount; i++) {\n            obj.removed[i] = buf.getIntLE(varPos0 + varIntLen + i * 4);\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int updatesCount = VarInt.peek(buf, varPos1);\n         if (updatesCount < 0) {\n            throw ProtocolException.negativeLength(\"Updates\", updatesCount);\n         }\n\n         if (updatesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Updates\", updatesCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)updatesCount * 5L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Updates\", varPos1 + varIntLen + updatesCount * 5, buf.readableBytes());\n         }\n\n         obj.updates = new EntityUpdate[updatesCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < updatesCount; i++) {\n            obj.updates[i] = EntityUpdate.deserialize(buf, elemPos);\n            elemPos += EntityUpdate.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         int arrLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + arrLen * 4;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos1 += EntityUpdate.computeBytesConsumed(buf, pos1);\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int removedOffset = buffer.getIntLE(offset + 1);\n            if (removedOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Removed\");\n            }\n\n            int pos = offset + 9 + removedOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Removed\");\n            }\n\n            int removedCount = VarInt.peek(buffer, pos);\n            if (removedCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Removed\");\n            }\n\n            if (removedCount > 4096000) {\n               return ValidationResult.error(\"Removed exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += removedCount * 4;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Removed\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int updatesOffset = buffer.getIntLE(offset + 5);\n            if (updatesOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Updates\");\n            }\n\n            int posx = offset + 9 + updatesOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Updates\");\n            }\n\n            int updatesCount = VarInt.peek(buffer, posx);\n            if (updatesCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Updates\");\n            }\n\n            if (updatesCount > 4096000) {\n               return ValidationResult.error(\"Updates exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < updatesCount; i++) {\n               ValidationResult structResult = EntityUpdate.validateStructure(buffer, posx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid EntityUpdate in Updates[\" + i + \"]: \" + structResult.error());\n               }\n\n               posx += EntityUpdate.computeBytesConsumed(buffer, posx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, EntityUpdate.deserialize, EntityUpdate.computeBytesConsumed\n// Types referenced: EntityUpdate\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PlayAnimation",
        "packetId": 162,
        "package": "com.hypixel.hytale.protocol.packets.entities",
        "fields": [
          {
            "name": "entityId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "itemAnimationsId",
            "type": "String",
            "nullable": true
          },
          {
            "name": "animationId",
            "type": "String",
            "nullable": true
          },
          {
            "name": "slot",
            "type": "AnimationSlot",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: PlayAnimation\n// Package: com.hypixel.hytale.protocol.packets.entities\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 162;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 14;\npublic static final int MAX_SIZE = 32768024;\n\n// === FIELDS ===\n@Nonnull int entityId;\n@Nullable String itemAnimationsId;\n@Nullable String animationId;\n@Nonnull AnimationSlot slot;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PlayAnimation deserialize(@Nonnull ByteBuf buf, int offset) {\n      PlayAnimation obj = new PlayAnimation();\n      byte nullBits = buf.getByte(offset);\n      obj.entityId = buf.getIntLE(offset + 1);\n      obj.slot = AnimationSlot.fromValue(buf.getByte(offset + 5));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 14 + buf.getIntLE(offset + 6);\n         int itemAnimationsIdLen = VarInt.peek(buf, varPos0);\n         if (itemAnimationsIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ItemAnimationsId\", itemAnimationsIdLen);\n         }\n\n         if (itemAnimationsIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ItemAnimationsId\", itemAnimationsIdLen, 4096000);\n         }\n\n         obj.itemAnimationsId = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 14 + buf.getIntLE(offset + 10);\n         int animationIdLen = VarInt.peek(buf, varPos1);\n         if (animationIdLen < 0) {\n            throw ProtocolException.negativeLength(\"AnimationId\", animationIdLen);\n         }\n\n         if (animationIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"AnimationId\", animationIdLen, 4096000);\n         }\n\n         obj.animationId = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 14;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 6);\n         int pos0 = offset + 14 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 10);\n         int pos1 = offset + 14 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 14) {\n         return ValidationResult.error(\"Buffer too small: expected at least 14 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int itemAnimationsIdOffset = buffer.getIntLE(offset + 6);\n            if (itemAnimationsIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ItemAnimationsId\");\n            }\n\n            int pos = offset + 14 + itemAnimationsIdOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ItemAnimationsId\");\n            }\n\n            int itemAnimationsIdLen = VarInt.peek(buffer, pos);\n            if (itemAnimationsIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ItemAnimationsId\");\n            }\n\n            if (itemAnimationsIdLen > 4096000) {\n               return ValidationResult.error(\"ItemAnimationsId exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += itemAnimationsIdLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ItemAnimationsId\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int animationIdOffset = buffer.getIntLE(offset + 10);\n            if (animationIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for AnimationId\");\n            }\n\n            int posx = offset + 14 + animationIdOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for AnimationId\");\n            }\n\n            int animationIdLen = VarInt.peek(buffer, posx);\n            if (animationIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for AnimationId\");\n            }\n\n            if (animationIdLen > 4096000) {\n               return ValidationResult.error(\"AnimationId exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += animationIdLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading AnimationId\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, AnimationSlot.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: AnimationSlot\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ChangeVelocity",
        "packetId": 163,
        "package": "com.hypixel.hytale.protocol.packets.entities",
        "fields": [
          {
            "name": "x",
            "type": "float",
            "nullable": false
          },
          {
            "name": "y",
            "type": "float",
            "nullable": false
          },
          {
            "name": "z",
            "type": "float",
            "nullable": false
          },
          {
            "name": "changeType",
            "type": "ChangeVelocityType",
            "nullable": false
          },
          {
            "name": "config",
            "type": "VelocityConfig",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: ChangeVelocity\n// Package: com.hypixel.hytale.protocol.packets.entities\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 163;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 35;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 35;\npublic static final int MAX_SIZE = 35;\n\n// === FIELDS ===\n@Nonnull float x;\n@Nonnull float y;\n@Nonnull float z;\n@Nonnull ChangeVelocityType changeType;\n@Nullable VelocityConfig config;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ChangeVelocity deserialize(@Nonnull ByteBuf buf, int offset) {\n      ChangeVelocity obj = new ChangeVelocity();\n      byte nullBits = buf.getByte(offset);\n      obj.x = buf.getFloatLE(offset + 1);\n      obj.y = buf.getFloatLE(offset + 5);\n      obj.z = buf.getFloatLE(offset + 9);\n      obj.changeType = ChangeVelocityType.fromValue(buf.getByte(offset + 13));\n      if ((nullBits & 1) != 0) {\n         obj.config = VelocityConfig.deserialize(buf, offset + 14);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static ChangeVelocity deserialize(@Nonnull ByteBuf buf, int offset) {\n      ChangeVelocity obj = new ChangeVelocity();\n      byte nullBits = buf.getByte(offset);\n      obj.x = buf.getFloatLE(offset + 1);\n      obj.y = buf.getFloatLE(offset + 5);\n      obj.z = buf.getFloatLE(offset + 9);\n      obj.changeType = ChangeVelocityType.fromValue(buf.getByte(offset + 13));\n      if ((nullBits & 1) != 0) {\n         obj.config = VelocityConfig.deserialize(buf, offset + 14);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 35;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 35 ? ValidationResult.error(\"Buffer too small: expected at least 35 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getFloatLE, ChangeVelocityType.fromValue, VelocityConfig.deserialize\n// Types referenced: ChangeVelocityType, VelocityConfig\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ApplyKnockback",
        "packetId": 164,
        "package": "com.hypixel.hytale.protocol.packets.entities",
        "fields": [
          {
            "name": "hitPosition",
            "type": "Position",
            "nullable": true
          },
          {
            "name": "x",
            "type": "float",
            "nullable": false
          },
          {
            "name": "y",
            "type": "float",
            "nullable": false
          },
          {
            "name": "z",
            "type": "float",
            "nullable": false
          },
          {
            "name": "changeType",
            "type": "ChangeVelocityType",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ApplyKnockback\n// Package: com.hypixel.hytale.protocol.packets.entities\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 164;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 38;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 38;\npublic static final int MAX_SIZE = 38;\n\n// === FIELDS ===\n@Nullable Position hitPosition;\n@Nonnull float x;\n@Nonnull float y;\n@Nonnull float z;\n@Nonnull ChangeVelocityType changeType;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ApplyKnockback deserialize(@Nonnull ByteBuf buf, int offset) {\n      ApplyKnockback obj = new ApplyKnockback();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.hitPosition = Position.deserialize(buf, offset + 1);\n      }\n\n      obj.x = buf.getFloatLE(offset + 25);\n      obj.y = buf.getFloatLE(offset + 29);\n      obj.z = buf.getFloatLE(offset + 33);\n      obj.changeType = ChangeVelocityType.fromValue(buf.getByte(offset + 37));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static ApplyKnockback deserialize(@Nonnull ByteBuf buf, int offset) {\n      ApplyKnockback obj = new ApplyKnockback();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.hitPosition = Position.deserialize(buf, offset + 1);\n      }\n\n      obj.x = buf.getFloatLE(offset + 25);\n      obj.y = buf.getFloatLE(offset + 29);\n      obj.z = buf.getFloatLE(offset + 33);\n      obj.changeType = ChangeVelocityType.fromValue(buf.getByte(offset + 37));\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 38;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 38 ? ValidationResult.error(\"Buffer too small: expected at least 38 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, Position.deserialize, buf.getFloatLE, ChangeVelocityType.fromValue\n// Types referenced: Position, ChangeVelocityType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SpawnModelParticles",
        "packetId": 165,
        "package": "com.hypixel.hytale.protocol.packets.entities",
        "fields": [
          {
            "name": "entityId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "modelParticles",
            "type": "ModelParticle[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SpawnModelParticles\n// Package: com.hypixel.hytale.protocol.packets.entities\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 165;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int entityId;\n@Nullable ModelParticle[] modelParticles;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SpawnModelParticles deserialize(@Nonnull ByteBuf buf, int offset) {\n      SpawnModelParticles obj = new SpawnModelParticles();\n      byte nullBits = buf.getByte(offset);\n      obj.entityId = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int modelParticlesCount = VarInt.peek(buf, pos);\n         if (modelParticlesCount < 0) {\n            throw ProtocolException.negativeLength(\"ModelParticles\", modelParticlesCount);\n         }\n\n         if (modelParticlesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"ModelParticles\", modelParticlesCount, 4096000);\n         }\n\n         int modelParticlesVarLen = VarInt.size(modelParticlesCount);\n         if ((long)(pos + modelParticlesVarLen) + (long)modelParticlesCount * 34L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"ModelParticles\", pos + modelParticlesVarLen + modelParticlesCount * 34, buf.readableBytes());\n         }\n\n         pos += modelParticlesVarLen;\n         obj.modelParticles = new ModelParticle[modelParticlesCount];\n\n         for (int i = 0; i < modelParticlesCount; i++) {\n            obj.modelParticles[i] = ModelParticle.deserialize(buf, pos);\n            pos += ModelParticle.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SpawnModelParticles deserialize(@Nonnull ByteBuf buf, int offset) {\n      SpawnModelParticles obj = new SpawnModelParticles();\n      byte nullBits = buf.getByte(offset);\n      obj.entityId = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int modelParticlesCount = VarInt.peek(buf, pos);\n         if (modelParticlesCount < 0) {\n            throw ProtocolException.negativeLength(\"ModelParticles\", modelParticlesCount);\n         }\n\n         if (modelParticlesCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"ModelParticles\", modelParticlesCount, 4096000);\n         }\n\n         int modelParticlesVarLen = VarInt.size(modelParticlesCount);\n         if ((long)(pos + modelParticlesVarLen) + (long)modelParticlesCount * 34L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"ModelParticles\", pos + modelParticlesVarLen + modelParticlesCount * 34, buf.readableBytes());\n         }\n\n         pos += modelParticlesVarLen;\n         obj.modelParticles = new ModelParticle[modelParticlesCount];\n\n         for (int i = 0; i < modelParticlesCount; i++) {\n            obj.modelParticles[i] = ModelParticle.deserialize(buf, pos);\n            pos += ModelParticle.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += ModelParticle.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            int modelParticlesCount = VarInt.peek(buffer, pos);\n            if (modelParticlesCount < 0) {\n               return ValidationResult.error(\"Invalid array count for ModelParticles\");\n            }\n\n            if (modelParticlesCount > 4096000) {\n               return ValidationResult.error(\"ModelParticles exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < modelParticlesCount; i++) {\n               ValidationResult structResult = ModelParticle.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid ModelParticle in ModelParticles[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += ModelParticle.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, ModelParticle.deserialize, ModelParticle.computeBytesConsumed\n// Types referenced: ModelParticle\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "MountMovement",
        "packetId": 166,
        "package": "com.hypixel.hytale.protocol.packets.entities",
        "fields": [
          {
            "name": "absolutePosition",
            "type": "Position",
            "nullable": true
          },
          {
            "name": "bodyOrientation",
            "type": "Direction",
            "nullable": true
          },
          {
            "name": "movementStates",
            "type": "MovementStates",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: MountMovement\n// Package: com.hypixel.hytale.protocol.packets.entities\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 166;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 59;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 59;\npublic static final int MAX_SIZE = 59;\n\n// === FIELDS ===\n@Nullable Position absolutePosition;\n@Nullable Direction bodyOrientation;\n@Nullable MovementStates movementStates;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static MountMovement deserialize(@Nonnull ByteBuf buf, int offset) {\n      MountMovement obj = new MountMovement();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.absolutePosition = Position.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 2) != 0) {\n         obj.bodyOrientation = Direction.deserialize(buf, offset + 25);\n      }\n\n      if ((nullBits & 4) != 0) {\n         obj.movementStates = MovementStates.deserialize(buf, offset + 37);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static MountMovement deserialize(@Nonnull ByteBuf buf, int offset) {\n      MountMovement obj = new MountMovement();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.absolutePosition = Position.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 2) != 0) {\n         obj.bodyOrientation = Direction.deserialize(buf, offset + 25);\n      }\n\n      if ((nullBits & 4) != 0) {\n         obj.movementStates = MovementStates.deserialize(buf, offset + 37);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 59;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 59 ? ValidationResult.error(\"Buffer too small: expected at least 59 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, Position.deserialize, Direction.deserialize, MovementStates.deserialize\n// Types referenced: Position, Direction, MovementStates\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "auth": [
      {
        "name": "Status",
        "packetId": 10,
        "package": "com.hypixel.hytale.protocol.packets.auth",
        "fields": [
          {
            "name": "name",
            "type": "String",
            "nullable": true
          },
          {
            "name": "motd",
            "type": "String",
            "nullable": true
          },
          {
            "name": "playerCount",
            "type": "int",
            "nullable": false
          },
          {
            "name": "maxPlayers",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: Status\n// Package: com.hypixel.hytale.protocol.packets.auth\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 10;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 17;\npublic static final int MAX_SIZE = 2587;\n\n// === FIELDS ===\n@Nullable String name;\n@Nullable String motd;\n@Nonnull int playerCount;\n@Nonnull int maxPlayers;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static Status deserialize(@Nonnull ByteBuf buf, int offset) {\n      Status obj = new Status();\n      byte nullBits = buf.getByte(offset);\n      obj.playerCount = buf.getIntLE(offset + 1);\n      obj.maxPlayers = buf.getIntLE(offset + 5);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 17 + buf.getIntLE(offset + 9);\n         int nameLen = VarInt.peek(buf, varPos0);\n         if (nameLen < 0) {\n            throw ProtocolException.negativeLength(\"Name\", nameLen);\n         }\n\n         if (nameLen > 128) {\n            throw ProtocolException.stringTooLong(\"Name\", nameLen, 128);\n         }\n\n         obj.name = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 17 + buf.getIntLE(offset + 13);\n         int motdLen = VarInt.peek(buf, varPos1);\n         if (motdLen < 0) {\n            throw ProtocolException.negativeLength(\"Motd\", motdLen);\n         }\n\n         if (motdLen > 512) {\n            throw ProtocolException.stringTooLong(\"Motd\", motdLen, 512);\n         }\n\n         obj.motd = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 17;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 9);\n         int pos0 = offset + 17 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 13);\n         int pos1 = offset + 17 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 17) {\n         return ValidationResult.error(\"Buffer too small: expected at least 17 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int nameOffset = buffer.getIntLE(offset + 9);\n            if (nameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Name\");\n            }\n\n            int pos = offset + 17 + nameOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Name\");\n            }\n\n            int nameLen = VarInt.peek(buffer, pos);\n            if (nameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Name\");\n            }\n\n            if (nameLen > 128) {\n               return ValidationResult.error(\"Name exceeds max length 128\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += nameLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Name\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int motdOffset = buffer.getIntLE(offset + 13);\n            if (motdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Motd\");\n            }\n\n            int posx = offset + 17 + motdOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Motd\");\n            }\n\n            int motdLen = VarInt.peek(buffer, posx);\n            if (motdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Motd\");\n            }\n\n            if (motdLen > 512) {\n               return ValidationResult.error(\"Motd exceeds max length 512\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += motdLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Motd\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AuthGrant",
        "packetId": 11,
        "package": "com.hypixel.hytale.protocol.packets.auth",
        "fields": [
          {
            "name": "authorizationGrant",
            "type": "String",
            "nullable": true
          },
          {
            "name": "serverIdentityToken",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AuthGrant\n// Package: com.hypixel.hytale.protocol.packets.auth\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 11;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 49171;\n\n// === FIELDS ===\n@Nullable String authorizationGrant;\n@Nullable String serverIdentityToken;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AuthGrant deserialize(@Nonnull ByteBuf buf, int offset) {\n      AuthGrant obj = new AuthGrant();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int authorizationGrantLen = VarInt.peek(buf, varPos0);\n         if (authorizationGrantLen < 0) {\n            throw ProtocolException.negativeLength(\"AuthorizationGrant\", authorizationGrantLen);\n         }\n\n         if (authorizationGrantLen > 4096) {\n            throw ProtocolException.stringTooLong(\"AuthorizationGrant\", authorizationGrantLen, 4096);\n         }\n\n         obj.authorizationGrant = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int serverIdentityTokenLen = VarInt.peek(buf, varPos1);\n         if (serverIdentityTokenLen < 0) {\n            throw ProtocolException.negativeLength(\"ServerIdentityToken\", serverIdentityTokenLen);\n         }\n\n         if (serverIdentityTokenLen > 8192) {\n            throw ProtocolException.stringTooLong(\"ServerIdentityToken\", serverIdentityTokenLen, 8192);\n         }\n\n         obj.serverIdentityToken = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int authorizationGrantOffset = buffer.getIntLE(offset + 1);\n            if (authorizationGrantOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for AuthorizationGrant\");\n            }\n\n            int pos = offset + 9 + authorizationGrantOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for AuthorizationGrant\");\n            }\n\n            int authorizationGrantLen = VarInt.peek(buffer, pos);\n            if (authorizationGrantLen < 0) {\n               return ValidationResult.error(\"Invalid string length for AuthorizationGrant\");\n            }\n\n            if (authorizationGrantLen > 4096) {\n               return ValidationResult.error(\"AuthorizationGrant exceeds max length 4096\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += authorizationGrantLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading AuthorizationGrant\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int serverIdentityTokenOffset = buffer.getIntLE(offset + 5);\n            if (serverIdentityTokenOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ServerIdentityToken\");\n            }\n\n            int posx = offset + 9 + serverIdentityTokenOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ServerIdentityToken\");\n            }\n\n            int serverIdentityTokenLen = VarInt.peek(buffer, posx);\n            if (serverIdentityTokenLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ServerIdentityToken\");\n            }\n\n            if (serverIdentityTokenLen > 8192) {\n               return ValidationResult.error(\"ServerIdentityToken exceeds max length 8192\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += serverIdentityTokenLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ServerIdentityToken\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AuthToken",
        "packetId": 12,
        "package": "com.hypixel.hytale.protocol.packets.auth",
        "fields": [
          {
            "name": "accessToken",
            "type": "String",
            "nullable": true
          },
          {
            "name": "serverAuthorizationGrant",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AuthToken\n// Package: com.hypixel.hytale.protocol.packets.auth\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 12;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 49171;\n\n// === FIELDS ===\n@Nullable String accessToken;\n@Nullable String serverAuthorizationGrant;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AuthToken deserialize(@Nonnull ByteBuf buf, int offset) {\n      AuthToken obj = new AuthToken();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int accessTokenLen = VarInt.peek(buf, varPos0);\n         if (accessTokenLen < 0) {\n            throw ProtocolException.negativeLength(\"AccessToken\", accessTokenLen);\n         }\n\n         if (accessTokenLen > 8192) {\n            throw ProtocolException.stringTooLong(\"AccessToken\", accessTokenLen, 8192);\n         }\n\n         obj.accessToken = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int serverAuthorizationGrantLen = VarInt.peek(buf, varPos1);\n         if (serverAuthorizationGrantLen < 0) {\n            throw ProtocolException.negativeLength(\"ServerAuthorizationGrant\", serverAuthorizationGrantLen);\n         }\n\n         if (serverAuthorizationGrantLen > 4096) {\n            throw ProtocolException.stringTooLong(\"ServerAuthorizationGrant\", serverAuthorizationGrantLen, 4096);\n         }\n\n         obj.serverAuthorizationGrant = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int accessTokenOffset = buffer.getIntLE(offset + 1);\n            if (accessTokenOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for AccessToken\");\n            }\n\n            int pos = offset + 9 + accessTokenOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for AccessToken\");\n            }\n\n            int accessTokenLen = VarInt.peek(buffer, pos);\n            if (accessTokenLen < 0) {\n               return ValidationResult.error(\"Invalid string length for AccessToken\");\n            }\n\n            if (accessTokenLen > 8192) {\n               return ValidationResult.error(\"AccessToken exceeds max length 8192\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += accessTokenLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading AccessToken\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int serverAuthorizationGrantOffset = buffer.getIntLE(offset + 5);\n            if (serverAuthorizationGrantOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ServerAuthorizationGrant\");\n            }\n\n            int posx = offset + 9 + serverAuthorizationGrantOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ServerAuthorizationGrant\");\n            }\n\n            int serverAuthorizationGrantLen = VarInt.peek(buffer, posx);\n            if (serverAuthorizationGrantLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ServerAuthorizationGrant\");\n            }\n\n            if (serverAuthorizationGrantLen > 4096) {\n               return ValidationResult.error(\"ServerAuthorizationGrant exceeds max length 4096\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += serverAuthorizationGrantLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ServerAuthorizationGrant\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerAuthToken",
        "packetId": 13,
        "package": "com.hypixel.hytale.protocol.packets.auth",
        "fields": [
          {
            "name": "serverAccessToken",
            "type": "String",
            "nullable": true
          },
          {
            "name": "passwordChallenge",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: ServerAuthToken\n// Package: com.hypixel.hytale.protocol.packets.auth\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 13;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 32851;\n\n// === FIELDS ===\n@Nullable String serverAccessToken;\n@Nullable byte[] passwordChallenge;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerAuthToken deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerAuthToken obj = new ServerAuthToken();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         int serverAccessTokenLen = VarInt.peek(buf, varPos0);\n         if (serverAccessTokenLen < 0) {\n            throw ProtocolException.negativeLength(\"ServerAccessToken\", serverAccessTokenLen);\n         }\n\n         if (serverAccessTokenLen > 8192) {\n            throw ProtocolException.stringTooLong(\"ServerAccessToken\", serverAccessTokenLen, 8192);\n         }\n\n         obj.serverAccessToken = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int passwordChallengeCount = VarInt.peek(buf, varPos1);\n         if (passwordChallengeCount < 0) {\n            throw ProtocolException.negativeLength(\"PasswordChallenge\", passwordChallengeCount);\n         }\n\n         if (passwordChallengeCount > 64) {\n            throw ProtocolException.arrayTooLong(\"PasswordChallenge\", passwordChallengeCount, 64);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)passwordChallengeCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"PasswordChallenge\", varPos1 + varIntLen + passwordChallengeCount * 1, buf.readableBytes());\n         }\n\n         obj.passwordChallenge = new byte[passwordChallengeCount];\n\n         for (int i = 0; i < passwordChallengeCount; i++) {\n            obj.passwordChallenge[i] = buf.getByte(varPos1 + varIntLen + i * 1);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + arrLen * 1;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int serverAccessTokenOffset = buffer.getIntLE(offset + 1);\n            if (serverAccessTokenOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ServerAccessToken\");\n            }\n\n            int pos = offset + 9 + serverAccessTokenOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ServerAccessToken\");\n            }\n\n            int serverAccessTokenLen = VarInt.peek(buffer, pos);\n            if (serverAccessTokenLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ServerAccessToken\");\n            }\n\n            if (serverAccessTokenLen > 8192) {\n               return ValidationResult.error(\"ServerAccessToken exceeds max length 8192\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += serverAccessTokenLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ServerAccessToken\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int passwordChallengeOffset = buffer.getIntLE(offset + 5);\n            if (passwordChallengeOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for PasswordChallenge\");\n            }\n\n            int posx = offset + 9 + passwordChallengeOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for PasswordChallenge\");\n            }\n\n            int passwordChallengeCount = VarInt.peek(buffer, posx);\n            if (passwordChallengeCount < 0) {\n               return ValidationResult.error(\"Invalid array count for PasswordChallenge\");\n            }\n\n            if (passwordChallengeCount > 64) {\n               return ValidationResult.error(\"PasswordChallenge exceeds max length 64\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += passwordChallengeCount * 1;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading PasswordChallenge\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ConnectAccept",
        "packetId": 14,
        "package": "com.hypixel.hytale.protocol.packets.auth",
        "fields": [
          {
            "name": "passwordChallenge",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: ConnectAccept\n// Package: com.hypixel.hytale.protocol.packets.auth\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 14;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 70;\n\n// === FIELDS ===\n@Nullable byte[] passwordChallenge;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ConnectAccept deserialize(@Nonnull ByteBuf buf, int offset) {\n      ConnectAccept obj = new ConnectAccept();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int passwordChallengeCount = VarInt.peek(buf, pos);\n         if (passwordChallengeCount < 0) {\n            throw ProtocolException.negativeLength(\"PasswordChallenge\", passwordChallengeCount);\n         }\n\n         if (passwordChallengeCount > 64) {\n            throw ProtocolException.arrayTooLong(\"PasswordChallenge\", passwordChallengeCount, 64);\n         }\n\n         int passwordChallengeVarLen = VarInt.size(passwordChallengeCount);\n         if ((long)(pos + passwordChallengeVarLen) + (long)passwordChallengeCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"PasswordChallenge\", pos + passwordChallengeVarLen + passwordChallengeCount * 1, buf.readableBytes());\n         }\n\n         pos += passwordChallengeVarLen;\n         obj.passwordChallenge = new byte[passwordChallengeCount];\n\n         for (int i = 0; i < passwordChallengeCount; i++) {\n            obj.passwordChallenge[i] = buf.getByte(pos + i * 1);\n         }\n\n         pos += passwordChallengeCount * 1;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int passwordChallengeCount = VarInt.peek(buffer, pos);\n            if (passwordChallengeCount < 0) {\n               return ValidationResult.error(\"Invalid array count for PasswordChallenge\");\n            }\n\n            if (passwordChallengeCount > 64) {\n               return ValidationResult.error(\"PasswordChallenge exceeds max length 64\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += passwordChallengeCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading PasswordChallenge\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PasswordResponse",
        "packetId": 15,
        "package": "com.hypixel.hytale.protocol.packets.auth",
        "fields": [
          {
            "name": "hash",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: PasswordResponse\n// Package: com.hypixel.hytale.protocol.packets.auth\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 15;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 70;\n\n// === FIELDS ===\n@Nullable byte[] hash;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PasswordResponse deserialize(@Nonnull ByteBuf buf, int offset) {\n      PasswordResponse obj = new PasswordResponse();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int hashCount = VarInt.peek(buf, pos);\n         if (hashCount < 0) {\n            throw ProtocolException.negativeLength(\"Hash\", hashCount);\n         }\n\n         if (hashCount > 64) {\n            throw ProtocolException.arrayTooLong(\"Hash\", hashCount, 64);\n         }\n\n         int hashVarLen = VarInt.size(hashCount);\n         if ((long)(pos + hashVarLen) + (long)hashCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Hash\", pos + hashVarLen + hashCount * 1, buf.readableBytes());\n         }\n\n         pos += hashVarLen;\n         obj.hash = new byte[hashCount];\n\n         for (int i = 0; i < hashCount; i++) {\n            obj.hash[i] = buf.getByte(pos + i * 1);\n         }\n\n         pos += hashCount * 1;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int hashCount = VarInt.peek(buffer, pos);\n            if (hashCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Hash\");\n            }\n\n            if (hashCount > 64) {\n               return ValidationResult.error(\"Hash exceeds max length 64\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += hashCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Hash\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PasswordAccepted",
        "packetId": 16,
        "package": "com.hypixel.hytale.protocol.packets.auth",
        "fields": [],
        "deserializeContext": "// Packet: PasswordAccepted\n// Package: com.hypixel.hytale.protocol.packets.auth\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 16;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PasswordAccepted deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new PasswordAccepted();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PasswordRejected",
        "packetId": 17,
        "package": "com.hypixel.hytale.protocol.packets.auth",
        "fields": [
          {
            "name": "newChallenge",
            "type": "byte[]",
            "nullable": true
          },
          {
            "name": "attemptsRemaining",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: PasswordRejected\n// Package: com.hypixel.hytale.protocol.packets.auth\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 17;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 74;\n\n// === FIELDS ===\n@Nullable byte[] newChallenge;\n@Nonnull int attemptsRemaining;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PasswordRejected deserialize(@Nonnull ByteBuf buf, int offset) {\n      PasswordRejected obj = new PasswordRejected();\n      byte nullBits = buf.getByte(offset);\n      obj.attemptsRemaining = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int newChallengeCount = VarInt.peek(buf, pos);\n         if (newChallengeCount < 0) {\n            throw ProtocolException.negativeLength(\"NewChallenge\", newChallengeCount);\n         }\n\n         if (newChallengeCount > 64) {\n            throw ProtocolException.arrayTooLong(\"NewChallenge\", newChallengeCount, 64);\n         }\n\n         int newChallengeVarLen = VarInt.size(newChallengeCount);\n         if ((long)(pos + newChallengeVarLen) + (long)newChallengeCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"NewChallenge\", pos + newChallengeVarLen + newChallengeCount * 1, buf.readableBytes());\n         }\n\n         pos += newChallengeVarLen;\n         obj.newChallenge = new byte[newChallengeCount];\n\n         for (int i = 0; i < newChallengeCount; i++) {\n            obj.newChallenge[i] = buf.getByte(pos + i * 1);\n         }\n\n         pos += newChallengeCount * 1;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            int newChallengeCount = VarInt.peek(buffer, pos);\n            if (newChallengeCount < 0) {\n               return ValidationResult.error(\"Invalid array count for NewChallenge\");\n            }\n\n            if (newChallengeCount > 64) {\n               return ValidationResult.error(\"NewChallenge exceeds max length 64\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += newChallengeCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading NewChallenge\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ClientReferral",
        "packetId": 18,
        "package": "com.hypixel.hytale.protocol.packets.auth",
        "fields": [
          {
            "name": "hostTo",
            "type": "HostAddress",
            "nullable": true
          },
          {
            "name": "data",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: ClientReferral\n// Package: com.hypixel.hytale.protocol.packets.auth\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 18;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 5141;\n\n// === FIELDS ===\n@Nullable HostAddress hostTo;\n@Nullable byte[] data;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ClientReferral deserialize(@Nonnull ByteBuf buf, int offset) {\n      ClientReferral obj = new ClientReferral();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         obj.hostTo = HostAddress.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int dataCount = VarInt.peek(buf, varPos1);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)dataCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", varPos1 + varIntLen + dataCount * 1, buf.readableBytes());\n         }\n\n         obj.data = new byte[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getByte(varPos1 + varIntLen + i * 1);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static ClientReferral deserialize(@Nonnull ByteBuf buf, int offset) {\n      ClientReferral obj = new ClientReferral();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 9 + buf.getIntLE(offset + 1);\n         obj.hostTo = HostAddress.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 9 + buf.getIntLE(offset + 5);\n         int dataCount = VarInt.peek(buf, varPos1);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)dataCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", varPos1 + varIntLen + dataCount * 1, buf.readableBytes());\n         }\n\n         obj.data = new byte[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getByte(varPos1 + varIntLen + i * 1);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 9;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 9 + fieldOffset0;\n         pos0 += HostAddress.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 9 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + arrLen * 1;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int hostToOffset = buffer.getIntLE(offset + 1);\n            if (hostToOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for HostTo\");\n            }\n\n            int pos = offset + 9 + hostToOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for HostTo\");\n            }\n\n            ValidationResult hostToResult = HostAddress.validateStructure(buffer, pos);\n            if (!hostToResult.isValid()) {\n               return ValidationResult.error(\"Invalid HostTo: \" + hostToResult.error());\n            }\n\n            pos += HostAddress.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int dataOffset = buffer.getIntLE(offset + 5);\n            if (dataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Data\");\n            }\n\n            int posx = offset + 9 + dataOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Data\");\n            }\n\n            int dataCount = VarInt.peek(buffer, posx);\n            if (dataCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Data\");\n            }\n\n            if (dataCount > 4096) {\n               return ValidationResult.error(\"Data exceeds max length 4096\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += dataCount * 1;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Data\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, HostAddress.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall\n// Types referenced: HostAddress\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "camera": [
      {
        "name": "SetServerCamera",
        "packetId": 280,
        "package": "com.hypixel.hytale.protocol.packets.camera",
        "fields": [
          {
            "name": "clientCameraView",
            "type": "ClientCameraView",
            "nullable": false
          },
          {
            "name": "isLocked",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "cameraSettings",
            "type": "ServerCameraSettings",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SetServerCamera\n// Package: com.hypixel.hytale.protocol.packets.camera\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 280;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 157;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 157;\npublic static final int MAX_SIZE = 157;\n\n// === FIELDS ===\n@Nonnull ClientCameraView clientCameraView;\n@Nonnull boolean isLocked;\n@Nullable ServerCameraSettings cameraSettings;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetServerCamera deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetServerCamera obj = new SetServerCamera();\n      byte nullBits = buf.getByte(offset);\n      obj.clientCameraView = ClientCameraView.fromValue(buf.getByte(offset + 1));\n      obj.isLocked = buf.getByte(offset + 2) != 0;\n      if ((nullBits & 1) != 0) {\n         obj.cameraSettings = ServerCameraSettings.deserialize(buf, offset + 3);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SetServerCamera deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetServerCamera obj = new SetServerCamera();\n      byte nullBits = buf.getByte(offset);\n      obj.clientCameraView = ClientCameraView.fromValue(buf.getByte(offset + 1));\n      obj.isLocked = buf.getByte(offset + 2) != 0;\n      if ((nullBits & 1) != 0) {\n         obj.cameraSettings = ServerCameraSettings.deserialize(buf, offset + 3);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 157;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 157 ? ValidationResult.error(\"Buffer too small: expected at least 157 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, ClientCameraView.fromValue, ServerCameraSettings.deserialize\n// Types referenced: ClientCameraView, ServerCameraSettings\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CameraShakeEffect",
        "packetId": 281,
        "package": "com.hypixel.hytale.protocol.packets.camera",
        "fields": [
          {
            "name": "cameraShakeId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "intensity",
            "type": "float",
            "nullable": false
          },
          {
            "name": "mode",
            "type": "AccumulationMode",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: CameraShakeEffect\n// Package: com.hypixel.hytale.protocol.packets.camera\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 281;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 9;\n\n// === FIELDS ===\n@Nonnull int cameraShakeId;\n@Nonnull float intensity;\n@Nonnull AccumulationMode mode;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CameraShakeEffect deserialize(@Nonnull ByteBuf buf, int offset) {\n      CameraShakeEffect obj = new CameraShakeEffect();\n      obj.cameraShakeId = buf.getIntLE(offset + 0);\n      obj.intensity = buf.getFloatLE(offset + 4);\n      obj.mode = AccumulationMode.fromValue(buf.getByte(offset + 8));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 9;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 9 ? ValidationResult.error(\"Buffer too small: expected at least 9 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getFloatLE, AccumulationMode.fromValue, buf.getByte\n// Types referenced: AccumulationMode\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "RequestFlyCameraMode",
        "packetId": 282,
        "package": "com.hypixel.hytale.protocol.packets.camera",
        "fields": [
          {
            "name": "entering",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: RequestFlyCameraMode\n// Package: com.hypixel.hytale.protocol.packets.camera\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 282;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean entering;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static RequestFlyCameraMode deserialize(@Nonnull ByteBuf buf, int offset) {\n      RequestFlyCameraMode obj = new RequestFlyCameraMode();\n      obj.entering = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetFlyCameraMode",
        "packetId": 283,
        "package": "com.hypixel.hytale.protocol.packets.camera",
        "fields": [
          {
            "name": "entering",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetFlyCameraMode\n// Package: com.hypixel.hytale.protocol.packets.camera\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 283;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean entering;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetFlyCameraMode deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetFlyCameraMode obj = new SetFlyCameraMode();\n      obj.entering = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "interface_": [
      {
        "name": "PortalDef",
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "nameKey",
            "type": "String",
            "nullable": true
          },
          {
            "name": "explorationSeconds",
            "type": "int",
            "nullable": false
          },
          {
            "name": "breachSeconds",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: PortalDef\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 16384014;\n\n// === FIELDS ===\n@Nullable String nameKey;\n@Nonnull int explorationSeconds;\n@Nonnull int breachSeconds;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PortalDef deserialize(@Nonnull ByteBuf buf, int offset) {\n      PortalDef obj = new PortalDef();\n      byte nullBits = buf.getByte(offset);\n      obj.explorationSeconds = buf.getIntLE(offset + 1);\n      obj.breachSeconds = buf.getIntLE(offset + 5);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int nameKeyLen = VarInt.peek(buf, pos);\n         if (nameKeyLen < 0) {\n            throw ProtocolException.negativeLength(\"NameKey\", nameKeyLen);\n         }\n\n         if (nameKeyLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"NameKey\", nameKeyLen, 4096000);\n         }\n\n         int nameKeyVarLen = VarInt.length(buf, pos);\n         obj.nameKey = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += nameKeyVarLen + nameKeyLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 9;\n         if ((nullBits & 1) != 0) {\n            int nameKeyLen = VarInt.peek(buffer, pos);\n            if (nameKeyLen < 0) {\n               return ValidationResult.error(\"Invalid string length for NameKey\");\n            }\n\n            if (nameKeyLen > 4096000) {\n               return ValidationResult.error(\"NameKey exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += nameKeyLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading NameKey\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerPlayerListUpdate",
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "uuid",
            "type": "UUID",
            "nullable": false
          },
          {
            "name": "worldUuid",
            "type": "UUID",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ServerPlayerListUpdate\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 32;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 32;\npublic static final int MAX_SIZE = 32;\n\n// === FIELDS ===\n@Nonnull UUID uuid;\n@Nonnull UUID worldUuid;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerPlayerListUpdate deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerPlayerListUpdate obj = new ServerPlayerListUpdate();\n      obj.uuid = PacketIO.readUUID(buf, offset + 0);\n      obj.worldUuid = PacketIO.readUUID(buf, offset + 16);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 32;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 32 ? ValidationResult.error(\"Buffer too small: expected at least 32 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: PacketIO.readUUID\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "EditorSelection",
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "minX",
            "type": "int",
            "nullable": false
          },
          {
            "name": "minY",
            "type": "int",
            "nullable": false
          },
          {
            "name": "minZ",
            "type": "int",
            "nullable": false
          },
          {
            "name": "maxX",
            "type": "int",
            "nullable": false
          },
          {
            "name": "maxY",
            "type": "int",
            "nullable": false
          },
          {
            "name": "maxZ",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: EditorSelection\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 24;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 24;\npublic static final int MAX_SIZE = 24;\n\n// === FIELDS ===\n@Nonnull int minX;\n@Nonnull int minY;\n@Nonnull int minZ;\n@Nonnull int maxX;\n@Nonnull int maxY;\n@Nonnull int maxZ;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static EditorSelection deserialize(@Nonnull ByteBuf buf, int offset) {\n      EditorSelection obj = new EditorSelection();\n      obj.minX = buf.getIntLE(offset + 0);\n      obj.minY = buf.getIntLE(offset + 4);\n      obj.minZ = buf.getIntLE(offset + 8);\n      obj.maxX = buf.getIntLE(offset + 12);\n      obj.maxY = buf.getIntLE(offset + 16);\n      obj.maxZ = buf.getIntLE(offset + 20);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 24;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 24 ? ValidationResult.error(\"Buffer too small: expected at least 24 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CustomUIEventBinding",
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "type",
            "type": "CustomUIEventBindingType",
            "nullable": false
          },
          {
            "name": "selector",
            "type": "String",
            "nullable": true
          },
          {
            "name": "data",
            "type": "String",
            "nullable": true
          },
          {
            "name": "locksInterface",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: CustomUIEventBinding\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 3;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 11;\npublic static final int MAX_SIZE = 32768021;\n\n// === FIELDS ===\n@Nonnull CustomUIEventBindingType type;\n@Nullable String selector;\n@Nullable String data;\n@Nonnull boolean locksInterface;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CustomUIEventBinding deserialize(@Nonnull ByteBuf buf, int offset) {\n      CustomUIEventBinding obj = new CustomUIEventBinding();\n      byte nullBits = buf.getByte(offset);\n      obj.type = CustomUIEventBindingType.fromValue(buf.getByte(offset + 1));\n      obj.locksInterface = buf.getByte(offset + 2) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 11 + buf.getIntLE(offset + 3);\n         int selectorLen = VarInt.peek(buf, varPos0);\n         if (selectorLen < 0) {\n            throw ProtocolException.negativeLength(\"Selector\", selectorLen);\n         }\n\n         if (selectorLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Selector\", selectorLen, 4096000);\n         }\n\n         obj.selector = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 11 + buf.getIntLE(offset + 7);\n         int dataLen = VarInt.peek(buf, varPos1);\n         if (dataLen < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataLen);\n         }\n\n         if (dataLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Data\", dataLen, 4096000);\n         }\n\n         obj.data = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 11;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 3);\n         int pos0 = offset + 11 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 7);\n         int pos1 = offset + 11 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 11) {\n         return ValidationResult.error(\"Buffer too small: expected at least 11 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int selectorOffset = buffer.getIntLE(offset + 3);\n            if (selectorOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Selector\");\n            }\n\n            int pos = offset + 11 + selectorOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Selector\");\n            }\n\n            int selectorLen = VarInt.peek(buffer, pos);\n            if (selectorLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Selector\");\n            }\n\n            if (selectorLen > 4096000) {\n               return ValidationResult.error(\"Selector exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += selectorLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Selector\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int dataOffset = buffer.getIntLE(offset + 7);\n            if (dataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Data\");\n            }\n\n            int posx = offset + 11 + dataOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Data\");\n            }\n\n            int dataLen = VarInt.peek(buffer, posx);\n            if (dataLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Data\");\n            }\n\n            if (dataLen > 4096000) {\n               return ValidationResult.error(\"Data exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += dataLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Data\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, CustomUIEventBindingType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: CustomUIEventBindingType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CustomUICommand",
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "type",
            "type": "CustomUICommandType",
            "nullable": false
          },
          {
            "name": "selector",
            "type": "String",
            "nullable": true
          },
          {
            "name": "data",
            "type": "String",
            "nullable": true
          },
          {
            "name": "text",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: CustomUICommand\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 14;\npublic static final int MAX_SIZE = 49152029;\n\n// === FIELDS ===\n@Nonnull CustomUICommandType type;\n@Nullable String selector;\n@Nullable String data;\n@Nullable String text;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CustomUICommand deserialize(@Nonnull ByteBuf buf, int offset) {\n      CustomUICommand obj = new CustomUICommand();\n      byte nullBits = buf.getByte(offset);\n      obj.type = CustomUICommandType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 14 + buf.getIntLE(offset + 2);\n         int selectorLen = VarInt.peek(buf, varPos0);\n         if (selectorLen < 0) {\n            throw ProtocolException.negativeLength(\"Selector\", selectorLen);\n         }\n\n         if (selectorLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Selector\", selectorLen, 4096000);\n         }\n\n         obj.selector = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 14 + buf.getIntLE(offset + 6);\n         int dataLen = VarInt.peek(buf, varPos1);\n         if (dataLen < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataLen);\n         }\n\n         if (dataLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Data\", dataLen, 4096000);\n         }\n\n         obj.data = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 14 + buf.getIntLE(offset + 10);\n         int textLen = VarInt.peek(buf, varPos2);\n         if (textLen < 0) {\n            throw ProtocolException.negativeLength(\"Text\", textLen);\n         }\n\n         if (textLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Text\", textLen, 4096000);\n         }\n\n         obj.text = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 14;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 2);\n         int pos0 = offset + 14 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 6);\n         int pos1 = offset + 14 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 10);\n         int pos2 = offset + 14 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 14) {\n         return ValidationResult.error(\"Buffer too small: expected at least 14 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int selectorOffset = buffer.getIntLE(offset + 2);\n            if (selectorOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Selector\");\n            }\n\n            int pos = offset + 14 + selectorOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Selector\");\n            }\n\n            int selectorLen = VarInt.peek(buffer, pos);\n            if (selectorLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Selector\");\n            }\n\n            if (selectorLen > 4096000) {\n               return ValidationResult.error(\"Selector exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += selectorLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Selector\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int dataOffset = buffer.getIntLE(offset + 6);\n            if (dataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Data\");\n            }\n\n            int posx = offset + 14 + dataOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Data\");\n            }\n\n            int dataLen = VarInt.peek(buffer, posx);\n            if (dataLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Data\");\n            }\n\n            if (dataLen > 4096000) {\n               return ValidationResult.error(\"Data exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += dataLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Data\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int textOffset = buffer.getIntLE(offset + 10);\n            if (textOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Text\");\n            }\n\n            int posxx = offset + 14 + textOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Text\");\n            }\n\n            int textLen = VarInt.peek(buffer, posxx);\n            if (textLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Text\");\n            }\n\n            if (textLen > 4096000) {\n               return ValidationResult.error(\"Text exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += textLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Text\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, CustomUICommandType.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: CustomUICommandType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BlockChange",
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "block",
            "type": "int",
            "nullable": false
          },
          {
            "name": "rotation",
            "type": "byte",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BlockChange\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 17;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 17;\npublic static final int MAX_SIZE = 17;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n@Nonnull int block;\n@Nonnull byte rotation;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BlockChange deserialize(@Nonnull ByteBuf buf, int offset) {\n      BlockChange obj = new BlockChange();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      obj.block = buf.getIntLE(offset + 12);\n      obj.rotation = buf.getByte(offset + 16);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 17;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 17 ? ValidationResult.error(\"Buffer too small: expected at least 17 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "FluidChange",
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "fluidId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "fluidLevel",
            "type": "byte",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: FluidChange\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 17;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 17;\npublic static final int MAX_SIZE = 17;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n@Nonnull int fluidId;\n@Nonnull byte fluidLevel;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static FluidChange deserialize(@Nonnull ByteBuf buf, int offset) {\n      FluidChange obj = new FluidChange();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      obj.fluidId = buf.getIntLE(offset + 12);\n      obj.fluidLevel = buf.getByte(offset + 16);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 17;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 17 ? ValidationResult.error(\"Buffer too small: expected at least 17 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PortalState",
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "remainingSeconds",
            "type": "int",
            "nullable": false
          },
          {
            "name": "breaching",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: PortalState\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 5;\n\n// === FIELDS ===\n@Nonnull int remainingSeconds;\n@Nonnull boolean breaching;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PortalState deserialize(@Nonnull ByteBuf buf, int offset) {\n      PortalState obj = new PortalState();\n      obj.remainingSeconds = buf.getIntLE(offset + 0);\n      obj.breaching = buf.getByte(offset + 4) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 5;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 5 ? ValidationResult.error(\"Buffer too small: expected at least 5 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerPlayerListPlayer",
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "uuid",
            "type": "UUID",
            "nullable": false
          },
          {
            "name": "username",
            "type": "String",
            "nullable": true
          },
          {
            "name": "worldUuid",
            "type": "UUID",
            "nullable": true
          },
          {
            "name": "ping",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ServerPlayerListPlayer\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 37;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 37;\npublic static final int MAX_SIZE = 16384042;\n\n// === FIELDS ===\n@Nonnull UUID uuid;\n@Nullable String username;\n@Nullable UUID worldUuid;\n@Nonnull int ping;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerPlayerListPlayer deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerPlayerListPlayer obj = new ServerPlayerListPlayer();\n      byte nullBits = buf.getByte(offset);\n      obj.uuid = PacketIO.readUUID(buf, offset + 1);\n      if ((nullBits & 2) != 0) {\n         obj.worldUuid = PacketIO.readUUID(buf, offset + 17);\n      }\n\n      obj.ping = buf.getIntLE(offset + 33);\n      int pos = offset + 37;\n      if ((nullBits & 1) != 0) {\n         int usernameLen = VarInt.peek(buf, pos);\n         if (usernameLen < 0) {\n            throw ProtocolException.negativeLength(\"Username\", usernameLen);\n         }\n\n         if (usernameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Username\", usernameLen, 4096000);\n         }\n\n         int usernameVarLen = VarInt.length(buf, pos);\n         obj.username = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += usernameVarLen + usernameLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 37;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 37) {\n         return ValidationResult.error(\"Buffer too small: expected at least 37 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 37;\n         if ((nullBits & 1) != 0) {\n            int usernameLen = VarInt.peek(buffer, pos);\n            if (usernameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Username\");\n            }\n\n            if (usernameLen > 4096000) {\n               return ValidationResult.error(\"Username exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += usernameLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Username\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, PacketIO.readUUID, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerMessage",
        "packetId": 210,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "type",
            "type": "ChatType",
            "nullable": false
          },
          {
            "name": "message",
            "type": "FormattedMessage",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: ServerMessage\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 210;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull ChatType type;\n@Nullable FormattedMessage message;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerMessage deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerMessage obj = new ServerMessage();\n      byte nullBits = buf.getByte(offset);\n      obj.type = ChatType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         obj.message = FormattedMessage.deserialize(buf, pos);\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static ServerMessage deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerMessage obj = new ServerMessage();\n      byte nullBits = buf.getByte(offset);\n      obj.type = ChatType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         obj.message = FormattedMessage.deserialize(buf, pos);\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         pos += FormattedMessage.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            ValidationResult messageResult = FormattedMessage.validateStructure(buffer, pos);\n            if (!messageResult.isValid()) {\n               return ValidationResult.error(\"Invalid Message: \" + messageResult.error());\n            }\n\n            pos += FormattedMessage.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, ChatType.fromValue, FormattedMessage.deserialize, FormattedMessage.computeBytesConsumed\n// Types referenced: ChatType, FormattedMessage\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ChatMessage",
        "packetId": 211,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "message",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: ChatMessage\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 211;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String message;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ChatMessage deserialize(@Nonnull ByteBuf buf, int offset) {\n      ChatMessage obj = new ChatMessage();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int messageLen = VarInt.peek(buf, pos);\n         if (messageLen < 0) {\n            throw ProtocolException.negativeLength(\"Message\", messageLen);\n         }\n\n         if (messageLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Message\", messageLen, 4096000);\n         }\n\n         int messageVarLen = VarInt.length(buf, pos);\n         obj.message = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += messageVarLen + messageLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int messageLen = VarInt.peek(buffer, pos);\n            if (messageLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Message\");\n            }\n\n            if (messageLen > 4096000) {\n               return ValidationResult.error(\"Message exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += messageLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Message\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "Notification",
        "packetId": 212,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "message",
            "type": "FormattedMessage",
            "nullable": true
          },
          {
            "name": "secondaryMessage",
            "type": "FormattedMessage",
            "nullable": true
          },
          {
            "name": "icon",
            "type": "String",
            "nullable": true
          },
          {
            "name": "item",
            "type": "ItemWithAllMetadata",
            "nullable": true
          },
          {
            "name": "style",
            "type": "NotificationStyle",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: Notification\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 212;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 4;\npublic static final int VARIABLE_BLOCK_START = 18;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable FormattedMessage message;\n@Nullable FormattedMessage secondaryMessage;\n@Nullable String icon;\n@Nullable ItemWithAllMetadata item;\n@Nonnull NotificationStyle style;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static Notification deserialize(@Nonnull ByteBuf buf, int offset) {\n      Notification obj = new Notification();\n      byte nullBits = buf.getByte(offset);\n      obj.style = NotificationStyle.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 18 + buf.getIntLE(offset + 2);\n         obj.message = FormattedMessage.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 18 + buf.getIntLE(offset + 6);\n         obj.secondaryMessage = FormattedMessage.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 18 + buf.getIntLE(offset + 10);\n         int iconLen = VarInt.peek(buf, varPos2);\n         if (iconLen < 0) {\n            throw ProtocolException.negativeLength(\"Icon\", iconLen);\n         }\n\n         if (iconLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Icon\", iconLen, 4096000);\n         }\n\n         obj.icon = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 18 + buf.getIntLE(offset + 14);\n         obj.item = ItemWithAllMetadata.deserialize(buf, varPos3);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static Notification deserialize(@Nonnull ByteBuf buf, int offset) {\n      Notification obj = new Notification();\n      byte nullBits = buf.getByte(offset);\n      obj.style = NotificationStyle.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 18 + buf.getIntLE(offset + 2);\n         obj.message = FormattedMessage.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 18 + buf.getIntLE(offset + 6);\n         obj.secondaryMessage = FormattedMessage.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 18 + buf.getIntLE(offset + 10);\n         int iconLen = VarInt.peek(buf, varPos2);\n         if (iconLen < 0) {\n            throw ProtocolException.negativeLength(\"Icon\", iconLen);\n         }\n\n         if (iconLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Icon\", iconLen, 4096000);\n         }\n\n         obj.icon = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 18 + buf.getIntLE(offset + 14);\n         obj.item = ItemWithAllMetadata.deserialize(buf, varPos3);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 18;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 2);\n         int pos0 = offset + 18 + fieldOffset0;\n         pos0 += FormattedMessage.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 6);\n         int pos1 = offset + 18 + fieldOffset1;\n         pos1 += FormattedMessage.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 10);\n         int pos2 = offset + 18 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         int fieldOffset3 = buf.getIntLE(offset + 14);\n         int pos3 = offset + 18 + fieldOffset3;\n         pos3 += ItemWithAllMetadata.computeBytesConsumed(buf, pos3);\n         if (pos3 - offset > maxEnd) {\n            maxEnd = pos3 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 18) {\n         return ValidationResult.error(\"Buffer too small: expected at least 18 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int messageOffset = buffer.getIntLE(offset + 2);\n            if (messageOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Message\");\n            }\n\n            int pos = offset + 18 + messageOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Message\");\n            }\n\n            ValidationResult messageResult = FormattedMessage.validateStructure(buffer, pos);\n            if (!messageResult.isValid()) {\n               return ValidationResult.error(\"Invalid Message: \" + messageResult.error());\n            }\n\n            pos += FormattedMessage.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int secondaryMessageOffset = buffer.getIntLE(offset + 6);\n            if (secondaryMessageOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for SecondaryMessage\");\n            }\n\n            int posx = offset + 18 + secondaryMessageOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for SecondaryMessage\");\n            }\n\n            ValidationResult secondaryMessageResult = FormattedMessage.validateStructure(buffer, posx);\n            if (!secondaryMessageResult.isValid()) {\n               return ValidationResult.error(\"Invalid SecondaryMessage: \" + secondaryMessageResult.error());\n            }\n\n            posx += FormattedMessage.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int iconOffset = buffer.getIntLE(offset + 10);\n            if (iconOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Icon\");\n            }\n\n            int posxx = offset + 18 + iconOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Icon\");\n            }\n\n            int iconLen = VarInt.peek(buffer, posxx);\n            if (iconLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Icon\");\n            }\n\n            if (iconLen > 4096000) {\n               return ValidationResult.error(\"Icon exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += iconLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Icon\");\n            }\n         }\n\n         if ((nullBits & 8) != 0) {\n            int itemOffset = buffer.getIntLE(offset + 14);\n            if (itemOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Item\");\n            }\n\n            int posxxx = offset + 18 + itemOffset;\n            if (posxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Item\");\n            }\n\n            ValidationResult itemResult = ItemWithAllMetadata.validateStructure(buffer, posxxx);\n            if (!itemResult.isValid()) {\n               return ValidationResult.error(\"Invalid Item: \" + itemResult.error());\n            }\n\n            posxxx += ItemWithAllMetadata.computeBytesConsumed(buffer, posxxx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, NotificationStyle.fromValue, buf.getIntLE, FormattedMessage.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ItemWithAllMetadata.deserialize\n// Types referenced: NotificationStyle, FormattedMessage, ItemWithAllMetadata\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "KillFeedMessage",
        "packetId": 213,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "killer",
            "type": "FormattedMessage",
            "nullable": true
          },
          {
            "name": "decedent",
            "type": "FormattedMessage",
            "nullable": true
          },
          {
            "name": "icon",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: KillFeedMessage\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 213;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable FormattedMessage killer;\n@Nullable FormattedMessage decedent;\n@Nullable String icon;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static KillFeedMessage deserialize(@Nonnull ByteBuf buf, int offset) {\n      KillFeedMessage obj = new KillFeedMessage();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 1);\n         obj.killer = FormattedMessage.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 5);\n         obj.decedent = FormattedMessage.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 13 + buf.getIntLE(offset + 9);\n         int iconLen = VarInt.peek(buf, varPos2);\n         if (iconLen < 0) {\n            throw ProtocolException.negativeLength(\"Icon\", iconLen);\n         }\n\n         if (iconLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Icon\", iconLen, 4096000);\n         }\n\n         obj.icon = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static KillFeedMessage deserialize(@Nonnull ByteBuf buf, int offset) {\n      KillFeedMessage obj = new KillFeedMessage();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 1);\n         obj.killer = FormattedMessage.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 5);\n         obj.decedent = FormattedMessage.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 13 + buf.getIntLE(offset + 9);\n         int iconLen = VarInt.peek(buf, varPos2);\n         if (iconLen < 0) {\n            throw ProtocolException.negativeLength(\"Icon\", iconLen);\n         }\n\n         if (iconLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Icon\", iconLen, 4096000);\n         }\n\n         obj.icon = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 13;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 13 + fieldOffset0;\n         pos0 += FormattedMessage.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 13 + fieldOffset1;\n         pos1 += FormattedMessage.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 9);\n         int pos2 = offset + 13 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int killerOffset = buffer.getIntLE(offset + 1);\n            if (killerOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Killer\");\n            }\n\n            int pos = offset + 13 + killerOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Killer\");\n            }\n\n            ValidationResult killerResult = FormattedMessage.validateStructure(buffer, pos);\n            if (!killerResult.isValid()) {\n               return ValidationResult.error(\"Invalid Killer: \" + killerResult.error());\n            }\n\n            pos += FormattedMessage.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int decedentOffset = buffer.getIntLE(offset + 5);\n            if (decedentOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Decedent\");\n            }\n\n            int posx = offset + 13 + decedentOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Decedent\");\n            }\n\n            ValidationResult decedentResult = FormattedMessage.validateStructure(buffer, posx);\n            if (!decedentResult.isValid()) {\n               return ValidationResult.error(\"Invalid Decedent: \" + decedentResult.error());\n            }\n\n            posx += FormattedMessage.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int iconOffset = buffer.getIntLE(offset + 9);\n            if (iconOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Icon\");\n            }\n\n            int posxx = offset + 13 + iconOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Icon\");\n            }\n\n            int iconLen = VarInt.peek(buffer, posxx);\n            if (iconLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Icon\");\n            }\n\n            if (iconLen > 4096000) {\n               return ValidationResult.error(\"Icon exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += iconLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Icon\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, FormattedMessage.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: FormattedMessage\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ShowEventTitle",
        "packetId": 214,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "fadeInDuration",
            "type": "float",
            "nullable": false
          },
          {
            "name": "fadeOutDuration",
            "type": "float",
            "nullable": false
          },
          {
            "name": "duration",
            "type": "float",
            "nullable": false
          },
          {
            "name": "icon",
            "type": "String",
            "nullable": true
          },
          {
            "name": "isMajor",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "primaryTitle",
            "type": "FormattedMessage",
            "nullable": true
          },
          {
            "name": "secondaryTitle",
            "type": "FormattedMessage",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: ShowEventTitle\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 214;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 14;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 26;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull float fadeInDuration;\n@Nonnull float fadeOutDuration;\n@Nonnull float duration;\n@Nullable String icon;\n@Nonnull boolean isMajor;\n@Nullable FormattedMessage primaryTitle;\n@Nullable FormattedMessage secondaryTitle;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ShowEventTitle deserialize(@Nonnull ByteBuf buf, int offset) {\n      ShowEventTitle obj = new ShowEventTitle();\n      byte nullBits = buf.getByte(offset);\n      obj.fadeInDuration = buf.getFloatLE(offset + 1);\n      obj.fadeOutDuration = buf.getFloatLE(offset + 5);\n      obj.duration = buf.getFloatLE(offset + 9);\n      obj.isMajor = buf.getByte(offset + 13) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 26 + buf.getIntLE(offset + 14);\n         int iconLen = VarInt.peek(buf, varPos0);\n         if (iconLen < 0) {\n            throw ProtocolException.negativeLength(\"Icon\", iconLen);\n         }\n\n         if (iconLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Icon\", iconLen, 4096000);\n         }\n\n         obj.icon = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 26 + buf.getIntLE(offset + 18);\n         obj.primaryTitle = FormattedMessage.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 26 + buf.getIntLE(offset + 22);\n         obj.secondaryTitle = FormattedMessage.deserialize(buf, varPos2);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static ShowEventTitle deserialize(@Nonnull ByteBuf buf, int offset) {\n      ShowEventTitle obj = new ShowEventTitle();\n      byte nullBits = buf.getByte(offset);\n      obj.fadeInDuration = buf.getFloatLE(offset + 1);\n      obj.fadeOutDuration = buf.getFloatLE(offset + 5);\n      obj.duration = buf.getFloatLE(offset + 9);\n      obj.isMajor = buf.getByte(offset + 13) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 26 + buf.getIntLE(offset + 14);\n         int iconLen = VarInt.peek(buf, varPos0);\n         if (iconLen < 0) {\n            throw ProtocolException.negativeLength(\"Icon\", iconLen);\n         }\n\n         if (iconLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Icon\", iconLen, 4096000);\n         }\n\n         obj.icon = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 26 + buf.getIntLE(offset + 18);\n         obj.primaryTitle = FormattedMessage.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 26 + buf.getIntLE(offset + 22);\n         obj.secondaryTitle = FormattedMessage.deserialize(buf, varPos2);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 26;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 14);\n         int pos0 = offset + 26 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 18);\n         int pos1 = offset + 26 + fieldOffset1;\n         pos1 += FormattedMessage.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 22);\n         int pos2 = offset + 26 + fieldOffset2;\n         pos2 += FormattedMessage.computeBytesConsumed(buf, pos2);\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 26) {\n         return ValidationResult.error(\"Buffer too small: expected at least 26 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int iconOffset = buffer.getIntLE(offset + 14);\n            if (iconOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Icon\");\n            }\n\n            int pos = offset + 26 + iconOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Icon\");\n            }\n\n            int iconLen = VarInt.peek(buffer, pos);\n            if (iconLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Icon\");\n            }\n\n            if (iconLen > 4096000) {\n               return ValidationResult.error(\"Icon exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += iconLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Icon\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int primaryTitleOffset = buffer.getIntLE(offset + 18);\n            if (primaryTitleOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for PrimaryTitle\");\n            }\n\n            int posx = offset + 26 + primaryTitleOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for PrimaryTitle\");\n            }\n\n            ValidationResult primaryTitleResult = FormattedMessage.validateStructure(buffer, posx);\n            if (!primaryTitleResult.isValid()) {\n               return ValidationResult.error(\"Invalid PrimaryTitle: \" + primaryTitleResult.error());\n            }\n\n            posx += FormattedMessage.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int secondaryTitleOffset = buffer.getIntLE(offset + 22);\n            if (secondaryTitleOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for SecondaryTitle\");\n            }\n\n            int posxx = offset + 26 + secondaryTitleOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for SecondaryTitle\");\n            }\n\n            ValidationResult secondaryTitleResult = FormattedMessage.validateStructure(buffer, posxx);\n            if (!secondaryTitleResult.isValid()) {\n               return ValidationResult.error(\"Invalid SecondaryTitle: \" + secondaryTitleResult.error());\n            }\n\n            posxx += FormattedMessage.computeBytesConsumed(buffer, posxx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getFloatLE, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, FormattedMessage.deserialize\n// Types referenced: FormattedMessage\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "HideEventTitle",
        "packetId": 215,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "fadeOutDuration",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: HideEventTitle\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 215;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull float fadeOutDuration;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static HideEventTitle deserialize(@Nonnull ByteBuf buf, int offset) {\n      HideEventTitle obj = new HideEventTitle();\n      obj.fadeOutDuration = buf.getFloatLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getFloatLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetPage",
        "packetId": 216,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "page",
            "type": "Page",
            "nullable": false
          },
          {
            "name": "canCloseThroughInteraction",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetPage\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 216;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 2;\n\n// === FIELDS ===\n@Nonnull Page page;\n@Nonnull boolean canCloseThroughInteraction;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetPage deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetPage obj = new SetPage();\n      obj.page = Page.fromValue(buf.getByte(offset + 0));\n      obj.canCloseThroughInteraction = buf.getByte(offset + 1) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 2;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 2 ? ValidationResult.error(\"Buffer too small: expected at least 2 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: Page.fromValue, buf.getByte\n// Types referenced: Page\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CustomHud",
        "packetId": 217,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "clear",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "commands",
            "type": "CustomUICommand[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: CustomHud\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 217;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull boolean clear;\n@Nullable CustomUICommand[] commands;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CustomHud deserialize(@Nonnull ByteBuf buf, int offset) {\n      CustomHud obj = new CustomHud();\n      byte nullBits = buf.getByte(offset);\n      obj.clear = buf.getByte(offset + 1) != 0;\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int commandsCount = VarInt.peek(buf, pos);\n         if (commandsCount < 0) {\n            throw ProtocolException.negativeLength(\"Commands\", commandsCount);\n         }\n\n         if (commandsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Commands\", commandsCount, 4096000);\n         }\n\n         int commandsVarLen = VarInt.size(commandsCount);\n         if ((long)(pos + commandsVarLen) + (long)commandsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Commands\", pos + commandsVarLen + commandsCount * 2, buf.readableBytes());\n         }\n\n         pos += commandsVarLen;\n         obj.commands = new CustomUICommand[commandsCount];\n\n         for (int i = 0; i < commandsCount; i++) {\n            obj.commands[i] = CustomUICommand.deserialize(buf, pos);\n            pos += CustomUICommand.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static CustomHud deserialize(@Nonnull ByteBuf buf, int offset) {\n      CustomHud obj = new CustomHud();\n      byte nullBits = buf.getByte(offset);\n      obj.clear = buf.getByte(offset + 1) != 0;\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int commandsCount = VarInt.peek(buf, pos);\n         if (commandsCount < 0) {\n            throw ProtocolException.negativeLength(\"Commands\", commandsCount);\n         }\n\n         if (commandsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Commands\", commandsCount, 4096000);\n         }\n\n         int commandsVarLen = VarInt.size(commandsCount);\n         if ((long)(pos + commandsVarLen) + (long)commandsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Commands\", pos + commandsVarLen + commandsCount * 2, buf.readableBytes());\n         }\n\n         pos += commandsVarLen;\n         obj.commands = new CustomUICommand[commandsCount];\n\n         for (int i = 0; i < commandsCount; i++) {\n            obj.commands[i] = CustomUICommand.deserialize(buf, pos);\n            pos += CustomUICommand.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += CustomUICommand.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int commandsCount = VarInt.peek(buffer, pos);\n            if (commandsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Commands\");\n            }\n\n            if (commandsCount > 4096000) {\n               return ValidationResult.error(\"Commands exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < commandsCount; i++) {\n               ValidationResult structResult = CustomUICommand.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid CustomUICommand in Commands[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += CustomUICommand.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, CustomUICommand.deserialize, CustomUICommand.computeBytesConsumed\n// Types referenced: CustomUICommand\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CustomPage",
        "packetId": 218,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "key",
            "type": "String",
            "nullable": true
          },
          {
            "name": "isInitial",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "clear",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "lifetime",
            "type": "CustomPageLifetime",
            "nullable": false
          },
          {
            "name": "commands",
            "type": "CustomUICommand[]",
            "nullable": true
          },
          {
            "name": "eventBindings",
            "type": "CustomUIEventBinding[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: CustomPage\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 218;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 16;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable String key;\n@Nonnull boolean isInitial;\n@Nonnull boolean clear;\n@Nonnull CustomPageLifetime lifetime;\n@Nullable CustomUICommand[] commands;\n@Nullable CustomUIEventBinding[] eventBindings;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CustomPage deserialize(@Nonnull ByteBuf buf, int offset) {\n      CustomPage obj = new CustomPage();\n      byte nullBits = buf.getByte(offset);\n      obj.isInitial = buf.getByte(offset + 1) != 0;\n      obj.clear = buf.getByte(offset + 2) != 0;\n      obj.lifetime = CustomPageLifetime.fromValue(buf.getByte(offset + 3));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 16 + buf.getIntLE(offset + 4);\n         int keyLen = VarInt.peek(buf, varPos0);\n         if (keyLen < 0) {\n            throw ProtocolException.negativeLength(\"Key\", keyLen);\n         }\n\n         if (keyLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Key\", keyLen, 4096000);\n         }\n\n         obj.key = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 16 + buf.getIntLE(offset + 8);\n         int commandsCount = VarInt.peek(buf, varPos1);\n         if (commandsCount < 0) {\n            throw ProtocolException.negativeLength(\"Commands\", commandsCount);\n         }\n\n         if (commandsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Commands\", commandsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)commandsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Commands\", varPos1 + varIntLen + commandsCount * 2, buf.readableBytes());\n         }\n\n         obj.commands = new CustomUICommand[commandsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < commandsCount; i++) {\n            obj.commands[i] = CustomUICommand.deserialize(buf, elemPos);\n            elemPos += CustomUICommand.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 16 + buf.getIntLE(offset + 12);\n         int eventBindingsCount = VarInt.peek(buf, varPos2);\n         if (eventBindingsCount < 0) {\n            throw ProtocolException.negativeLength(\"EventBindings\", eventBindingsCount);\n         }\n\n         if (eventBindingsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"EventBindings\", eventBindingsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)eventBindingsCount * 3L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"EventBindings\", varPos2 + varIntLen + eventBindingsCount * 3, buf.readableBytes());\n         }\n\n         obj.eventBindings = new CustomUIEventBinding[eventBindingsCount];\n         int elemPos = varPos2 + varIntLen;\n\n         for (int i = 0; i < eventBindingsCount; i++) {\n            obj.eventBindings[i] = CustomUIEventBinding.deserialize(buf, elemPos);\n            elemPos += CustomUIEventBinding.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static CustomPage deserialize(@Nonnull ByteBuf buf, int offset) {\n      CustomPage obj = new CustomPage();\n      byte nullBits = buf.getByte(offset);\n      obj.isInitial = buf.getByte(offset + 1) != 0;\n      obj.clear = buf.getByte(offset + 2) != 0;\n      obj.lifetime = CustomPageLifetime.fromValue(buf.getByte(offset + 3));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 16 + buf.getIntLE(offset + 4);\n         int keyLen = VarInt.peek(buf, varPos0);\n         if (keyLen < 0) {\n            throw ProtocolException.negativeLength(\"Key\", keyLen);\n         }\n\n         if (keyLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Key\", keyLen, 4096000);\n         }\n\n         obj.key = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 16 + buf.getIntLE(offset + 8);\n         int commandsCount = VarInt.peek(buf, varPos1);\n         if (commandsCount < 0) {\n            throw ProtocolException.negativeLength(\"Commands\", commandsCount);\n         }\n\n         if (commandsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Commands\", commandsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)commandsCount * 2L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Commands\", varPos1 + varIntLen + commandsCount * 2, buf.readableBytes());\n         }\n\n         obj.commands = new CustomUICommand[commandsCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < commandsCount; i++) {\n            obj.commands[i] = CustomUICommand.deserialize(buf, elemPos);\n            elemPos += CustomUICommand.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 16 + buf.getIntLE(offset + 12);\n         int eventBindingsCount = VarInt.peek(buf, varPos2);\n         if (eventBindingsCount < 0) {\n            throw ProtocolException.negativeLength(\"EventBindings\", eventBindingsCount);\n         }\n\n         if (eventBindingsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"EventBindings\", eventBindingsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)eventBindingsCount * 3L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"EventBindings\", varPos2 + varIntLen + eventBindingsCount * 3, buf.readableBytes());\n         }\n\n         obj.eventBindings = new CustomUIEventBinding[eventBindingsCount];\n         int elemPos = varPos2 + varIntLen;\n\n         for (int i = 0; i < eventBindingsCount; i++) {\n            obj.eventBindings[i] = CustomUIEventBinding.deserialize(buf, elemPos);\n            elemPos += CustomUIEventBinding.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 16;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 4);\n         int pos0 = offset + 16 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 8);\n         int pos1 = offset + 16 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos1 += CustomUICommand.computeBytesConsumed(buf, pos1);\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 12);\n         int pos2 = offset + 16 + fieldOffset2;\n         int arrLen = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos2 += CustomUIEventBinding.computeBytesConsumed(buf, pos2);\n         }\n\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 16) {\n         return ValidationResult.error(\"Buffer too small: expected at least 16 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int keyOffset = buffer.getIntLE(offset + 4);\n            if (keyOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Key\");\n            }\n\n            int pos = offset + 16 + keyOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Key\");\n            }\n\n            int keyLen = VarInt.peek(buffer, pos);\n            if (keyLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Key\");\n            }\n\n            if (keyLen > 4096000) {\n               return ValidationResult.error(\"Key exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += keyLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Key\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int commandsOffset = buffer.getIntLE(offset + 8);\n            if (commandsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Commands\");\n            }\n\n            int posx = offset + 16 + commandsOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Commands\");\n            }\n\n            int commandsCount = VarInt.peek(buffer, posx);\n            if (commandsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Commands\");\n            }\n\n            if (commandsCount > 4096000) {\n               return ValidationResult.error(\"Commands exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < commandsCount; i++) {\n               ValidationResult structResult = CustomUICommand.validateStructure(buffer, posx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid CustomUICommand in Commands[\" + i + \"]: \" + structResult.error());\n               }\n\n               posx += CustomUICommand.computeBytesConsumed(buffer, posx);\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int eventBindingsOffset = buffer.getIntLE(offset + 12);\n            if (eventBindingsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for EventBindings\");\n            }\n\n            int posxx = offset + 16 + eventBindingsOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for EventBindings\");\n            }\n\n            int eventBindingsCount = VarInt.peek(buffer, posxx);\n            if (eventBindingsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for EventBindings\");\n            }\n\n            if (eventBindingsCount > 4096000) {\n               return ValidationResult.error(\"EventBindings exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n\n            for (int i = 0; i < eventBindingsCount; i++) {\n               ValidationResult structResult = CustomUIEventBinding.validateStructure(buffer, posxx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid CustomUIEventBinding in EventBindings[\" + i + \"]: \" + structResult.error());\n               }\n\n               posxx += CustomUIEventBinding.computeBytesConsumed(buffer, posxx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, CustomPageLifetime.fromValue, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, CustomUICommand.deserialize, CustomUICommand.computeBytesConsumed, CustomUIEventBinding.deserialize, CustomUIEventBinding.computeBytesConsumed\n// Types referenced: CustomPageLifetime, CustomUICommand, CustomUIEventBinding\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CustomPageEvent",
        "packetId": 219,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "type",
            "type": "CustomPageEventType",
            "nullable": false
          },
          {
            "name": "data",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: CustomPageEvent\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 219;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 2;\npublic static final int MAX_SIZE = 16384007;\n\n// === FIELDS ===\n@Nonnull CustomPageEventType type;\n@Nullable String data;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CustomPageEvent deserialize(@Nonnull ByteBuf buf, int offset) {\n      CustomPageEvent obj = new CustomPageEvent();\n      byte nullBits = buf.getByte(offset);\n      obj.type = CustomPageEventType.fromValue(buf.getByte(offset + 1));\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int dataLen = VarInt.peek(buf, pos);\n         if (dataLen < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataLen);\n         }\n\n         if (dataLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Data\", dataLen, 4096000);\n         }\n\n         int dataVarLen = VarInt.length(buf, pos);\n         obj.data = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += dataVarLen + dataLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 2;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 2) {\n         return ValidationResult.error(\"Buffer too small: expected at least 2 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 2;\n         if ((nullBits & 1) != 0) {\n            int dataLen = VarInt.peek(buffer, pos);\n            if (dataLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Data\");\n            }\n\n            if (dataLen > 4096000) {\n               return ValidationResult.error(\"Data exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += dataLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Data\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, CustomPageEventType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n// Types referenced: CustomPageEventType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "EditorBlocksChange",
        "packetId": 222,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "selection",
            "type": "EditorSelection",
            "nullable": true
          },
          {
            "name": "blocksChange",
            "type": "BlockChange[]",
            "nullable": true
          },
          {
            "name": "fluidsChange",
            "type": "FluidChange[]",
            "nullable": true
          },
          {
            "name": "blocksCount",
            "type": "int",
            "nullable": false
          },
          {
            "name": "advancedPreview",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: EditorBlocksChange\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 222;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 30;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 38;\npublic static final int MAX_SIZE = 139264048;\n\n// === FIELDS ===\n@Nullable EditorSelection selection;\n@Nullable BlockChange[] blocksChange;\n@Nullable FluidChange[] fluidsChange;\n@Nonnull int blocksCount;\n@Nonnull boolean advancedPreview;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static EditorBlocksChange deserialize(@Nonnull ByteBuf buf, int offset) {\n      EditorBlocksChange obj = new EditorBlocksChange();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.selection = EditorSelection.deserialize(buf, offset + 1);\n      }\n\n      obj.blocksCount = buf.getIntLE(offset + 25);\n      obj.advancedPreview = buf.getByte(offset + 29) != 0;\n      if ((nullBits & 2) != 0) {\n         int varPos0 = offset + 38 + buf.getIntLE(offset + 30);\n         int blocksChangeCount = VarInt.peek(buf, varPos0);\n         if (blocksChangeCount < 0) {\n            throw ProtocolException.negativeLength(\"BlocksChange\", blocksChangeCount);\n         }\n\n         if (blocksChangeCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"BlocksChange\", blocksChangeCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)blocksChangeCount * 17L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"BlocksChange\", varPos0 + varIntLen + blocksChangeCount * 17, buf.readableBytes());\n         }\n\n         obj.blocksChange = new BlockChange[blocksChangeCount];\n         int elemPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < blocksChangeCount; i++) {\n            obj.blocksChange[i] = BlockChange.deserialize(buf, elemPos);\n            elemPos += BlockChange.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos1 = offset + 38 + buf.getIntLE(offset + 34);\n         int fluidsChangeCount = VarInt.peek(buf, varPos1);\n         if (fluidsChangeCount < 0) {\n            throw ProtocolException.negativeLength(\"FluidsChange\", fluidsChangeCount);\n         }\n\n         if (fluidsChangeCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"FluidsChange\", fluidsChangeCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)fluidsChangeCount * 17L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"FluidsChange\", varPos1 + varIntLen + fluidsChangeCount * 17, buf.readableBytes());\n         }\n\n         obj.fluidsChange = new FluidChange[fluidsChangeCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < fluidsChangeCount; i++) {\n            obj.fluidsChange[i] = FluidChange.deserialize(buf, elemPos);\n            elemPos += FluidChange.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static EditorBlocksChange deserialize(@Nonnull ByteBuf buf, int offset) {\n      EditorBlocksChange obj = new EditorBlocksChange();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.selection = EditorSelection.deserialize(buf, offset + 1);\n      }\n\n      obj.blocksCount = buf.getIntLE(offset + 25);\n      obj.advancedPreview = buf.getByte(offset + 29) != 0;\n      if ((nullBits & 2) != 0) {\n         int varPos0 = offset + 38 + buf.getIntLE(offset + 30);\n         int blocksChangeCount = VarInt.peek(buf, varPos0);\n         if (blocksChangeCount < 0) {\n            throw ProtocolException.negativeLength(\"BlocksChange\", blocksChangeCount);\n         }\n\n         if (blocksChangeCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"BlocksChange\", blocksChangeCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)blocksChangeCount * 17L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"BlocksChange\", varPos0 + varIntLen + blocksChangeCount * 17, buf.readableBytes());\n         }\n\n         obj.blocksChange = new BlockChange[blocksChangeCount];\n         int elemPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < blocksChangeCount; i++) {\n            obj.blocksChange[i] = BlockChange.deserialize(buf, elemPos);\n            elemPos += BlockChange.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos1 = offset + 38 + buf.getIntLE(offset + 34);\n         int fluidsChangeCount = VarInt.peek(buf, varPos1);\n         if (fluidsChangeCount < 0) {\n            throw ProtocolException.negativeLength(\"FluidsChange\", fluidsChangeCount);\n         }\n\n         if (fluidsChangeCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"FluidsChange\", fluidsChangeCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)fluidsChangeCount * 17L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"FluidsChange\", varPos1 + varIntLen + fluidsChangeCount * 17, buf.readableBytes());\n         }\n\n         obj.fluidsChange = new FluidChange[fluidsChangeCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < fluidsChangeCount; i++) {\n            obj.fluidsChange[i] = FluidChange.deserialize(buf, elemPos);\n            elemPos += FluidChange.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 38;\n      if ((nullBits & 2) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 30);\n         int pos0 = offset + 38 + fieldOffset0;\n         int arrLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos0 += BlockChange.computeBytesConsumed(buf, pos0);\n         }\n\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 34);\n         int pos1 = offset + 38 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos1 += FluidChange.computeBytesConsumed(buf, pos1);\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 38) {\n         return ValidationResult.error(\"Buffer too small: expected at least 38 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 2) != 0) {\n            int blocksChangeOffset = buffer.getIntLE(offset + 30);\n            if (blocksChangeOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for BlocksChange\");\n            }\n\n            int pos = offset + 38 + blocksChangeOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for BlocksChange\");\n            }\n\n            int blocksChangeCount = VarInt.peek(buffer, pos);\n            if (blocksChangeCount < 0) {\n               return ValidationResult.error(\"Invalid array count for BlocksChange\");\n            }\n\n            if (blocksChangeCount > 4096000) {\n               return ValidationResult.error(\"BlocksChange exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += blocksChangeCount * 17;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading BlocksChange\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int fluidsChangeOffset = buffer.getIntLE(offset + 34);\n            if (fluidsChangeOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for FluidsChange\");\n            }\n\n            int posx = offset + 38 + fluidsChangeOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for FluidsChange\");\n            }\n\n            int fluidsChangeCount = VarInt.peek(buffer, posx);\n            if (fluidsChangeCount < 0) {\n               return ValidationResult.error(\"Invalid array count for FluidsChange\");\n            }\n\n            if (fluidsChangeCount > 4096000) {\n               return ValidationResult.error(\"FluidsChange exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += fluidsChangeCount * 17;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading FluidsChange\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, EditorSelection.deserialize, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, BlockChange.deserialize, BlockChange.computeBytesConsumed, FluidChange.deserialize, FluidChange.computeBytesConsumed\n// Types referenced: EditorSelection, BlockChange, FluidChange\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerInfo",
        "packetId": 223,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "serverName",
            "type": "String",
            "nullable": true
          },
          {
            "name": "motd",
            "type": "String",
            "nullable": true
          },
          {
            "name": "maxPlayers",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ServerInfo\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 223;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 32768023;\n\n// === FIELDS ===\n@Nullable String serverName;\n@Nullable String motd;\n@Nonnull int maxPlayers;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerInfo deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerInfo obj = new ServerInfo();\n      byte nullBits = buf.getByte(offset);\n      obj.maxPlayers = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 5);\n         int serverNameLen = VarInt.peek(buf, varPos0);\n         if (serverNameLen < 0) {\n            throw ProtocolException.negativeLength(\"ServerName\", serverNameLen);\n         }\n\n         if (serverNameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ServerName\", serverNameLen, 4096000);\n         }\n\n         obj.serverName = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 9);\n         int motdLen = VarInt.peek(buf, varPos1);\n         if (motdLen < 0) {\n            throw ProtocolException.negativeLength(\"Motd\", motdLen);\n         }\n\n         if (motdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Motd\", motdLen, 4096000);\n         }\n\n         obj.motd = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 13;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 5);\n         int pos0 = offset + 13 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 9);\n         int pos1 = offset + 13 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int serverNameOffset = buffer.getIntLE(offset + 5);\n            if (serverNameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ServerName\");\n            }\n\n            int pos = offset + 13 + serverNameOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ServerName\");\n            }\n\n            int serverNameLen = VarInt.peek(buffer, pos);\n            if (serverNameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ServerName\");\n            }\n\n            if (serverNameLen > 4096000) {\n               return ValidationResult.error(\"ServerName exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += serverNameLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ServerName\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int motdOffset = buffer.getIntLE(offset + 9);\n            if (motdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Motd\");\n            }\n\n            int posx = offset + 13 + motdOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Motd\");\n            }\n\n            int motdLen = VarInt.peek(buffer, posx);\n            if (motdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Motd\");\n            }\n\n            if (motdLen > 4096000) {\n               return ValidationResult.error(\"Motd exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += motdLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Motd\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "AddToServerPlayerList",
        "packetId": 224,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "players",
            "type": "ServerPlayerListPlayer[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: AddToServerPlayerList\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 224;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable ServerPlayerListPlayer[] players;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static AddToServerPlayerList deserialize(@Nonnull ByteBuf buf, int offset) {\n      AddToServerPlayerList obj = new AddToServerPlayerList();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int playersCount = VarInt.peek(buf, pos);\n         if (playersCount < 0) {\n            throw ProtocolException.negativeLength(\"Players\", playersCount);\n         }\n\n         if (playersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Players\", playersCount, 4096000);\n         }\n\n         int playersVarLen = VarInt.size(playersCount);\n         if ((long)(pos + playersVarLen) + (long)playersCount * 37L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Players\", pos + playersVarLen + playersCount * 37, buf.readableBytes());\n         }\n\n         pos += playersVarLen;\n         obj.players = new ServerPlayerListPlayer[playersCount];\n\n         for (int i = 0; i < playersCount; i++) {\n            obj.players[i] = ServerPlayerListPlayer.deserialize(buf, pos);\n            pos += ServerPlayerListPlayer.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static AddToServerPlayerList deserialize(@Nonnull ByteBuf buf, int offset) {\n      AddToServerPlayerList obj = new AddToServerPlayerList();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int playersCount = VarInt.peek(buf, pos);\n         if (playersCount < 0) {\n            throw ProtocolException.negativeLength(\"Players\", playersCount);\n         }\n\n         if (playersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Players\", playersCount, 4096000);\n         }\n\n         int playersVarLen = VarInt.size(playersCount);\n         if ((long)(pos + playersVarLen) + (long)playersCount * 37L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Players\", pos + playersVarLen + playersCount * 37, buf.readableBytes());\n         }\n\n         pos += playersVarLen;\n         obj.players = new ServerPlayerListPlayer[playersCount];\n\n         for (int i = 0; i < playersCount; i++) {\n            obj.players[i] = ServerPlayerListPlayer.deserialize(buf, pos);\n            pos += ServerPlayerListPlayer.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += ServerPlayerListPlayer.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int playersCount = VarInt.peek(buffer, pos);\n            if (playersCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Players\");\n            }\n\n            if (playersCount > 4096000) {\n               return ValidationResult.error(\"Players exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < playersCount; i++) {\n               ValidationResult structResult = ServerPlayerListPlayer.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid ServerPlayerListPlayer in Players[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += ServerPlayerListPlayer.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, ServerPlayerListPlayer.deserialize, ServerPlayerListPlayer.computeBytesConsumed\n// Types referenced: ServerPlayerListPlayer\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "RemoveFromServerPlayerList",
        "packetId": 225,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "players",
            "type": "UUID[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: RemoveFromServerPlayerList\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 225;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 65536006;\n\n// === FIELDS ===\n@Nullable UUID[] players;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static RemoveFromServerPlayerList deserialize(@Nonnull ByteBuf buf, int offset) {\n      RemoveFromServerPlayerList obj = new RemoveFromServerPlayerList();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int playersCount = VarInt.peek(buf, pos);\n         if (playersCount < 0) {\n            throw ProtocolException.negativeLength(\"Players\", playersCount);\n         }\n\n         if (playersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Players\", playersCount, 4096000);\n         }\n\n         int playersVarLen = VarInt.size(playersCount);\n         if ((long)(pos + playersVarLen) + (long)playersCount * 16L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Players\", pos + playersVarLen + playersCount * 16, buf.readableBytes());\n         }\n\n         pos += playersVarLen;\n         obj.players = new UUID[playersCount];\n\n         for (int i = 0; i < playersCount; i++) {\n            obj.players[i] = PacketIO.readUUID(buf, pos + i * 16);\n         }\n\n         pos += playersCount * 16;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 16;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int playersCount = VarInt.peek(buffer, pos);\n            if (playersCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Players\");\n            }\n\n            if (playersCount > 4096000) {\n               return ValidationResult.error(\"Players exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += playersCount * 16;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Players\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, PacketIO.readUUID\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateServerPlayerList",
        "packetId": 226,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "players",
            "type": "ServerPlayerListUpdate[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateServerPlayerList\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 226;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 131072006;\n\n// === FIELDS ===\n@Nullable ServerPlayerListUpdate[] players;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateServerPlayerList deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateServerPlayerList obj = new UpdateServerPlayerList();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int playersCount = VarInt.peek(buf, pos);\n         if (playersCount < 0) {\n            throw ProtocolException.negativeLength(\"Players\", playersCount);\n         }\n\n         if (playersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Players\", playersCount, 4096000);\n         }\n\n         int playersVarLen = VarInt.size(playersCount);\n         if ((long)(pos + playersVarLen) + (long)playersCount * 32L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Players\", pos + playersVarLen + playersCount * 32, buf.readableBytes());\n         }\n\n         pos += playersVarLen;\n         obj.players = new ServerPlayerListUpdate[playersCount];\n\n         for (int i = 0; i < playersCount; i++) {\n            obj.players[i] = ServerPlayerListUpdate.deserialize(buf, pos);\n            pos += ServerPlayerListUpdate.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateServerPlayerList deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateServerPlayerList obj = new UpdateServerPlayerList();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int playersCount = VarInt.peek(buf, pos);\n         if (playersCount < 0) {\n            throw ProtocolException.negativeLength(\"Players\", playersCount);\n         }\n\n         if (playersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Players\", playersCount, 4096000);\n         }\n\n         int playersVarLen = VarInt.size(playersCount);\n         if ((long)(pos + playersVarLen) + (long)playersCount * 32L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Players\", pos + playersVarLen + playersCount * 32, buf.readableBytes());\n         }\n\n         pos += playersVarLen;\n         obj.players = new ServerPlayerListUpdate[playersCount];\n\n         for (int i = 0; i < playersCount; i++) {\n            obj.players[i] = ServerPlayerListUpdate.deserialize(buf, pos);\n            pos += ServerPlayerListUpdate.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos += ServerPlayerListUpdate.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int playersCount = VarInt.peek(buffer, pos);\n            if (playersCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Players\");\n            }\n\n            if (playersCount > 4096000) {\n               return ValidationResult.error(\"Players exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += playersCount * 32;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Players\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, ServerPlayerListUpdate.deserialize, ServerPlayerListUpdate.computeBytesConsumed\n// Types referenced: ServerPlayerListUpdate\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateServerPlayerListPing",
        "packetId": 227,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "players",
            "type": "Map<UUID, Integer>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateServerPlayerListPing\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 227;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 81920006;\n\n// === FIELDS ===\n@Nullable Map<UUID, Integer> players;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateServerPlayerListPing deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateServerPlayerListPing obj = new UpdateServerPlayerListPing();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int playersCount = VarInt.peek(buf, pos);\n         if (playersCount < 0) {\n            throw ProtocolException.negativeLength(\"Players\", playersCount);\n         }\n\n         if (playersCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Players\", playersCount, 4096000);\n         }\n\n         pos += VarInt.size(playersCount);\n         obj.players = new HashMap<>(playersCount);\n\n         for (int i = 0; i < playersCount; i++) {\n            UUID key = PacketIO.readUUID(buf, pos);\n            pos += 16;\n            int val = buf.getIntLE(pos);\n            pos += 4;\n            if (obj.players.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"players\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 16;\n            pos += 4;\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int playersCount = VarInt.peek(buffer, pos);\n            if (playersCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Players\");\n            }\n\n            if (playersCount > 4096000) {\n               return ValidationResult.error(\"Players exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < playersCount; i++) {\n               pos += 16;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += 4;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading value\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, PacketIO.readUUID, buf.getIntLE, obj.players.put, ProtocolException.duplicateKey\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateKnownRecipes",
        "packetId": 228,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "known",
            "type": "Map<String, CraftingRecipe>",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateKnownRecipes\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 228;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable Map<String, CraftingRecipe> known;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateKnownRecipes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateKnownRecipes obj = new UpdateKnownRecipes();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int knownCount = VarInt.peek(buf, pos);\n         if (knownCount < 0) {\n            throw ProtocolException.negativeLength(\"Known\", knownCount);\n         }\n\n         if (knownCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Known\", knownCount, 4096000);\n         }\n\n         pos += VarInt.size(knownCount);\n         obj.known = new HashMap<>(knownCount);\n\n         for (int i = 0; i < knownCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            CraftingRecipe val = CraftingRecipe.deserialize(buf, pos);\n            pos += CraftingRecipe.computeBytesConsumed(buf, pos);\n            if (obj.known.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"known\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateKnownRecipes deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateKnownRecipes obj = new UpdateKnownRecipes();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int knownCount = VarInt.peek(buf, pos);\n         if (knownCount < 0) {\n            throw ProtocolException.negativeLength(\"Known\", knownCount);\n         }\n\n         if (knownCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"Known\", knownCount, 4096000);\n         }\n\n         pos += VarInt.size(knownCount);\n         obj.known = new HashMap<>(knownCount);\n\n         for (int i = 0; i < knownCount; i++) {\n            int keyLen = VarInt.peek(buf, pos);\n            if (keyLen < 0) {\n               throw ProtocolException.negativeLength(\"key\", keyLen);\n            }\n\n            if (keyLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"key\", keyLen, 4096000);\n            }\n\n            int keyVarLen = VarInt.length(buf, pos);\n            String key = PacketIO.readVarString(buf, pos);\n            pos += keyVarLen + keyLen;\n            CraftingRecipe val = CraftingRecipe.deserialize(buf, pos);\n            pos += CraftingRecipe.computeBytesConsumed(buf, pos);\n            if (obj.known.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"known\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            int sl = VarInt.peek(buf, pos);\n            pos += VarInt.length(buf, pos) + sl;\n            pos += CraftingRecipe.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int knownCount = VarInt.peek(buffer, pos);\n            if (knownCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for Known\");\n            }\n\n            if (knownCount > 4096000) {\n               return ValidationResult.error(\"Known exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < knownCount; i++) {\n               int keyLen = VarInt.peek(buffer, pos);\n               if (keyLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for key\");\n               }\n\n               if (keyLen > 4096000) {\n                  return ValidationResult.error(\"key exceeds max length 4096000\");\n               }\n\n               pos += VarInt.length(buffer, pos);\n               pos += keyLen;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += CraftingRecipe.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString, CraftingRecipe.deserialize, CraftingRecipe.computeBytesConsumed, obj.known.put, ProtocolException.duplicateKey\n// Types referenced: CraftingRecipe\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdatePortal",
        "packetId": 229,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "state",
            "type": "PortalState",
            "nullable": true
          },
          {
            "name": "definition",
            "type": "PortalDef",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdatePortal\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 229;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 16384020;\n\n// === FIELDS ===\n@Nullable PortalState state;\n@Nullable PortalDef definition;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdatePortal deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdatePortal obj = new UpdatePortal();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.state = PortalState.deserialize(buf, offset + 1);\n      }\n\n      int pos = offset + 6;\n      if ((nullBits & 2) != 0) {\n         obj.definition = PortalDef.deserialize(buf, pos);\n         pos += PortalDef.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdatePortal deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdatePortal obj = new UpdatePortal();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.state = PortalState.deserialize(buf, offset + 1);\n      }\n\n      int pos = offset + 6;\n      if ((nullBits & 2) != 0) {\n         obj.definition = PortalDef.deserialize(buf, pos);\n         pos += PortalDef.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 6;\n      if ((nullBits & 2) != 0) {\n         pos += PortalDef.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 6) {\n         return ValidationResult.error(\"Buffer too small: expected at least 6 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 6;\n         if ((nullBits & 2) != 0) {\n            ValidationResult definitionResult = PortalDef.validateStructure(buffer, pos);\n            if (!definitionResult.isValid()) {\n               return ValidationResult.error(\"Invalid Definition: \" + definitionResult.error());\n            }\n\n            pos += PortalDef.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, PortalState.deserialize, PortalDef.deserialize, PortalDef.computeBytesConsumed\n// Types referenced: PortalState, PortalDef\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateVisibleHudComponents",
        "packetId": 230,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "visibleComponents",
            "type": "HudComponent[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateVisibleHudComponents\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 230;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 4096006;\n\n// === FIELDS ===\n@Nullable HudComponent[] visibleComponents;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateVisibleHudComponents deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateVisibleHudComponents obj = new UpdateVisibleHudComponents();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int visibleComponentsCount = VarInt.peek(buf, pos);\n         if (visibleComponentsCount < 0) {\n            throw ProtocolException.negativeLength(\"VisibleComponents\", visibleComponentsCount);\n         }\n\n         if (visibleComponentsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"VisibleComponents\", visibleComponentsCount, 4096000);\n         }\n\n         int visibleComponentsVarLen = VarInt.size(visibleComponentsCount);\n         if ((long)(pos + visibleComponentsVarLen) + (long)visibleComponentsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"VisibleComponents\", pos + visibleComponentsVarLen + visibleComponentsCount * 1, buf.readableBytes());\n         }\n\n         pos += visibleComponentsVarLen;\n         obj.visibleComponents = new HudComponent[visibleComponentsCount];\n\n         for (int i = 0; i < visibleComponentsCount; i++) {\n            obj.visibleComponents[i] = HudComponent.fromValue(buf.getByte(pos));\n            pos++;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int visibleComponentsCount = VarInt.peek(buffer, pos);\n            if (visibleComponentsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for VisibleComponents\");\n            }\n\n            if (visibleComponentsCount > 4096000) {\n               return ValidationResult.error(\"VisibleComponents exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += visibleComponentsCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading VisibleComponents\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, HudComponent.fromValue\n// Types referenced: HudComponent\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ResetUserInterfaceState",
        "packetId": 231,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [],
        "deserializeContext": "// Packet: ResetUserInterfaceState\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 231;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ResetUserInterfaceState deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new ResetUserInterfaceState();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateLanguage",
        "packetId": 232,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "language",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateLanguage\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 232;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String language;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateLanguage deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateLanguage obj = new UpdateLanguage();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int languageLen = VarInt.peek(buf, pos);\n         if (languageLen < 0) {\n            throw ProtocolException.negativeLength(\"Language\", languageLen);\n         }\n\n         if (languageLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Language\", languageLen, 4096000);\n         }\n\n         int languageVarLen = VarInt.length(buf, pos);\n         obj.language = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += languageVarLen + languageLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int languageLen = VarInt.peek(buffer, pos);\n            if (languageLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Language\");\n            }\n\n            if (languageLen > 4096000) {\n               return ValidationResult.error(\"Language exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += languageLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Language\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "WorldSavingStatus",
        "packetId": 233,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "isWorldSaving",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: WorldSavingStatus\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 233;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean isWorldSaving;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static WorldSavingStatus deserialize(@Nonnull ByteBuf buf, int offset) {\n      WorldSavingStatus obj = new WorldSavingStatus();\n      obj.isWorldSaving = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "OpenChatWithCommand",
        "packetId": 234,
        "package": "com.hypixel.hytale.protocol.packets.interface_",
        "fields": [
          {
            "name": "command",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: OpenChatWithCommand\n// Package: com.hypixel.hytale.protocol.packets.interface_\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 234;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String command;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static OpenChatWithCommand deserialize(@Nonnull ByteBuf buf, int offset) {\n      OpenChatWithCommand obj = new OpenChatWithCommand();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int commandLen = VarInt.peek(buf, pos);\n         if (commandLen < 0) {\n            throw ProtocolException.negativeLength(\"Command\", commandLen);\n         }\n\n         if (commandLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Command\", commandLen, 4096000);\n         }\n\n         int commandVarLen = VarInt.length(buf, pos);\n         obj.command = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += commandVarLen + commandLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int commandLen = VarInt.peek(buffer, pos);\n            if (commandLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Command\");\n            }\n\n            if (commandLen > 4096000) {\n               return ValidationResult.error(\"Command exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += commandLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Command\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "worldmap": [
      {
        "name": "MapChunk",
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [
          {
            "name": "chunkX",
            "type": "int",
            "nullable": false
          },
          {
            "name": "chunkZ",
            "type": "int",
            "nullable": false
          },
          {
            "name": "image",
            "type": "MapImage",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: MapChunk\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 16384023;\n\n// === FIELDS ===\n@Nonnull int chunkX;\n@Nonnull int chunkZ;\n@Nullable MapImage image;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static MapChunk deserialize(@Nonnull ByteBuf buf, int offset) {\n      MapChunk obj = new MapChunk();\n      byte nullBits = buf.getByte(offset);\n      obj.chunkX = buf.getIntLE(offset + 1);\n      obj.chunkZ = buf.getIntLE(offset + 5);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         obj.image = MapImage.deserialize(buf, pos);\n         pos += MapImage.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static MapChunk deserialize(@Nonnull ByteBuf buf, int offset) {\n      MapChunk obj = new MapChunk();\n      byte nullBits = buf.getByte(offset);\n      obj.chunkX = buf.getIntLE(offset + 1);\n      obj.chunkZ = buf.getIntLE(offset + 5);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         obj.image = MapImage.deserialize(buf, pos);\n         pos += MapImage.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         pos += MapImage.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 9;\n         if ((nullBits & 1) != 0) {\n            ValidationResult imageResult = MapImage.validateStructure(buffer, pos);\n            if (!imageResult.isValid()) {\n               return ValidationResult.error(\"Invalid Image: \" + imageResult.error());\n            }\n\n            pos += MapImage.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, MapImage.deserialize, MapImage.computeBytesConsumed\n// Types referenced: MapImage\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ContextMenuItem",
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [
          {
            "name": "name",
            "type": "String",
            "nullable": false
          },
          {
            "name": "command",
            "type": "String",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ContextMenuItem\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 8;\npublic static final int MAX_SIZE = 32768018;\n\n// === FIELDS ===\n@Nonnull String name;\n@Nonnull String command;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ContextMenuItem deserialize(@Nonnull ByteBuf buf, int offset) {\n      ContextMenuItem obj = new ContextMenuItem();\n      int varPos0 = offset + 8 + buf.getIntLE(offset + 0);\n      int nameLen = VarInt.peek(buf, varPos0);\n      if (nameLen < 0) {\n         throw ProtocolException.negativeLength(\"Name\", nameLen);\n      } else if (nameLen > 4096000) {\n         throw ProtocolException.stringTooLong(\"Name\", nameLen, 4096000);\n      } else {\n         obj.name = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n         varPos0 = offset + 8 + buf.getIntLE(offset + 4);\n         nameLen = VarInt.peek(buf, varPos0);\n         if (nameLen < 0) {\n            throw ProtocolException.negativeLength(\"Command\", nameLen);\n         } else if (nameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Command\", nameLen, 4096000);\n         } else {\n            obj.command = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n            return obj;\n         }\n      }\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int maxEnd = 8;\n      int fieldOffset0 = buf.getIntLE(offset + 0);\n      int pos0 = offset + 8 + fieldOffset0;\n      int sl = VarInt.peek(buf, pos0);\n      pos0 += VarInt.length(buf, pos0) + sl;\n      if (pos0 - offset > maxEnd) {\n         maxEnd = pos0 - offset;\n      }\n\n      fieldOffset0 = buf.getIntLE(offset + 4);\n      pos0 = offset + 8 + fieldOffset0;\n      sl = VarInt.peek(buf, pos0);\n      pos0 += VarInt.length(buf, pos0) + sl;\n      if (pos0 - offset > maxEnd) {\n         maxEnd = pos0 - offset;\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 8) {\n         return ValidationResult.error(\"Buffer too small: expected at least 8 bytes\");\n      } else {\n         int nameOffset = buffer.getIntLE(offset + 0);\n         if (nameOffset < 0) {\n            return ValidationResult.error(\"Invalid offset for Name\");\n         } else {\n            int pos = offset + 8 + nameOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Name\");\n            } else {\n               int nameLen = VarInt.peek(buffer, pos);\n               if (nameLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for Name\");\n               } else if (nameLen > 4096000) {\n                  return ValidationResult.error(\"Name exceeds max length 4096000\");\n               } else {\n                  pos += VarInt.length(buffer, pos);\n                  pos += nameLen;\n                  if (pos > buffer.writerIndex()) {\n                     return ValidationResult.error(\"Buffer overflow reading Name\");\n                  } else {\n                     nameOffset = buffer.getIntLE(offset + 4);\n                     if (nameOffset < 0) {\n                        return ValidationResult.error(\"Invalid offset for Command\");\n                     } else {\n                        pos = offset + 8 + nameOffset;\n                        if (pos >= buffer.writerIndex()) {\n                           return ValidationResult.error(\"Offset out of bounds for Command\");\n                        } else {\n                           nameLen = VarInt.peek(buffer, pos);\n                           if (nameLen < 0) {\n                              return ValidationResult.error(\"Invalid string length for Command\");\n                           } else if (nameLen > 4096000) {\n                              return ValidationResult.error(\"Command exceeds max length 4096000\");\n                           } else {\n                              pos += VarInt.length(buffer, pos);\n                              pos += nameLen;\n                              return pos > buffer.writerIndex() ? ValidationResult.error(\"Buffer overflow reading Command\") : ValidationResult.OK;\n                           }\n                        }\n                     }\n                  }\n               }\n            }\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "MapImage",
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [
          {
            "name": "width",
            "type": "int",
            "nullable": false
          },
          {
            "name": "height",
            "type": "int",
            "nullable": false
          },
          {
            "name": "data",
            "type": "int[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: MapImage\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 16384014;\n\n// === FIELDS ===\n@Nonnull int width;\n@Nonnull int height;\n@Nullable int[] data;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static MapImage deserialize(@Nonnull ByteBuf buf, int offset) {\n      MapImage obj = new MapImage();\n      byte nullBits = buf.getByte(offset);\n      obj.width = buf.getIntLE(offset + 1);\n      obj.height = buf.getIntLE(offset + 5);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int dataCount = VarInt.peek(buf, pos);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096000);\n         }\n\n         int dataVarLen = VarInt.size(dataCount);\n         if ((long)(pos + dataVarLen) + (long)dataCount * 4L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", pos + dataVarLen + dataCount * 4, buf.readableBytes());\n         }\n\n         pos += dataVarLen;\n         obj.data = new int[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getIntLE(pos + i * 4);\n         }\n\n         pos += dataCount * 4;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 4;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 9;\n         if ((nullBits & 1) != 0) {\n            int dataCount = VarInt.peek(buffer, pos);\n            if (dataCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Data\");\n            }\n\n            if (dataCount > 4096000) {\n               return ValidationResult.error(\"Data exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += dataCount * 4;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Data\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "BiomeData",
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [
          {
            "name": "zoneId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "zoneName",
            "type": "String",
            "nullable": true
          },
          {
            "name": "biomeName",
            "type": "String",
            "nullable": true
          },
          {
            "name": "biomeColor",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: BiomeData\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 17;\npublic static final int MAX_SIZE = 32768027;\n\n// === FIELDS ===\n@Nonnull int zoneId;\n@Nullable String zoneName;\n@Nullable String biomeName;\n@Nonnull int biomeColor;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static BiomeData deserialize(@Nonnull ByteBuf buf, int offset) {\n      BiomeData obj = new BiomeData();\n      byte nullBits = buf.getByte(offset);\n      obj.zoneId = buf.getIntLE(offset + 1);\n      obj.biomeColor = buf.getIntLE(offset + 5);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 17 + buf.getIntLE(offset + 9);\n         int zoneNameLen = VarInt.peek(buf, varPos0);\n         if (zoneNameLen < 0) {\n            throw ProtocolException.negativeLength(\"ZoneName\", zoneNameLen);\n         }\n\n         if (zoneNameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ZoneName\", zoneNameLen, 4096000);\n         }\n\n         obj.zoneName = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 17 + buf.getIntLE(offset + 13);\n         int biomeNameLen = VarInt.peek(buf, varPos1);\n         if (biomeNameLen < 0) {\n            throw ProtocolException.negativeLength(\"BiomeName\", biomeNameLen);\n         }\n\n         if (biomeNameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"BiomeName\", biomeNameLen, 4096000);\n         }\n\n         obj.biomeName = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 17;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 9);\n         int pos0 = offset + 17 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 13);\n         int pos1 = offset + 17 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 17) {\n         return ValidationResult.error(\"Buffer too small: expected at least 17 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int zoneNameOffset = buffer.getIntLE(offset + 9);\n            if (zoneNameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ZoneName\");\n            }\n\n            int pos = offset + 17 + zoneNameOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ZoneName\");\n            }\n\n            int zoneNameLen = VarInt.peek(buffer, pos);\n            if (zoneNameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ZoneName\");\n            }\n\n            if (zoneNameLen > 4096000) {\n               return ValidationResult.error(\"ZoneName exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += zoneNameLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ZoneName\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int biomeNameOffset = buffer.getIntLE(offset + 13);\n            if (biomeNameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for BiomeName\");\n            }\n\n            int posx = offset + 17 + biomeNameOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for BiomeName\");\n            }\n\n            int biomeNameLen = VarInt.peek(buffer, posx);\n            if (biomeNameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for BiomeName\");\n            }\n\n            if (biomeNameLen > 4096000) {\n               return ValidationResult.error(\"BiomeName exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += biomeNameLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading BiomeName\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "MapMarker",
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [
          {
            "name": "id",
            "type": "String",
            "nullable": true
          },
          {
            "name": "name",
            "type": "String",
            "nullable": true
          },
          {
            "name": "markerImage",
            "type": "String",
            "nullable": true
          },
          {
            "name": "transform",
            "type": "Transform",
            "nullable": true
          },
          {
            "name": "contextMenuItems",
            "type": "ContextMenuItem[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: MapMarker\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 38;\npublic static final int VARIABLE_FIELD_COUNT = 4;\npublic static final int VARIABLE_BLOCK_START = 54;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable String id;\n@Nullable String name;\n@Nullable String markerImage;\n@Nullable Transform transform;\n@Nullable ContextMenuItem[] contextMenuItems;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static MapMarker deserialize(@Nonnull ByteBuf buf, int offset) {\n      MapMarker obj = new MapMarker();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 8) != 0) {\n         obj.transform = Transform.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 54 + buf.getIntLE(offset + 38);\n         int idLen = VarInt.peek(buf, varPos0);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         obj.id = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 54 + buf.getIntLE(offset + 42);\n         int nameLen = VarInt.peek(buf, varPos1);\n         if (nameLen < 0) {\n            throw ProtocolException.negativeLength(\"Name\", nameLen);\n         }\n\n         if (nameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Name\", nameLen, 4096000);\n         }\n\n         obj.name = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 54 + buf.getIntLE(offset + 46);\n         int markerImageLen = VarInt.peek(buf, varPos2);\n         if (markerImageLen < 0) {\n            throw ProtocolException.negativeLength(\"MarkerImage\", markerImageLen);\n         }\n\n         if (markerImageLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"MarkerImage\", markerImageLen, 4096000);\n         }\n\n         obj.markerImage = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 16) != 0) {\n         int varPos3 = offset + 54 + buf.getIntLE(offset + 50);\n         int contextMenuItemsCount = VarInt.peek(buf, varPos3);\n         if (contextMenuItemsCount < 0) {\n            throw ProtocolException.negativeLength(\"ContextMenuItems\", contextMenuItemsCount);\n         }\n\n         if (contextMenuItemsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"ContextMenuItems\", contextMenuItemsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos3);\n         if ((long)(varPos3 + varIntLen) + (long)contextMenuItemsCount * 0L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"ContextMenuItems\", varPos3 + varIntLen + contextMenuItemsCount * 0, buf.readableBytes());\n         }\n\n         obj.contextMenuItems = new ContextMenuItem[contextMenuItemsCount];\n         int elemPos = varPos3 + varIntLen;\n\n         for (int i = 0; i < contextMenuItemsCount; i++) {\n            obj.contextMenuItems[i] = ContextMenuItem.deserialize(buf, elemPos);\n            elemPos += ContextMenuItem.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static MapMarker deserialize(@Nonnull ByteBuf buf, int offset) {\n      MapMarker obj = new MapMarker();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 8) != 0) {\n         obj.transform = Transform.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 54 + buf.getIntLE(offset + 38);\n         int idLen = VarInt.peek(buf, varPos0);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         obj.id = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 54 + buf.getIntLE(offset + 42);\n         int nameLen = VarInt.peek(buf, varPos1);\n         if (nameLen < 0) {\n            throw ProtocolException.negativeLength(\"Name\", nameLen);\n         }\n\n         if (nameLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Name\", nameLen, 4096000);\n         }\n\n         obj.name = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 54 + buf.getIntLE(offset + 46);\n         int markerImageLen = VarInt.peek(buf, varPos2);\n         if (markerImageLen < 0) {\n            throw ProtocolException.negativeLength(\"MarkerImage\", markerImageLen);\n         }\n\n         if (markerImageLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"MarkerImage\", markerImageLen, 4096000);\n         }\n\n         obj.markerImage = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 16) != 0) {\n         int varPos3 = offset + 54 + buf.getIntLE(offset + 50);\n         int contextMenuItemsCount = VarInt.peek(buf, varPos3);\n         if (contextMenuItemsCount < 0) {\n            throw ProtocolException.negativeLength(\"ContextMenuItems\", contextMenuItemsCount);\n         }\n\n         if (contextMenuItemsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"ContextMenuItems\", contextMenuItemsCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos3);\n         if ((long)(varPos3 + varIntLen) + (long)contextMenuItemsCount * 0L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"ContextMenuItems\", varPos3 + varIntLen + contextMenuItemsCount * 0, buf.readableBytes());\n         }\n\n         obj.contextMenuItems = new ContextMenuItem[contextMenuItemsCount];\n         int elemPos = varPos3 + varIntLen;\n\n         for (int i = 0; i < contextMenuItemsCount; i++) {\n            obj.contextMenuItems[i] = ContextMenuItem.deserialize(buf, elemPos);\n            elemPos += ContextMenuItem.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 54;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 38);\n         int pos0 = offset + 54 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 42);\n         int pos1 = offset + 54 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 46);\n         int pos2 = offset + 54 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      if ((nullBits & 16) != 0) {\n         int fieldOffset3 = buf.getIntLE(offset + 50);\n         int pos3 = offset + 54 + fieldOffset3;\n         int arrLen = VarInt.peek(buf, pos3);\n         pos3 += VarInt.length(buf, pos3);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos3 += ContextMenuItem.computeBytesConsumed(buf, pos3);\n         }\n\n         if (pos3 - offset > maxEnd) {\n            maxEnd = pos3 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 54) {\n         return ValidationResult.error(\"Buffer too small: expected at least 54 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int idOffset = buffer.getIntLE(offset + 38);\n            if (idOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Id\");\n            }\n\n            int pos = offset + 54 + idOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Id\");\n            }\n\n            int idLen = VarInt.peek(buffer, pos);\n            if (idLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Id\");\n            }\n\n            if (idLen > 4096000) {\n               return ValidationResult.error(\"Id exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += idLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Id\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int nameOffset = buffer.getIntLE(offset + 42);\n            if (nameOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Name\");\n            }\n\n            int posx = offset + 54 + nameOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Name\");\n            }\n\n            int nameLen = VarInt.peek(buffer, posx);\n            if (nameLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Name\");\n            }\n\n            if (nameLen > 4096000) {\n               return ValidationResult.error(\"Name exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += nameLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Name\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int markerImageOffset = buffer.getIntLE(offset + 46);\n            if (markerImageOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for MarkerImage\");\n            }\n\n            int posxx = offset + 54 + markerImageOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for MarkerImage\");\n            }\n\n            int markerImageLen = VarInt.peek(buffer, posxx);\n            if (markerImageLen < 0) {\n               return ValidationResult.error(\"Invalid string length for MarkerImage\");\n            }\n\n            if (markerImageLen > 4096000) {\n               return ValidationResult.error(\"MarkerImage exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += markerImageLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading MarkerImage\");\n            }\n         }\n\n         if ((nullBits & 16) != 0) {\n            int contextMenuItemsOffset = buffer.getIntLE(offset + 50);\n            if (contextMenuItemsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ContextMenuItems\");\n            }\n\n            int posxxx = offset + 54 + contextMenuItemsOffset;\n            if (posxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ContextMenuItems\");\n            }\n\n            int contextMenuItemsCount = VarInt.peek(buffer, posxxx);\n            if (contextMenuItemsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for ContextMenuItems\");\n            }\n\n            if (contextMenuItemsCount > 4096000) {\n               return ValidationResult.error(\"ContextMenuItems exceeds max length 4096000\");\n            }\n\n            posxxx += VarInt.length(buffer, posxxx);\n\n            for (int i = 0; i < contextMenuItemsCount; i++) {\n               ValidationResult structResult = ContextMenuItem.validateStructure(buffer, posxxx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid ContextMenuItem in ContextMenuItems[\" + i + \"]: \" + structResult.error());\n               }\n\n               posxxx += ContextMenuItem.computeBytesConsumed(buffer, posxxx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, Transform.deserialize, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, ContextMenuItem.deserialize, ContextMenuItem.computeBytesConsumed\n// Types referenced: Transform, ContextMenuItem\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateWorldMapSettings",
        "packetId": 240,
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [
          {
            "name": "enabled",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "biomeDataMap",
            "type": "Map<Short, BiomeData>",
            "nullable": true
          },
          {
            "name": "allowTeleportToCoordinates",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "allowTeleportToMarkers",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "defaultScale",
            "type": "float",
            "nullable": false
          },
          {
            "name": "minScale",
            "type": "float",
            "nullable": false
          },
          {
            "name": "maxScale",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateWorldMapSettings\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 240;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 16;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 16;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull boolean enabled;\n@Nullable Map<Short, BiomeData> biomeDataMap;\n@Nonnull boolean allowTeleportToCoordinates;\n@Nonnull boolean allowTeleportToMarkers;\n@Nonnull float defaultScale;\n@Nonnull float minScale;\n@Nonnull float maxScale;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateWorldMapSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateWorldMapSettings obj = new UpdateWorldMapSettings();\n      byte nullBits = buf.getByte(offset);\n      obj.enabled = buf.getByte(offset + 1) != 0;\n      obj.allowTeleportToCoordinates = buf.getByte(offset + 2) != 0;\n      obj.allowTeleportToMarkers = buf.getByte(offset + 3) != 0;\n      obj.defaultScale = buf.getFloatLE(offset + 4);\n      obj.minScale = buf.getFloatLE(offset + 8);\n      obj.maxScale = buf.getFloatLE(offset + 12);\n      int pos = offset + 16;\n      if ((nullBits & 1) != 0) {\n         int biomeDataMapCount = VarInt.peek(buf, pos);\n         if (biomeDataMapCount < 0) {\n            throw ProtocolException.negativeLength(\"BiomeDataMap\", biomeDataMapCount);\n         }\n\n         if (biomeDataMapCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BiomeDataMap\", biomeDataMapCount, 4096000);\n         }\n\n         pos += VarInt.size(biomeDataMapCount);\n         obj.biomeDataMap = new HashMap<>(biomeDataMapCount);\n\n         for (int i = 0; i < biomeDataMapCount; i++) {\n            short key = buf.getShortLE(pos);\n            pos += 2;\n            BiomeData val = BiomeData.deserialize(buf, pos);\n            pos += BiomeData.computeBytesConsumed(buf, pos);\n            if (obj.biomeDataMap.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"biomeDataMap\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateWorldMapSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateWorldMapSettings obj = new UpdateWorldMapSettings();\n      byte nullBits = buf.getByte(offset);\n      obj.enabled = buf.getByte(offset + 1) != 0;\n      obj.allowTeleportToCoordinates = buf.getByte(offset + 2) != 0;\n      obj.allowTeleportToMarkers = buf.getByte(offset + 3) != 0;\n      obj.defaultScale = buf.getFloatLE(offset + 4);\n      obj.minScale = buf.getFloatLE(offset + 8);\n      obj.maxScale = buf.getFloatLE(offset + 12);\n      int pos = offset + 16;\n      if ((nullBits & 1) != 0) {\n         int biomeDataMapCount = VarInt.peek(buf, pos);\n         if (biomeDataMapCount < 0) {\n            throw ProtocolException.negativeLength(\"BiomeDataMap\", biomeDataMapCount);\n         }\n\n         if (biomeDataMapCount > 4096000) {\n            throw ProtocolException.dictionaryTooLarge(\"BiomeDataMap\", biomeDataMapCount, 4096000);\n         }\n\n         pos += VarInt.size(biomeDataMapCount);\n         obj.biomeDataMap = new HashMap<>(biomeDataMapCount);\n\n         for (int i = 0; i < biomeDataMapCount; i++) {\n            short key = buf.getShortLE(pos);\n            pos += 2;\n            BiomeData val = BiomeData.deserialize(buf, pos);\n            pos += BiomeData.computeBytesConsumed(buf, pos);\n            if (obj.biomeDataMap.put(key, val) != null) {\n               throw ProtocolException.duplicateKey(\"biomeDataMap\", key);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 16;\n      if ((nullBits & 1) != 0) {\n         int dictLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos);\n\n         for (int i = 0; i < dictLen; i++) {\n            pos += 2;\n            pos += BiomeData.computeBytesConsumed(buf, pos);\n         }\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 16) {\n         return ValidationResult.error(\"Buffer too small: expected at least 16 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 16;\n         if ((nullBits & 1) != 0) {\n            int biomeDataMapCount = VarInt.peek(buffer, pos);\n            if (biomeDataMapCount < 0) {\n               return ValidationResult.error(\"Invalid dictionary count for BiomeDataMap\");\n            }\n\n            if (biomeDataMapCount > 4096000) {\n               return ValidationResult.error(\"BiomeDataMap exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < biomeDataMapCount; i++) {\n               pos += 2;\n               if (pos > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading key\");\n               }\n\n               pos += BiomeData.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getFloatLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.dictionaryTooLarge, VarInt.size, buf.getShortLE, BiomeData.deserialize, BiomeData.computeBytesConsumed, obj.biomeDataMap.put, ProtocolException.duplicateKey\n// Types referenced: BiomeData\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateWorldMap",
        "packetId": 241,
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [
          {
            "name": "chunks",
            "type": "MapChunk[]",
            "nullable": true
          },
          {
            "name": "addedMarkers",
            "type": "MapMarker[]",
            "nullable": true
          },
          {
            "name": "removedMarkers",
            "type": "String[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateWorldMap\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 241;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable MapChunk[] chunks;\n@Nullable MapMarker[] addedMarkers;\n@Nullable String[] removedMarkers;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateWorldMap deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateWorldMap obj = new UpdateWorldMap();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 1);\n         int chunksCount = VarInt.peek(buf, varPos0);\n         if (chunksCount < 0) {\n            throw ProtocolException.negativeLength(\"Chunks\", chunksCount);\n         }\n\n         if (chunksCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Chunks\", chunksCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)chunksCount * 9L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Chunks\", varPos0 + varIntLen + chunksCount * 9, buf.readableBytes());\n         }\n\n         obj.chunks = new MapChunk[chunksCount];\n         int elemPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < chunksCount; i++) {\n            obj.chunks[i] = MapChunk.deserialize(buf, elemPos);\n            elemPos += MapChunk.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 5);\n         int addedMarkersCount = VarInt.peek(buf, varPos1);\n         if (addedMarkersCount < 0) {\n            throw ProtocolException.negativeLength(\"AddedMarkers\", addedMarkersCount);\n         }\n\n         if (addedMarkersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"AddedMarkers\", addedMarkersCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)addedMarkersCount * 38L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"AddedMarkers\", varPos1 + varIntLen + addedMarkersCount * 38, buf.readableBytes());\n         }\n\n         obj.addedMarkers = new MapMarker[addedMarkersCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < addedMarkersCount; i++) {\n            obj.addedMarkers[i] = MapMarker.deserialize(buf, elemPos);\n            elemPos += MapMarker.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 13 + buf.getIntLE(offset + 9);\n         int removedMarkersCount = VarInt.peek(buf, varPos2);\n         if (removedMarkersCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedMarkers\", removedMarkersCount);\n         }\n\n         if (removedMarkersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedMarkers\", removedMarkersCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)removedMarkersCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedMarkers\", varPos2 + varIntLen + removedMarkersCount * 1, buf.readableBytes());\n         }\n\n         obj.removedMarkers = new String[removedMarkersCount];\n         int elemPos = varPos2 + varIntLen;\n\n         for (int i = 0; i < removedMarkersCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedMarkers[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedMarkers[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedMarkers[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateWorldMap deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateWorldMap obj = new UpdateWorldMap();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 13 + buf.getIntLE(offset + 1);\n         int chunksCount = VarInt.peek(buf, varPos0);\n         if (chunksCount < 0) {\n            throw ProtocolException.negativeLength(\"Chunks\", chunksCount);\n         }\n\n         if (chunksCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Chunks\", chunksCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)chunksCount * 9L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Chunks\", varPos0 + varIntLen + chunksCount * 9, buf.readableBytes());\n         }\n\n         obj.chunks = new MapChunk[chunksCount];\n         int elemPos = varPos0 + varIntLen;\n\n         for (int i = 0; i < chunksCount; i++) {\n            obj.chunks[i] = MapChunk.deserialize(buf, elemPos);\n            elemPos += MapChunk.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 13 + buf.getIntLE(offset + 5);\n         int addedMarkersCount = VarInt.peek(buf, varPos1);\n         if (addedMarkersCount < 0) {\n            throw ProtocolException.negativeLength(\"AddedMarkers\", addedMarkersCount);\n         }\n\n         if (addedMarkersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"AddedMarkers\", addedMarkersCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)addedMarkersCount * 38L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"AddedMarkers\", varPos1 + varIntLen + addedMarkersCount * 38, buf.readableBytes());\n         }\n\n         obj.addedMarkers = new MapMarker[addedMarkersCount];\n         int elemPos = varPos1 + varIntLen;\n\n         for (int i = 0; i < addedMarkersCount; i++) {\n            obj.addedMarkers[i] = MapMarker.deserialize(buf, elemPos);\n            elemPos += MapMarker.computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 13 + buf.getIntLE(offset + 9);\n         int removedMarkersCount = VarInt.peek(buf, varPos2);\n         if (removedMarkersCount < 0) {\n            throw ProtocolException.negativeLength(\"RemovedMarkers\", removedMarkersCount);\n         }\n\n         if (removedMarkersCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"RemovedMarkers\", removedMarkersCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)removedMarkersCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"RemovedMarkers\", varPos2 + varIntLen + removedMarkersCount * 1, buf.readableBytes());\n         }\n\n         obj.removedMarkers = new String[removedMarkersCount];\n         int elemPos = varPos2 + varIntLen;\n\n         for (int i = 0; i < removedMarkersCount; i++) {\n            int strLen = VarInt.peek(buf, elemPos);\n            if (strLen < 0) {\n               throw ProtocolException.negativeLength(\"removedMarkers[\" + i + \"]\", strLen);\n            }\n\n            if (strLen > 4096000) {\n               throw ProtocolException.stringTooLong(\"removedMarkers[\" + i + \"]\", strLen, 4096000);\n            }\n\n            int strVarLen = VarInt.length(buf, elemPos);\n            obj.removedMarkers[i] = PacketIO.readVarString(buf, elemPos);\n            elemPos += strVarLen + strLen;\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 13;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 1);\n         int pos0 = offset + 13 + fieldOffset0;\n         int arrLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos0 += MapChunk.computeBytesConsumed(buf, pos0);\n         }\n\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 5);\n         int pos1 = offset + 13 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos1 += MapMarker.computeBytesConsumed(buf, pos1);\n         }\n\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 9);\n         int pos2 = offset + 13 + fieldOffset2;\n         int arrLen = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2);\n\n         for (int i = 0; i < arrLen; i++) {\n            int sl = VarInt.peek(buf, pos2);\n            pos2 += VarInt.length(buf, pos2) + sl;\n         }\n\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int chunksOffset = buffer.getIntLE(offset + 1);\n            if (chunksOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Chunks\");\n            }\n\n            int pos = offset + 13 + chunksOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Chunks\");\n            }\n\n            int chunksCount = VarInt.peek(buffer, pos);\n            if (chunksCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Chunks\");\n            }\n\n            if (chunksCount > 4096000) {\n               return ValidationResult.error(\"Chunks exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < chunksCount; i++) {\n               ValidationResult structResult = MapChunk.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid MapChunk in Chunks[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += MapChunk.computeBytesConsumed(buffer, pos);\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int addedMarkersOffset = buffer.getIntLE(offset + 5);\n            if (addedMarkersOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for AddedMarkers\");\n            }\n\n            int posx = offset + 13 + addedMarkersOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for AddedMarkers\");\n            }\n\n            int addedMarkersCount = VarInt.peek(buffer, posx);\n            if (addedMarkersCount < 0) {\n               return ValidationResult.error(\"Invalid array count for AddedMarkers\");\n            }\n\n            if (addedMarkersCount > 4096000) {\n               return ValidationResult.error(\"AddedMarkers exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n\n            for (int i = 0; i < addedMarkersCount; i++) {\n               ValidationResult structResult = MapMarker.validateStructure(buffer, posx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid MapMarker in AddedMarkers[\" + i + \"]: \" + structResult.error());\n               }\n\n               posx += MapMarker.computeBytesConsumed(buffer, posx);\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int removedMarkersOffset = buffer.getIntLE(offset + 9);\n            if (removedMarkersOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for RemovedMarkers\");\n            }\n\n            int posxx = offset + 13 + removedMarkersOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for RemovedMarkers\");\n            }\n\n            int removedMarkersCount = VarInt.peek(buffer, posxx);\n            if (removedMarkersCount < 0) {\n               return ValidationResult.error(\"Invalid array count for RemovedMarkers\");\n            }\n\n            if (removedMarkersCount > 4096000) {\n               return ValidationResult.error(\"RemovedMarkers exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n\n            for (int i = 0; i < removedMarkersCount; i++) {\n               int strLen = VarInt.peek(buffer, posxx);\n               if (strLen < 0) {\n                  return ValidationResult.error(\"Invalid string length in RemovedMarkers\");\n               }\n\n               posxx += VarInt.length(buffer, posxx);\n               posxx += strLen;\n               if (posxx > buffer.writerIndex()) {\n                  return ValidationResult.error(\"Buffer overflow reading string in RemovedMarkers\");\n               }\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, MapChunk.deserialize, MapChunk.computeBytesConsumed, MapMarker.deserialize, MapMarker.computeBytesConsumed, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: MapChunk, MapMarker\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ClearWorldMap",
        "packetId": 242,
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [],
        "deserializeContext": "// Packet: ClearWorldMap\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 242;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ClearWorldMap deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new ClearWorldMap();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateWorldMapVisible",
        "packetId": 243,
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [
          {
            "name": "visible",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateWorldMapVisible\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 243;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean visible;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateWorldMapVisible deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateWorldMapVisible obj = new UpdateWorldMapVisible();\n      obj.visible = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "TeleportToWorldMapMarker",
        "packetId": 244,
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [
          {
            "name": "id",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: TeleportToWorldMapMarker\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 244;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String id;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static TeleportToWorldMapMarker deserialize(@Nonnull ByteBuf buf, int offset) {\n      TeleportToWorldMapMarker obj = new TeleportToWorldMapMarker();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int idLen = VarInt.peek(buf, pos);\n         if (idLen < 0) {\n            throw ProtocolException.negativeLength(\"Id\", idLen);\n         }\n\n         if (idLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"Id\", idLen, 4096000);\n         }\n\n         int idVarLen = VarInt.length(buf, pos);\n         obj.id = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += idVarLen + idLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int idLen = VarInt.peek(buffer, pos);\n            if (idLen < 0) {\n               return ValidationResult.error(\"Invalid string length for Id\");\n            }\n\n            if (idLen > 4096000) {\n               return ValidationResult.error(\"Id exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += idLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Id\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "TeleportToWorldMapPosition",
        "packetId": 245,
        "package": "com.hypixel.hytale.protocol.packets.worldmap",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: TeleportToWorldMapPosition\n// Package: com.hypixel.hytale.protocol.packets.worldmap\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 245;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 8;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 8;\npublic static final int MAX_SIZE = 8;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static TeleportToWorldMapPosition deserialize(@Nonnull ByteBuf buf, int offset) {\n      TeleportToWorldMapPosition obj = new TeleportToWorldMapPosition();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 8;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 8 ? ValidationResult.error(\"Buffer too small: expected at least 8 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "window": [
      {
        "name": "SortItemsAction",
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "sortType",
            "type": "SortType",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SortItemsAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull SortType sortType;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SortItemsAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      SortItemsAction obj = new SortItemsAction();\n      obj.sortType = SortType.fromValue(buf.getByte(offset + 0));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: SortType.fromValue, buf.getByte\n// Types referenced: SortType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateCategoryAction",
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "category",
            "type": "String",
            "nullable": false
          },
          {
            "name": "itemCategory",
            "type": "String",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateCategoryAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 8;\npublic static final int MAX_SIZE = 32768018;\n\n// === FIELDS ===\n@Nonnull String category;\n@Nonnull String itemCategory;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateCategoryAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateCategoryAction obj = new UpdateCategoryAction();\n      int varPos0 = offset + 8 + buf.getIntLE(offset + 0);\n      int categoryLen = VarInt.peek(buf, varPos0);\n      if (categoryLen < 0) {\n         throw ProtocolException.negativeLength(\"Category\", categoryLen);\n      } else if (categoryLen > 4096000) {\n         throw ProtocolException.stringTooLong(\"Category\", categoryLen, 4096000);\n      } else {\n         obj.category = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n         varPos0 = offset + 8 + buf.getIntLE(offset + 4);\n         categoryLen = VarInt.peek(buf, varPos0);\n         if (categoryLen < 0) {\n            throw ProtocolException.negativeLength(\"ItemCategory\", categoryLen);\n         } else if (categoryLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ItemCategory\", categoryLen, 4096000);\n         } else {\n            obj.itemCategory = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n            return obj;\n         }\n      }\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int maxEnd = 8;\n      int fieldOffset0 = buf.getIntLE(offset + 0);\n      int pos0 = offset + 8 + fieldOffset0;\n      int sl = VarInt.peek(buf, pos0);\n      pos0 += VarInt.length(buf, pos0) + sl;\n      if (pos0 - offset > maxEnd) {\n         maxEnd = pos0 - offset;\n      }\n\n      fieldOffset0 = buf.getIntLE(offset + 4);\n      pos0 = offset + 8 + fieldOffset0;\n      sl = VarInt.peek(buf, pos0);\n      pos0 += VarInt.length(buf, pos0) + sl;\n      if (pos0 - offset > maxEnd) {\n         maxEnd = pos0 - offset;\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 8) {\n         return ValidationResult.error(\"Buffer too small: expected at least 8 bytes\");\n      } else {\n         int categoryOffset = buffer.getIntLE(offset + 0);\n         if (categoryOffset < 0) {\n            return ValidationResult.error(\"Invalid offset for Category\");\n         } else {\n            int pos = offset + 8 + categoryOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Category\");\n            } else {\n               int categoryLen = VarInt.peek(buffer, pos);\n               if (categoryLen < 0) {\n                  return ValidationResult.error(\"Invalid string length for Category\");\n               } else if (categoryLen > 4096000) {\n                  return ValidationResult.error(\"Category exceeds max length 4096000\");\n               } else {\n                  pos += VarInt.length(buffer, pos);\n                  pos += categoryLen;\n                  if (pos > buffer.writerIndex()) {\n                     return ValidationResult.error(\"Buffer overflow reading Category\");\n                  } else {\n                     categoryOffset = buffer.getIntLE(offset + 4);\n                     if (categoryOffset < 0) {\n                        return ValidationResult.error(\"Invalid offset for ItemCategory\");\n                     } else {\n                        pos = offset + 8 + categoryOffset;\n                        if (pos >= buffer.writerIndex()) {\n                           return ValidationResult.error(\"Offset out of bounds for ItemCategory\");\n                        } else {\n                           categoryLen = VarInt.peek(buffer, pos);\n                           if (categoryLen < 0) {\n                              return ValidationResult.error(\"Invalid string length for ItemCategory\");\n                           } else if (categoryLen > 4096000) {\n                              return ValidationResult.error(\"ItemCategory exceeds max length 4096000\");\n                           } else {\n                              pos += VarInt.length(buffer, pos);\n                              pos += categoryLen;\n                              return pos > buffer.writerIndex() ? ValidationResult.error(\"Buffer overflow reading ItemCategory\") : ValidationResult.OK;\n                           }\n                        }\n                     }\n                  }\n               }\n            }\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetActiveAction",
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "state",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetActiveAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean state;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetActiveAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetActiveAction obj = new SetActiveAction();\n      obj.state = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CraftRecipeAction",
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "recipeId",
            "type": "String",
            "nullable": true
          },
          {
            "name": "quantity",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: CraftRecipeAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 16384010;\n\n// === FIELDS ===\n@Nullable String recipeId;\n@Nonnull int quantity;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CraftRecipeAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      CraftRecipeAction obj = new CraftRecipeAction();\n      byte nullBits = buf.getByte(offset);\n      obj.quantity = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int recipeIdLen = VarInt.peek(buf, pos);\n         if (recipeIdLen < 0) {\n            throw ProtocolException.negativeLength(\"RecipeId\", recipeIdLen);\n         }\n\n         if (recipeIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"RecipeId\", recipeIdLen, 4096000);\n         }\n\n         int recipeIdVarLen = VarInt.length(buf, pos);\n         obj.recipeId = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += recipeIdVarLen + recipeIdLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            int recipeIdLen = VarInt.peek(buffer, pos);\n            if (recipeIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for RecipeId\");\n            }\n\n            if (recipeIdLen > 4096000) {\n               return ValidationResult.error(\"RecipeId exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += recipeIdLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading RecipeId\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CraftItemAction",
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [],
        "deserializeContext": "// Packet: CraftItemAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CraftItemAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new CraftItemAction();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CancelCraftingAction",
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [],
        "deserializeContext": "// Packet: CancelCraftingAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CancelCraftingAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new CancelCraftingAction();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "TierUpgradeAction",
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [],
        "deserializeContext": "// Packet: TierUpgradeAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static TierUpgradeAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new TierUpgradeAction();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "WindowAction",
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [],
        "deserializeContext": "// Packet: WindowAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int MAX_SIZE = 32768023;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static WindowAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      int typeId = VarInt.peek(buf, offset);\n      int typeIdLen = VarInt.length(buf, offset);\n\n      return (WindowAction)(switch (typeId) {\n         case 0 -> CraftRecipeAction.deserialize(buf, offset + typeIdLen);\n         case 1 -> TierUpgradeAction.deserialize(buf, offset + typeIdLen);\n         case 2 -> SelectSlotAction.deserialize(buf, offset + typeIdLen);\n         case 3 -> ChangeBlockAction.deserialize(buf, offset + typeIdLen);\n         case 4 -> SetActiveAction.deserialize(buf, offset + typeIdLen);\n         case 5 -> CraftItemAction.deserialize(buf, offset + typeIdLen);\n         case 6 -> UpdateCategoryAction.deserialize(buf, offset + typeIdLen);\n         case 7 -> CancelCraftingAction.deserialize(buf, offset + typeIdLen);\n         case 8 -> SortItemsAction.deserialize(buf, offset + typeIdLen);\n         default -> throw ProtocolException.unknownPolymorphicType(\"WindowAction\", typeId);\n      });\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static WindowAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      int typeId = VarInt.peek(buf, offset);\n      int typeIdLen = VarInt.length(buf, offset);\n\n      return (WindowAction)(switch (typeId) {\n         case 0 -> CraftRecipeAction.deserialize(buf, offset + typeIdLen);\n         case 1 -> TierUpgradeAction.deserialize(buf, offset + typeIdLen);\n         case 2 -> SelectSlotAction.deserialize(buf, offset + typeIdLen);\n         case 3 -> ChangeBlockAction.deserialize(buf, offset + typeIdLen);\n         case 4 -> SetActiveAction.deserialize(buf, offset + typeIdLen);\n         case 5 -> CraftItemAction.deserialize(buf, offset + typeIdLen);\n         case 6 -> UpdateCategoryAction.deserialize(buf, offset + typeIdLen);\n         case 7 -> CancelCraftingAction.deserialize(buf, offset + typeIdLen);\n         case 8 -> SortItemsAction.deserialize(buf, offset + typeIdLen);\n         default -> throw ProtocolException.unknownPolymorphicType(\"WindowAction\", typeId);\n      });\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int typeId = VarInt.peek(buf, offset);\n      int typeIdLen = VarInt.length(buf, offset);\n\n      return typeIdLen + switch (typeId) {\n         case 0 -> CraftRecipeAction.computeBytesConsumed(buf, offset + typeIdLen);\n         case 1 -> TierUpgradeAction.computeBytesConsumed(buf, offset + typeIdLen);\n         case 2 -> SelectSlotAction.computeBytesConsumed(buf, offset + typeIdLen);\n         case 3 -> ChangeBlockAction.computeBytesConsumed(buf, offset + typeIdLen);\n         case 4 -> SetActiveAction.computeBytesConsumed(buf, offset + typeIdLen);\n         case 5 -> CraftItemAction.computeBytesConsumed(buf, offset + typeIdLen);\n         case 6 -> UpdateCategoryAction.computeBytesConsumed(buf, offset + typeIdLen);\n         case 7 -> CancelCraftingAction.computeBytesConsumed(buf, offset + typeIdLen);\n         case 8 -> SortItemsAction.computeBytesConsumed(buf, offset + typeIdLen);\n         default -> throw ProtocolException.unknownPolymorphicType(\"WindowAction\", typeId);\n      };\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      int typeId = VarInt.peek(buffer, offset);\n      int typeIdLen = VarInt.length(buffer, offset);\n\n      return switch (typeId) {\n         case 0 -> CraftRecipeAction.validateStructure(buffer, offset + typeIdLen);\n         case 1 -> TierUpgradeAction.validateStructure(buffer, offset + typeIdLen);\n         case 2 -> SelectSlotAction.validateStructure(buffer, offset + typeIdLen);\n         case 3 -> ChangeBlockAction.validateStructure(buffer, offset + typeIdLen);\n         case 4 -> SetActiveAction.validateStructure(buffer, offset + typeIdLen);\n         case 5 -> CraftItemAction.validateStructure(buffer, offset + typeIdLen);\n         case 6 -> UpdateCategoryAction.validateStructure(buffer, offset + typeIdLen);\n         case 7 -> CancelCraftingAction.validateStructure(buffer, offset + typeIdLen);\n         case 8 -> SortItemsAction.validateStructure(buffer, offset + typeIdLen);\n         default -> ValidationResult.error(\"Unknown polymorphic type ID \" + typeId + \" for WindowAction\");\n      };\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: VarInt.peek, VarInt.length, CraftRecipeAction.deserialize, TierUpgradeAction.deserialize, SelectSlotAction.deserialize, ChangeBlockAction.deserialize, SetActiveAction.deserialize, CraftItemAction.deserialize, UpdateCategoryAction.deserialize, CancelCraftingAction.deserialize, SortItemsAction.deserialize, ProtocolException.unknownPolymorphicType\n// Types referenced: CraftRecipeAction, TierUpgradeAction, SelectSlotAction, ChangeBlockAction, SetActiveAction, CraftItemAction, UpdateCategoryAction, CancelCraftingAction, SortItemsAction\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ChangeBlockAction",
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "down",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ChangeBlockAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean down;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ChangeBlockAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      ChangeBlockAction obj = new ChangeBlockAction();\n      obj.down = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SelectSlotAction",
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "slot",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SelectSlotAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int slot;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SelectSlotAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      SelectSlotAction obj = new SelectSlotAction();\n      obj.slot = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "OpenWindow",
        "packetId": 200,
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "id",
            "type": "int",
            "nullable": false
          },
          {
            "name": "windowType",
            "type": "WindowType",
            "nullable": false
          },
          {
            "name": "windowData",
            "type": "String",
            "nullable": true
          },
          {
            "name": "inventory",
            "type": "InventorySection",
            "nullable": true
          },
          {
            "name": "extraResources",
            "type": "ExtraResources",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: OpenWindow\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 200;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 18;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int id;\n@Nonnull WindowType windowType;\n@Nullable String windowData;\n@Nullable InventorySection inventory;\n@Nullable ExtraResources extraResources;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static OpenWindow deserialize(@Nonnull ByteBuf buf, int offset) {\n      OpenWindow obj = new OpenWindow();\n      byte nullBits = buf.getByte(offset);\n      obj.id = buf.getIntLE(offset + 1);\n      obj.windowType = WindowType.fromValue(buf.getByte(offset + 5));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 18 + buf.getIntLE(offset + 6);\n         int windowDataLen = VarInt.peek(buf, varPos0);\n         if (windowDataLen < 0) {\n            throw ProtocolException.negativeLength(\"WindowData\", windowDataLen);\n         }\n\n         if (windowDataLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"WindowData\", windowDataLen, 4096000);\n         }\n\n         obj.windowData = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 18 + buf.getIntLE(offset + 10);\n         obj.inventory = InventorySection.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 18 + buf.getIntLE(offset + 14);\n         obj.extraResources = ExtraResources.deserialize(buf, varPos2);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static OpenWindow deserialize(@Nonnull ByteBuf buf, int offset) {\n      OpenWindow obj = new OpenWindow();\n      byte nullBits = buf.getByte(offset);\n      obj.id = buf.getIntLE(offset + 1);\n      obj.windowType = WindowType.fromValue(buf.getByte(offset + 5));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 18 + buf.getIntLE(offset + 6);\n         int windowDataLen = VarInt.peek(buf, varPos0);\n         if (windowDataLen < 0) {\n            throw ProtocolException.negativeLength(\"WindowData\", windowDataLen);\n         }\n\n         if (windowDataLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"WindowData\", windowDataLen, 4096000);\n         }\n\n         obj.windowData = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 18 + buf.getIntLE(offset + 10);\n         obj.inventory = InventorySection.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 18 + buf.getIntLE(offset + 14);\n         obj.extraResources = ExtraResources.deserialize(buf, varPos2);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 18;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 6);\n         int pos0 = offset + 18 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 10);\n         int pos1 = offset + 18 + fieldOffset1;\n         pos1 += InventorySection.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 14);\n         int pos2 = offset + 18 + fieldOffset2;\n         pos2 += ExtraResources.computeBytesConsumed(buf, pos2);\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 18) {\n         return ValidationResult.error(\"Buffer too small: expected at least 18 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int windowDataOffset = buffer.getIntLE(offset + 6);\n            if (windowDataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for WindowData\");\n            }\n\n            int pos = offset + 18 + windowDataOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for WindowData\");\n            }\n\n            int windowDataLen = VarInt.peek(buffer, pos);\n            if (windowDataLen < 0) {\n               return ValidationResult.error(\"Invalid string length for WindowData\");\n            }\n\n            if (windowDataLen > 4096000) {\n               return ValidationResult.error(\"WindowData exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += windowDataLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading WindowData\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int inventoryOffset = buffer.getIntLE(offset + 10);\n            if (inventoryOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Inventory\");\n            }\n\n            int posx = offset + 18 + inventoryOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Inventory\");\n            }\n\n            ValidationResult inventoryResult = InventorySection.validateStructure(buffer, posx);\n            if (!inventoryResult.isValid()) {\n               return ValidationResult.error(\"Invalid Inventory: \" + inventoryResult.error());\n            }\n\n            posx += InventorySection.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int extraResourcesOffset = buffer.getIntLE(offset + 14);\n            if (extraResourcesOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ExtraResources\");\n            }\n\n            int posxx = offset + 18 + extraResourcesOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ExtraResources\");\n            }\n\n            ValidationResult extraResourcesResult = ExtraResources.validateStructure(buffer, posxx);\n            if (!extraResourcesResult.isValid()) {\n               return ValidationResult.error(\"Invalid ExtraResources: \" + extraResourcesResult.error());\n            }\n\n            posxx += ExtraResources.computeBytesConsumed(buffer, posxx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, WindowType.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, InventorySection.deserialize, ExtraResources.deserialize\n// Types referenced: WindowType, InventorySection, ExtraResources\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateWindow",
        "packetId": 201,
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "id",
            "type": "int",
            "nullable": false
          },
          {
            "name": "windowData",
            "type": "String",
            "nullable": true
          },
          {
            "name": "inventory",
            "type": "InventorySection",
            "nullable": true
          },
          {
            "name": "extraResources",
            "type": "ExtraResources",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateWindow\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 201;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 17;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int id;\n@Nullable String windowData;\n@Nullable InventorySection inventory;\n@Nullable ExtraResources extraResources;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateWindow deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateWindow obj = new UpdateWindow();\n      byte nullBits = buf.getByte(offset);\n      obj.id = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 17 + buf.getIntLE(offset + 5);\n         int windowDataLen = VarInt.peek(buf, varPos0);\n         if (windowDataLen < 0) {\n            throw ProtocolException.negativeLength(\"WindowData\", windowDataLen);\n         }\n\n         if (windowDataLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"WindowData\", windowDataLen, 4096000);\n         }\n\n         obj.windowData = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 17 + buf.getIntLE(offset + 9);\n         obj.inventory = InventorySection.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 17 + buf.getIntLE(offset + 13);\n         obj.extraResources = ExtraResources.deserialize(buf, varPos2);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateWindow deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateWindow obj = new UpdateWindow();\n      byte nullBits = buf.getByte(offset);\n      obj.id = buf.getIntLE(offset + 1);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 17 + buf.getIntLE(offset + 5);\n         int windowDataLen = VarInt.peek(buf, varPos0);\n         if (windowDataLen < 0) {\n            throw ProtocolException.negativeLength(\"WindowData\", windowDataLen);\n         }\n\n         if (windowDataLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"WindowData\", windowDataLen, 4096000);\n         }\n\n         obj.windowData = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 17 + buf.getIntLE(offset + 9);\n         obj.inventory = InventorySection.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 17 + buf.getIntLE(offset + 13);\n         obj.extraResources = ExtraResources.deserialize(buf, varPos2);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 17;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 5);\n         int pos0 = offset + 17 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 9);\n         int pos1 = offset + 17 + fieldOffset1;\n         pos1 += InventorySection.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 13);\n         int pos2 = offset + 17 + fieldOffset2;\n         pos2 += ExtraResources.computeBytesConsumed(buf, pos2);\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 17) {\n         return ValidationResult.error(\"Buffer too small: expected at least 17 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int windowDataOffset = buffer.getIntLE(offset + 5);\n            if (windowDataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for WindowData\");\n            }\n\n            int pos = offset + 17 + windowDataOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for WindowData\");\n            }\n\n            int windowDataLen = VarInt.peek(buffer, pos);\n            if (windowDataLen < 0) {\n               return ValidationResult.error(\"Invalid string length for WindowData\");\n            }\n\n            if (windowDataLen > 4096000) {\n               return ValidationResult.error(\"WindowData exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += windowDataLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading WindowData\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int inventoryOffset = buffer.getIntLE(offset + 9);\n            if (inventoryOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Inventory\");\n            }\n\n            int posx = offset + 17 + inventoryOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Inventory\");\n            }\n\n            ValidationResult inventoryResult = InventorySection.validateStructure(buffer, posx);\n            if (!inventoryResult.isValid()) {\n               return ValidationResult.error(\"Invalid Inventory: \" + inventoryResult.error());\n            }\n\n            posx += InventorySection.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int extraResourcesOffset = buffer.getIntLE(offset + 13);\n            if (extraResourcesOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ExtraResources\");\n            }\n\n            int posxx = offset + 17 + extraResourcesOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ExtraResources\");\n            }\n\n            ValidationResult extraResourcesResult = ExtraResources.validateStructure(buffer, posxx);\n            if (!extraResourcesResult.isValid()) {\n               return ValidationResult.error(\"Invalid ExtraResources: \" + extraResourcesResult.error());\n            }\n\n            posxx += ExtraResources.computeBytesConsumed(buffer, posxx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, InventorySection.deserialize, ExtraResources.deserialize\n// Types referenced: InventorySection, ExtraResources\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CloseWindow",
        "packetId": 202,
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "id",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: CloseWindow\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 202;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int id;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CloseWindow deserialize(@Nonnull ByteBuf buf, int offset) {\n      CloseWindow obj = new CloseWindow();\n      obj.id = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SendWindowAction",
        "packetId": 203,
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "id",
            "type": "int",
            "nullable": false
          },
          {
            "name": "action",
            "type": "WindowAction",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SendWindowAction\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 203;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 32768027;\n\n// === FIELDS ===\n@Nonnull int id;\n@Nonnull WindowAction action;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SendWindowAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      SendWindowAction obj = new SendWindowAction();\n      obj.id = buf.getIntLE(offset + 0);\n      int pos = offset + 4;\n      obj.action = WindowAction.deserialize(buf, pos);\n      pos += WindowAction.computeBytesConsumed(buf, pos);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SendWindowAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      SendWindowAction obj = new SendWindowAction();\n      obj.id = buf.getIntLE(offset + 0);\n      int pos = offset + 4;\n      obj.action = WindowAction.deserialize(buf, pos);\n      pos += WindowAction.computeBytesConsumed(buf, pos);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int pos = offset + 4;\n      pos += WindowAction.computeBytesConsumed(buf, pos);\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 4) {\n         return ValidationResult.error(\"Buffer too small: expected at least 4 bytes\");\n      } else {\n         int pos = offset + 4;\n         ValidationResult actionResult = WindowAction.validateStructure(buffer, pos);\n         if (!actionResult.isValid()) {\n            return ValidationResult.error(\"Invalid Action: \" + actionResult.error());\n         } else {\n            pos += WindowAction.computeBytesConsumed(buffer, pos);\n            return ValidationResult.OK;\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, WindowAction.deserialize, WindowAction.computeBytesConsumed\n// Types referenced: WindowAction\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ClientOpenWindow",
        "packetId": 204,
        "package": "com.hypixel.hytale.protocol.packets.window",
        "fields": [
          {
            "name": "type",
            "type": "WindowType",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ClientOpenWindow\n// Package: com.hypixel.hytale.protocol.packets.window\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 204;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull WindowType type;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ClientOpenWindow deserialize(@Nonnull ByteBuf buf, int offset) {\n      ClientOpenWindow obj = new ClientOpenWindow();\n      obj.type = WindowType.fromValue(buf.getByte(offset + 0));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: WindowType.fromValue, buf.getByte\n// Types referenced: WindowType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "inventory": [
      {
        "name": "UpdatePlayerInventory",
        "packetId": 170,
        "package": "com.hypixel.hytale.protocol.packets.inventory",
        "fields": [
          {
            "name": "storage",
            "type": "InventorySection",
            "nullable": true
          },
          {
            "name": "armor",
            "type": "InventorySection",
            "nullable": true
          },
          {
            "name": "hotbar",
            "type": "InventorySection",
            "nullable": true
          },
          {
            "name": "utility",
            "type": "InventorySection",
            "nullable": true
          },
          {
            "name": "builderMaterial",
            "type": "InventorySection",
            "nullable": true
          },
          {
            "name": "tools",
            "type": "InventorySection",
            "nullable": true
          },
          {
            "name": "backpack",
            "type": "InventorySection",
            "nullable": true
          },
          {
            "name": "sortType",
            "type": "SortType",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdatePlayerInventory\n// Package: com.hypixel.hytale.protocol.packets.inventory\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 170;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 2;\npublic static final int VARIABLE_FIELD_COUNT = 7;\npublic static final int VARIABLE_BLOCK_START = 30;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nullable InventorySection storage;\n@Nullable InventorySection armor;\n@Nullable InventorySection hotbar;\n@Nullable InventorySection utility;\n@Nullable InventorySection builderMaterial;\n@Nullable InventorySection tools;\n@Nullable InventorySection backpack;\n@Nonnull SortType sortType;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdatePlayerInventory deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdatePlayerInventory obj = new UpdatePlayerInventory();\n      byte nullBits = buf.getByte(offset);\n      obj.sortType = SortType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 30 + buf.getIntLE(offset + 2);\n         obj.storage = InventorySection.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 30 + buf.getIntLE(offset + 6);\n         obj.armor = InventorySection.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 30 + buf.getIntLE(offset + 10);\n         obj.hotbar = InventorySection.deserialize(buf, varPos2);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 30 + buf.getIntLE(offset + 14);\n         obj.utility = InventorySection.deserialize(buf, varPos3);\n      }\n\n      if ((nullBits & 16) != 0) {\n         int varPos4 = offset + 30 + buf.getIntLE(offset + 18);\n         obj.builderMaterial = InventorySection.deserialize(buf, varPos4);\n      }\n\n      if ((nullBits & 32) != 0) {\n         int varPos5 = offset + 30 + buf.getIntLE(offset + 22);\n         obj.tools = InventorySection.deserialize(buf, varPos5);\n      }\n\n      if ((nullBits & 64) != 0) {\n         int varPos6 = offset + 30 + buf.getIntLE(offset + 26);\n         obj.backpack = InventorySection.deserialize(buf, varPos6);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdatePlayerInventory deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdatePlayerInventory obj = new UpdatePlayerInventory();\n      byte nullBits = buf.getByte(offset);\n      obj.sortType = SortType.fromValue(buf.getByte(offset + 1));\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 30 + buf.getIntLE(offset + 2);\n         obj.storage = InventorySection.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 30 + buf.getIntLE(offset + 6);\n         obj.armor = InventorySection.deserialize(buf, varPos1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 30 + buf.getIntLE(offset + 10);\n         obj.hotbar = InventorySection.deserialize(buf, varPos2);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 30 + buf.getIntLE(offset + 14);\n         obj.utility = InventorySection.deserialize(buf, varPos3);\n      }\n\n      if ((nullBits & 16) != 0) {\n         int varPos4 = offset + 30 + buf.getIntLE(offset + 18);\n         obj.builderMaterial = InventorySection.deserialize(buf, varPos4);\n      }\n\n      if ((nullBits & 32) != 0) {\n         int varPos5 = offset + 30 + buf.getIntLE(offset + 22);\n         obj.tools = InventorySection.deserialize(buf, varPos5);\n      }\n\n      if ((nullBits & 64) != 0) {\n         int varPos6 = offset + 30 + buf.getIntLE(offset + 26);\n         obj.backpack = InventorySection.deserialize(buf, varPos6);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 30;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 2);\n         int pos0 = offset + 30 + fieldOffset0;\n         pos0 += InventorySection.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 6);\n         int pos1 = offset + 30 + fieldOffset1;\n         pos1 += InventorySection.computeBytesConsumed(buf, pos1);\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 10);\n         int pos2 = offset + 30 + fieldOffset2;\n         pos2 += InventorySection.computeBytesConsumed(buf, pos2);\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         int fieldOffset3 = buf.getIntLE(offset + 14);\n         int pos3 = offset + 30 + fieldOffset3;\n         pos3 += InventorySection.computeBytesConsumed(buf, pos3);\n         if (pos3 - offset > maxEnd) {\n            maxEnd = pos3 - offset;\n         }\n      }\n\n      if ((nullBits & 16) != 0) {\n         int fieldOffset4 = buf.getIntLE(offset + 18);\n         int pos4 = offset + 30 + fieldOffset4;\n         pos4 += InventorySection.computeBytesConsumed(buf, pos4);\n         if (pos4 - offset > maxEnd) {\n            maxEnd = pos4 - offset;\n         }\n      }\n\n      if ((nullBits & 32) != 0) {\n         int fieldOffset5 = buf.getIntLE(offset + 22);\n         int pos5 = offset + 30 + fieldOffset5;\n         pos5 += InventorySection.computeBytesConsumed(buf, pos5);\n         if (pos5 - offset > maxEnd) {\n            maxEnd = pos5 - offset;\n         }\n      }\n\n      if ((nullBits & 64) != 0) {\n         int fieldOffset6 = buf.getIntLE(offset + 26);\n         int pos6 = offset + 30 + fieldOffset6;\n         pos6 += InventorySection.computeBytesConsumed(buf, pos6);\n         if (pos6 - offset > maxEnd) {\n            maxEnd = pos6 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 30) {\n         return ValidationResult.error(\"Buffer too small: expected at least 30 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int storageOffset = buffer.getIntLE(offset + 2);\n            if (storageOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Storage\");\n            }\n\n            int pos = offset + 30 + storageOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Storage\");\n            }\n\n            ValidationResult storageResult = InventorySection.validateStructure(buffer, pos);\n            if (!storageResult.isValid()) {\n               return ValidationResult.error(\"Invalid Storage: \" + storageResult.error());\n            }\n\n            pos += InventorySection.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int armorOffset = buffer.getIntLE(offset + 6);\n            if (armorOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Armor\");\n            }\n\n            int posx = offset + 30 + armorOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Armor\");\n            }\n\n            ValidationResult armorResult = InventorySection.validateStructure(buffer, posx);\n            if (!armorResult.isValid()) {\n               return ValidationResult.error(\"Invalid Armor: \" + armorResult.error());\n            }\n\n            posx += InventorySection.computeBytesConsumed(buffer, posx);\n         }\n\n         if ((nullBits & 4) != 0) {\n            int hotbarOffset = buffer.getIntLE(offset + 10);\n            if (hotbarOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Hotbar\");\n            }\n\n            int posxx = offset + 30 + hotbarOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Hotbar\");\n            }\n\n            ValidationResult hotbarResult = InventorySection.validateStructure(buffer, posxx);\n            if (!hotbarResult.isValid()) {\n               return ValidationResult.error(\"Invalid Hotbar: \" + hotbarResult.error());\n            }\n\n            posxx += InventorySection.computeBytesConsumed(buffer, posxx);\n         }\n\n         if ((nullBits & 8) != 0) {\n            int utilityOffset = buffer.getIntLE(offset + 14);\n            if (utilityOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Utility\");\n            }\n\n            int posxxx = offset + 30 + utilityOffset;\n            if (posxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Utility\");\n            }\n\n            ValidationResult utilityResult = InventorySection.validateStructure(buffer, posxxx);\n            if (!utilityResult.isValid()) {\n               return ValidationResult.error(\"Invalid Utility: \" + utilityResult.error());\n            }\n\n            posxxx += InventorySection.computeBytesConsumed(buffer, posxxx);\n         }\n\n         if ((nullBits & 16) != 0) {\n            int builderMaterialOffset = buffer.getIntLE(offset + 18);\n            if (builderMaterialOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for BuilderMaterial\");\n            }\n\n            int posxxxx = offset + 30 + builderMaterialOffset;\n            if (posxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for BuilderMaterial\");\n            }\n\n            ValidationResult builderMaterialResult = InventorySection.validateStructure(buffer, posxxxx);\n            if (!builderMaterialResult.isValid()) {\n               return ValidationResult.error(\"Invalid BuilderMaterial: \" + builderMaterialResult.error());\n            }\n\n            posxxxx += InventorySection.computeBytesConsumed(buffer, posxxxx);\n         }\n\n         if ((nullBits & 32) != 0) {\n            int toolsOffset = buffer.getIntLE(offset + 22);\n            if (toolsOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Tools\");\n            }\n\n            int posxxxxx = offset + 30 + toolsOffset;\n            if (posxxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Tools\");\n            }\n\n            ValidationResult toolsResult = InventorySection.validateStructure(buffer, posxxxxx);\n            if (!toolsResult.isValid()) {\n               return ValidationResult.error(\"Invalid Tools: \" + toolsResult.error());\n            }\n\n            posxxxxx += InventorySection.computeBytesConsumed(buffer, posxxxxx);\n         }\n\n         if ((nullBits & 64) != 0) {\n            int backpackOffset = buffer.getIntLE(offset + 26);\n            if (backpackOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Backpack\");\n            }\n\n            int posxxxxxx = offset + 30 + backpackOffset;\n            if (posxxxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Backpack\");\n            }\n\n            ValidationResult backpackResult = InventorySection.validateStructure(buffer, posxxxxxx);\n            if (!backpackResult.isValid()) {\n               return ValidationResult.error(\"Invalid Backpack: \" + backpackResult.error());\n            }\n\n            posxxxxxx += InventorySection.computeBytesConsumed(buffer, posxxxxxx);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, SortType.fromValue, buf.getIntLE, InventorySection.deserialize\n// Types referenced: SortType, InventorySection\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetCreativeItem",
        "packetId": 171,
        "package": "com.hypixel.hytale.protocol.packets.inventory",
        "fields": [
          {
            "name": "inventorySectionId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "slotId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "item",
            "type": "ItemQuantity",
            "nullable": false
          },
          {
            "name": "override",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetCreativeItem\n// Package: com.hypixel.hytale.protocol.packets.inventory\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 171;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 16384019;\n\n// === FIELDS ===\n@Nonnull int inventorySectionId;\n@Nonnull int slotId;\n@Nonnull ItemQuantity item;\n@Nonnull boolean override;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetCreativeItem deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetCreativeItem obj = new SetCreativeItem();\n      obj.inventorySectionId = buf.getIntLE(offset + 0);\n      obj.slotId = buf.getIntLE(offset + 4);\n      obj.override = buf.getByte(offset + 8) != 0;\n      int pos = offset + 9;\n      obj.item = ItemQuantity.deserialize(buf, pos);\n      pos += ItemQuantity.computeBytesConsumed(buf, pos);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SetCreativeItem deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetCreativeItem obj = new SetCreativeItem();\n      obj.inventorySectionId = buf.getIntLE(offset + 0);\n      obj.slotId = buf.getIntLE(offset + 4);\n      obj.override = buf.getByte(offset + 8) != 0;\n      int pos = offset + 9;\n      obj.item = ItemQuantity.deserialize(buf, pos);\n      pos += ItemQuantity.computeBytesConsumed(buf, pos);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int pos = offset + 9;\n      pos += ItemQuantity.computeBytesConsumed(buf, pos);\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         int pos = offset + 9;\n         ValidationResult itemResult = ItemQuantity.validateStructure(buffer, pos);\n         if (!itemResult.isValid()) {\n            return ValidationResult.error(\"Invalid Item: \" + itemResult.error());\n         } else {\n            pos += ItemQuantity.computeBytesConsumed(buffer, pos);\n            return ValidationResult.OK;\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getByte, ItemQuantity.deserialize, ItemQuantity.computeBytesConsumed\n// Types referenced: ItemQuantity\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "DropCreativeItem",
        "packetId": 172,
        "package": "com.hypixel.hytale.protocol.packets.inventory",
        "fields": [
          {
            "name": "item",
            "type": "ItemQuantity",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: DropCreativeItem\n// Package: com.hypixel.hytale.protocol.packets.inventory\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 172;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 16384010;\n\n// === FIELDS ===\n@Nonnull ItemQuantity item;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static DropCreativeItem deserialize(@Nonnull ByteBuf buf, int offset) {\n      DropCreativeItem obj = new DropCreativeItem();\n      int pos = offset + 0;\n      obj.item = ItemQuantity.deserialize(buf, pos);\n      pos += ItemQuantity.computeBytesConsumed(buf, pos);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static DropCreativeItem deserialize(@Nonnull ByteBuf buf, int offset) {\n      DropCreativeItem obj = new DropCreativeItem();\n      int pos = offset + 0;\n      obj.item = ItemQuantity.deserialize(buf, pos);\n      pos += ItemQuantity.computeBytesConsumed(buf, pos);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int pos = offset + 0;\n      pos += ItemQuantity.computeBytesConsumed(buf, pos);\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 0) {\n         return ValidationResult.error(\"Buffer too small: expected at least 0 bytes\");\n      } else {\n         int pos = offset + 0;\n         ValidationResult itemResult = ItemQuantity.validateStructure(buffer, pos);\n         if (!itemResult.isValid()) {\n            return ValidationResult.error(\"Invalid Item: \" + itemResult.error());\n         } else {\n            pos += ItemQuantity.computeBytesConsumed(buffer, pos);\n            return ValidationResult.OK;\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: ItemQuantity.deserialize, ItemQuantity.computeBytesConsumed\n// Types referenced: ItemQuantity\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SmartGiveCreativeItem",
        "packetId": 173,
        "package": "com.hypixel.hytale.protocol.packets.inventory",
        "fields": [
          {
            "name": "item",
            "type": "ItemQuantity",
            "nullable": false
          },
          {
            "name": "moveType",
            "type": "SmartMoveType",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SmartGiveCreativeItem\n// Package: com.hypixel.hytale.protocol.packets.inventory\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 173;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384011;\n\n// === FIELDS ===\n@Nonnull ItemQuantity item;\n@Nonnull SmartMoveType moveType;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SmartGiveCreativeItem deserialize(@Nonnull ByteBuf buf, int offset) {\n      SmartGiveCreativeItem obj = new SmartGiveCreativeItem();\n      obj.moveType = SmartMoveType.fromValue(buf.getByte(offset + 0));\n      int pos = offset + 1;\n      obj.item = ItemQuantity.deserialize(buf, pos);\n      pos += ItemQuantity.computeBytesConsumed(buf, pos);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SmartGiveCreativeItem deserialize(@Nonnull ByteBuf buf, int offset) {\n      SmartGiveCreativeItem obj = new SmartGiveCreativeItem();\n      obj.moveType = SmartMoveType.fromValue(buf.getByte(offset + 0));\n      int pos = offset + 1;\n      obj.item = ItemQuantity.deserialize(buf, pos);\n      pos += ItemQuantity.computeBytesConsumed(buf, pos);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int pos = offset + 1;\n      pos += ItemQuantity.computeBytesConsumed(buf, pos);\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         int pos = offset + 1;\n         ValidationResult itemResult = ItemQuantity.validateStructure(buffer, pos);\n         if (!itemResult.isValid()) {\n            return ValidationResult.error(\"Invalid Item: \" + itemResult.error());\n         } else {\n            pos += ItemQuantity.computeBytesConsumed(buffer, pos);\n            return ValidationResult.OK;\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: SmartMoveType.fromValue, buf.getByte, ItemQuantity.deserialize, ItemQuantity.computeBytesConsumed\n// Types referenced: SmartMoveType, ItemQuantity\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "DropItemStack",
        "packetId": 174,
        "package": "com.hypixel.hytale.protocol.packets.inventory",
        "fields": [
          {
            "name": "inventorySectionId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "slotId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "quantity",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: DropItemStack\n// Package: com.hypixel.hytale.protocol.packets.inventory\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 174;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 12;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 12;\npublic static final int MAX_SIZE = 12;\n\n// === FIELDS ===\n@Nonnull int inventorySectionId;\n@Nonnull int slotId;\n@Nonnull int quantity;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static DropItemStack deserialize(@Nonnull ByteBuf buf, int offset) {\n      DropItemStack obj = new DropItemStack();\n      obj.inventorySectionId = buf.getIntLE(offset + 0);\n      obj.slotId = buf.getIntLE(offset + 4);\n      obj.quantity = buf.getIntLE(offset + 8);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 12;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 12 ? ValidationResult.error(\"Buffer too small: expected at least 12 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "MoveItemStack",
        "packetId": 175,
        "package": "com.hypixel.hytale.protocol.packets.inventory",
        "fields": [
          {
            "name": "fromSectionId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "fromSlotId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "quantity",
            "type": "int",
            "nullable": false
          },
          {
            "name": "toSectionId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "toSlotId",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: MoveItemStack\n// Package: com.hypixel.hytale.protocol.packets.inventory\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 175;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 20;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 20;\npublic static final int MAX_SIZE = 20;\n\n// === FIELDS ===\n@Nonnull int fromSectionId;\n@Nonnull int fromSlotId;\n@Nonnull int quantity;\n@Nonnull int toSectionId;\n@Nonnull int toSlotId;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static MoveItemStack deserialize(@Nonnull ByteBuf buf, int offset) {\n      MoveItemStack obj = new MoveItemStack();\n      obj.fromSectionId = buf.getIntLE(offset + 0);\n      obj.fromSlotId = buf.getIntLE(offset + 4);\n      obj.quantity = buf.getIntLE(offset + 8);\n      obj.toSectionId = buf.getIntLE(offset + 12);\n      obj.toSlotId = buf.getIntLE(offset + 16);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 20;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 20 ? ValidationResult.error(\"Buffer too small: expected at least 20 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SmartMoveItemStack",
        "packetId": 176,
        "package": "com.hypixel.hytale.protocol.packets.inventory",
        "fields": [
          {
            "name": "fromSectionId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "fromSlotId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "quantity",
            "type": "int",
            "nullable": false
          },
          {
            "name": "moveType",
            "type": "SmartMoveType",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SmartMoveItemStack\n// Package: com.hypixel.hytale.protocol.packets.inventory\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 176;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 13;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 13;\n\n// === FIELDS ===\n@Nonnull int fromSectionId;\n@Nonnull int fromSlotId;\n@Nonnull int quantity;\n@Nonnull SmartMoveType moveType;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SmartMoveItemStack deserialize(@Nonnull ByteBuf buf, int offset) {\n      SmartMoveItemStack obj = new SmartMoveItemStack();\n      obj.fromSectionId = buf.getIntLE(offset + 0);\n      obj.fromSlotId = buf.getIntLE(offset + 4);\n      obj.quantity = buf.getIntLE(offset + 8);\n      obj.moveType = SmartMoveType.fromValue(buf.getByte(offset + 12));\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 13;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 13 ? ValidationResult.error(\"Buffer too small: expected at least 13 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, SmartMoveType.fromValue, buf.getByte\n// Types referenced: SmartMoveType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetActiveSlot",
        "packetId": 177,
        "package": "com.hypixel.hytale.protocol.packets.inventory",
        "fields": [
          {
            "name": "inventorySectionId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "activeSlot",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetActiveSlot\n// Package: com.hypixel.hytale.protocol.packets.inventory\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 177;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 8;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 8;\npublic static final int MAX_SIZE = 8;\n\n// === FIELDS ===\n@Nonnull int inventorySectionId;\n@Nonnull int activeSlot;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetActiveSlot deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetActiveSlot obj = new SetActiveSlot();\n      obj.inventorySectionId = buf.getIntLE(offset + 0);\n      obj.activeSlot = buf.getIntLE(offset + 4);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 8;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 8 ? ValidationResult.error(\"Buffer too small: expected at least 8 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SwitchHotbarBlockSet",
        "packetId": 178,
        "package": "com.hypixel.hytale.protocol.packets.inventory",
        "fields": [
          {
            "name": "itemId",
            "type": "String",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SwitchHotbarBlockSet\n// Package: com.hypixel.hytale.protocol.packets.inventory\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 178;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 16384006;\n\n// === FIELDS ===\n@Nullable String itemId;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SwitchHotbarBlockSet deserialize(@Nonnull ByteBuf buf, int offset) {\n      SwitchHotbarBlockSet obj = new SwitchHotbarBlockSet();\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int itemIdLen = VarInt.peek(buf, pos);\n         if (itemIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ItemId\", itemIdLen);\n         }\n\n         if (itemIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ItemId\", itemIdLen, 4096000);\n         }\n\n         int itemIdVarLen = VarInt.length(buf, pos);\n         obj.itemId = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += itemIdVarLen + itemIdLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 1;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 1) {\n         return ValidationResult.error(\"Buffer too small: expected at least 1 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 1;\n         if ((nullBits & 1) != 0) {\n            int itemIdLen = VarInt.peek(buffer, pos);\n            if (itemIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ItemId\");\n            }\n\n            if (itemIdLen > 4096000) {\n               return ValidationResult.error(\"ItemId exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += itemIdLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ItemId\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "InventoryAction",
        "packetId": 179,
        "package": "com.hypixel.hytale.protocol.packets.inventory",
        "fields": [
          {
            "name": "inventorySectionId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "inventoryActionType",
            "type": "InventoryActionType",
            "nullable": false
          },
          {
            "name": "actionData",
            "type": "byte",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: InventoryAction\n// Package: com.hypixel.hytale.protocol.packets.inventory\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 179;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 6;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 6;\npublic static final int MAX_SIZE = 6;\n\n// === FIELDS ===\n@Nonnull int inventorySectionId;\n@Nonnull InventoryActionType inventoryActionType;\n@Nonnull byte actionData;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static InventoryAction deserialize(@Nonnull ByteBuf buf, int offset) {\n      InventoryAction obj = new InventoryAction();\n      obj.inventorySectionId = buf.getIntLE(offset + 0);\n      obj.inventoryActionType = InventoryActionType.fromValue(buf.getByte(offset + 4));\n      obj.actionData = buf.getByte(offset + 5);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 6;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 6 ? ValidationResult.error(\"Buffer too small: expected at least 6 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, InventoryActionType.fromValue, buf.getByte\n// Types referenced: InventoryActionType\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "world": [
      {
        "name": "SetBlockCmd",
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "index",
            "type": "short",
            "nullable": false
          },
          {
            "name": "blockId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "filler",
            "type": "short",
            "nullable": false
          },
          {
            "name": "rotation",
            "type": "byte",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetBlockCmd\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 9;\n\n// === FIELDS ===\n@Nonnull short index;\n@Nonnull int blockId;\n@Nonnull short filler;\n@Nonnull byte rotation;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetBlockCmd deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetBlockCmd obj = new SetBlockCmd();\n      obj.index = buf.getShortLE(offset + 0);\n      obj.blockId = buf.getIntLE(offset + 2);\n      obj.filler = buf.getShortLE(offset + 6);\n      obj.rotation = buf.getByte(offset + 8);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 9;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 9 ? ValidationResult.error(\"Buffer too small: expected at least 9 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getShortLE, buf.getIntLE, buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SleepMultiplayer",
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "sleepersCount",
            "type": "int",
            "nullable": false
          },
          {
            "name": "awakeCount",
            "type": "int",
            "nullable": false
          },
          {
            "name": "awakeSample",
            "type": "UUID[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SleepMultiplayer\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 65536014;\n\n// === FIELDS ===\n@Nonnull int sleepersCount;\n@Nonnull int awakeCount;\n@Nullable UUID[] awakeSample;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SleepMultiplayer deserialize(@Nonnull ByteBuf buf, int offset) {\n      SleepMultiplayer obj = new SleepMultiplayer();\n      byte nullBits = buf.getByte(offset);\n      obj.sleepersCount = buf.getIntLE(offset + 1);\n      obj.awakeCount = buf.getIntLE(offset + 5);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int awakeSampleCount = VarInt.peek(buf, pos);\n         if (awakeSampleCount < 0) {\n            throw ProtocolException.negativeLength(\"AwakeSample\", awakeSampleCount);\n         }\n\n         if (awakeSampleCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"AwakeSample\", awakeSampleCount, 4096000);\n         }\n\n         int awakeSampleVarLen = VarInt.size(awakeSampleCount);\n         if ((long)(pos + awakeSampleVarLen) + (long)awakeSampleCount * 16L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"AwakeSample\", pos + awakeSampleVarLen + awakeSampleCount * 16, buf.readableBytes());\n         }\n\n         pos += awakeSampleVarLen;\n         obj.awakeSample = new UUID[awakeSampleCount];\n\n         for (int i = 0; i < awakeSampleCount; i++) {\n            obj.awakeSample[i] = PacketIO.readUUID(buf, pos + i * 16);\n         }\n\n         pos += awakeSampleCount * 16;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 16;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 9;\n         if ((nullBits & 1) != 0) {\n            int awakeSampleCount = VarInt.peek(buffer, pos);\n            if (awakeSampleCount < 0) {\n               return ValidationResult.error(\"Invalid array count for AwakeSample\");\n            }\n\n            if (awakeSampleCount > 4096000) {\n               return ValidationResult.error(\"AwakeSample exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += awakeSampleCount * 16;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading AwakeSample\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, PacketIO.readUUID\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetFluidCmd",
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "index",
            "type": "short",
            "nullable": false
          },
          {
            "name": "fluidId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "fluidLevel",
            "type": "byte",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetFluidCmd\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 7;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 7;\npublic static final int MAX_SIZE = 7;\n\n// === FIELDS ===\n@Nonnull short index;\n@Nonnull int fluidId;\n@Nonnull byte fluidLevel;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetFluidCmd deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetFluidCmd obj = new SetFluidCmd();\n      obj.index = buf.getShortLE(offset + 0);\n      obj.fluidId = buf.getIntLE(offset + 2);\n      obj.fluidLevel = buf.getByte(offset + 6);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 7;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 7 ? ValidationResult.error(\"Buffer too small: expected at least 7 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getShortLE, buf.getIntLE, buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SleepClock",
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "startGametime",
            "type": "InstantData",
            "nullable": true
          },
          {
            "name": "targetGametime",
            "type": "InstantData",
            "nullable": true
          },
          {
            "name": "progress",
            "type": "float",
            "nullable": false
          },
          {
            "name": "durationSeconds",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SleepClock\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 33;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 33;\npublic static final int MAX_SIZE = 33;\n\n// === FIELDS ===\n@Nullable InstantData startGametime;\n@Nullable InstantData targetGametime;\n@Nonnull float progress;\n@Nonnull float durationSeconds;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SleepClock deserialize(@Nonnull ByteBuf buf, int offset) {\n      SleepClock obj = new SleepClock();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.startGametime = InstantData.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 2) != 0) {\n         obj.targetGametime = InstantData.deserialize(buf, offset + 13);\n      }\n\n      obj.progress = buf.getFloatLE(offset + 25);\n      obj.durationSeconds = buf.getFloatLE(offset + 29);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SleepClock deserialize(@Nonnull ByteBuf buf, int offset) {\n      SleepClock obj = new SleepClock();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.startGametime = InstantData.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 2) != 0) {\n         obj.targetGametime = InstantData.deserialize(buf, offset + 13);\n      }\n\n      obj.progress = buf.getFloatLE(offset + 25);\n      obj.durationSeconds = buf.getFloatLE(offset + 29);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 33;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 33 ? ValidationResult.error(\"Buffer too small: expected at least 33 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, InstantData.deserialize, buf.getFloatLE\n// Types referenced: InstantData\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetChunk",
        "packetId": 131,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "localLight",
            "type": "byte[]",
            "nullable": true
          },
          {
            "name": "globalLight",
            "type": "byte[]",
            "nullable": true
          },
          {
            "name": "data",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SetChunk\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 131;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 13;\npublic static final int VARIABLE_FIELD_COUNT = 3;\npublic static final int VARIABLE_BLOCK_START = 25;\npublic static final int MAX_SIZE = 12288040;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n@Nullable byte[] localLight;\n@Nullable byte[] globalLight;\n@Nullable byte[] data;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetChunk deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetChunk obj = new SetChunk();\n      byte nullBits = buf.getByte(offset);\n      obj.x = buf.getIntLE(offset + 1);\n      obj.y = buf.getIntLE(offset + 5);\n      obj.z = buf.getIntLE(offset + 9);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 25 + buf.getIntLE(offset + 13);\n         int localLightCount = VarInt.peek(buf, varPos0);\n         if (localLightCount < 0) {\n            throw ProtocolException.negativeLength(\"LocalLight\", localLightCount);\n         }\n\n         if (localLightCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"LocalLight\", localLightCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos0);\n         if ((long)(varPos0 + varIntLen) + (long)localLightCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"LocalLight\", varPos0 + varIntLen + localLightCount * 1, buf.readableBytes());\n         }\n\n         obj.localLight = new byte[localLightCount];\n\n         for (int i = 0; i < localLightCount; i++) {\n            obj.localLight[i] = buf.getByte(varPos0 + varIntLen + i * 1);\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 25 + buf.getIntLE(offset + 17);\n         int globalLightCount = VarInt.peek(buf, varPos1);\n         if (globalLightCount < 0) {\n            throw ProtocolException.negativeLength(\"GlobalLight\", globalLightCount);\n         }\n\n         if (globalLightCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"GlobalLight\", globalLightCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos1);\n         if ((long)(varPos1 + varIntLen) + (long)globalLightCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"GlobalLight\", varPos1 + varIntLen + globalLightCount * 1, buf.readableBytes());\n         }\n\n         obj.globalLight = new byte[globalLightCount];\n\n         for (int i = 0; i < globalLightCount; i++) {\n            obj.globalLight[i] = buf.getByte(varPos1 + varIntLen + i * 1);\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 25 + buf.getIntLE(offset + 21);\n         int dataCount = VarInt.peek(buf, varPos2);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos2);\n         if ((long)(varPos2 + varIntLen) + (long)dataCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", varPos2 + varIntLen + dataCount * 1, buf.readableBytes());\n         }\n\n         obj.data = new byte[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getByte(varPos2 + varIntLen + i * 1);\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 25;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 13);\n         int pos0 = offset + 25 + fieldOffset0;\n         int arrLen = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + arrLen * 1;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 17);\n         int pos1 = offset + 25 + fieldOffset1;\n         int arrLen = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + arrLen * 1;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 21);\n         int pos2 = offset + 25 + fieldOffset2;\n         int arrLen = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + arrLen * 1;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 25) {\n         return ValidationResult.error(\"Buffer too small: expected at least 25 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int localLightOffset = buffer.getIntLE(offset + 13);\n            if (localLightOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for LocalLight\");\n            }\n\n            int pos = offset + 25 + localLightOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for LocalLight\");\n            }\n\n            int localLightCount = VarInt.peek(buffer, pos);\n            if (localLightCount < 0) {\n               return ValidationResult.error(\"Invalid array count for LocalLight\");\n            }\n\n            if (localLightCount > 4096000) {\n               return ValidationResult.error(\"LocalLight exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += localLightCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading LocalLight\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int globalLightOffset = buffer.getIntLE(offset + 17);\n            if (globalLightOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for GlobalLight\");\n            }\n\n            int posx = offset + 25 + globalLightOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for GlobalLight\");\n            }\n\n            int globalLightCount = VarInt.peek(buffer, posx);\n            if (globalLightCount < 0) {\n               return ValidationResult.error(\"Invalid array count for GlobalLight\");\n            }\n\n            if (globalLightCount > 4096000) {\n               return ValidationResult.error(\"GlobalLight exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += globalLightCount * 1;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading GlobalLight\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int dataOffset = buffer.getIntLE(offset + 21);\n            if (dataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Data\");\n            }\n\n            int posxx = offset + 25 + dataOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Data\");\n            }\n\n            int dataCount = VarInt.peek(buffer, posxx);\n            if (dataCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Data\");\n            }\n\n            if (dataCount > 4096000) {\n               return ValidationResult.error(\"Data exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += dataCount * 1;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Data\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetChunkHeightmap",
        "packetId": 132,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "heightmap",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SetChunkHeightmap\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 132;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 4096014;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int z;\n@Nullable byte[] heightmap;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetChunkHeightmap deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetChunkHeightmap obj = new SetChunkHeightmap();\n      byte nullBits = buf.getByte(offset);\n      obj.x = buf.getIntLE(offset + 1);\n      obj.z = buf.getIntLE(offset + 5);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int heightmapCount = VarInt.peek(buf, pos);\n         if (heightmapCount < 0) {\n            throw ProtocolException.negativeLength(\"Heightmap\", heightmapCount);\n         }\n\n         if (heightmapCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Heightmap\", heightmapCount, 4096000);\n         }\n\n         int heightmapVarLen = VarInt.size(heightmapCount);\n         if ((long)(pos + heightmapVarLen) + (long)heightmapCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Heightmap\", pos + heightmapVarLen + heightmapCount * 1, buf.readableBytes());\n         }\n\n         pos += heightmapVarLen;\n         obj.heightmap = new byte[heightmapCount];\n\n         for (int i = 0; i < heightmapCount; i++) {\n            obj.heightmap[i] = buf.getByte(pos + i * 1);\n         }\n\n         pos += heightmapCount * 1;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 9;\n         if ((nullBits & 1) != 0) {\n            int heightmapCount = VarInt.peek(buffer, pos);\n            if (heightmapCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Heightmap\");\n            }\n\n            if (heightmapCount > 4096000) {\n               return ValidationResult.error(\"Heightmap exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += heightmapCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Heightmap\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetChunkTintmap",
        "packetId": 133,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "tintmap",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SetChunkTintmap\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 133;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 4096014;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int z;\n@Nullable byte[] tintmap;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetChunkTintmap deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetChunkTintmap obj = new SetChunkTintmap();\n      byte nullBits = buf.getByte(offset);\n      obj.x = buf.getIntLE(offset + 1);\n      obj.z = buf.getIntLE(offset + 5);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int tintmapCount = VarInt.peek(buf, pos);\n         if (tintmapCount < 0) {\n            throw ProtocolException.negativeLength(\"Tintmap\", tintmapCount);\n         }\n\n         if (tintmapCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Tintmap\", tintmapCount, 4096000);\n         }\n\n         int tintmapVarLen = VarInt.size(tintmapCount);\n         if ((long)(pos + tintmapVarLen) + (long)tintmapCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Tintmap\", pos + tintmapVarLen + tintmapCount * 1, buf.readableBytes());\n         }\n\n         pos += tintmapVarLen;\n         obj.tintmap = new byte[tintmapCount];\n\n         for (int i = 0; i < tintmapCount; i++) {\n            obj.tintmap[i] = buf.getByte(pos + i * 1);\n         }\n\n         pos += tintmapCount * 1;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 9;\n         if ((nullBits & 1) != 0) {\n            int tintmapCount = VarInt.peek(buffer, pos);\n            if (tintmapCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Tintmap\");\n            }\n\n            if (tintmapCount > 4096000) {\n               return ValidationResult.error(\"Tintmap exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += tintmapCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Tintmap\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetChunkEnvironments",
        "packetId": 134,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "environments",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SetChunkEnvironments\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 134;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 9;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 9;\npublic static final int MAX_SIZE = 4096014;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int z;\n@Nullable byte[] environments;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetChunkEnvironments deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetChunkEnvironments obj = new SetChunkEnvironments();\n      byte nullBits = buf.getByte(offset);\n      obj.x = buf.getIntLE(offset + 1);\n      obj.z = buf.getIntLE(offset + 5);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int environmentsCount = VarInt.peek(buf, pos);\n         if (environmentsCount < 0) {\n            throw ProtocolException.negativeLength(\"Environments\", environmentsCount);\n         }\n\n         if (environmentsCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Environments\", environmentsCount, 4096000);\n         }\n\n         int environmentsVarLen = VarInt.size(environmentsCount);\n         if ((long)(pos + environmentsVarLen) + (long)environmentsCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Environments\", pos + environmentsVarLen + environmentsCount * 1, buf.readableBytes());\n         }\n\n         pos += environmentsVarLen;\n         obj.environments = new byte[environmentsCount];\n\n         for (int i = 0; i < environmentsCount; i++) {\n            obj.environments[i] = buf.getByte(pos + i * 1);\n         }\n\n         pos += environmentsCount * 1;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 9;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 9) {\n         return ValidationResult.error(\"Buffer too small: expected at least 9 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 9;\n         if ((nullBits & 1) != 0) {\n            int environmentsCount = VarInt.peek(buffer, pos);\n            if (environmentsCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Environments\");\n            }\n\n            if (environmentsCount > 4096000) {\n               return ValidationResult.error(\"Environments exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += environmentsCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Environments\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UnloadChunk",
        "packetId": 135,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "chunkX",
            "type": "int",
            "nullable": false
          },
          {
            "name": "chunkZ",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UnloadChunk\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 135;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 8;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 8;\npublic static final int MAX_SIZE = 8;\n\n// === FIELDS ===\n@Nonnull int chunkX;\n@Nonnull int chunkZ;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UnloadChunk deserialize(@Nonnull ByteBuf buf, int offset) {\n      UnloadChunk obj = new UnloadChunk();\n      obj.chunkX = buf.getIntLE(offset + 0);\n      obj.chunkZ = buf.getIntLE(offset + 4);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 8;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 8 ? ValidationResult.error(\"Buffer too small: expected at least 8 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetFluids",
        "packetId": 136,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "data",
            "type": "byte[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SetFluids\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 136;\npublic static final boolean IS_COMPRESSED = true;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 13;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 4096018;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n@Nullable byte[] data;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetFluids deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetFluids obj = new SetFluids();\n      byte nullBits = buf.getByte(offset);\n      obj.x = buf.getIntLE(offset + 1);\n      obj.y = buf.getIntLE(offset + 5);\n      obj.z = buf.getIntLE(offset + 9);\n      int pos = offset + 13;\n      if ((nullBits & 1) != 0) {\n         int dataCount = VarInt.peek(buf, pos);\n         if (dataCount < 0) {\n            throw ProtocolException.negativeLength(\"Data\", dataCount);\n         }\n\n         if (dataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"Data\", dataCount, 4096000);\n         }\n\n         int dataVarLen = VarInt.size(dataCount);\n         if ((long)(pos + dataVarLen) + (long)dataCount * 1L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Data\", pos + dataVarLen + dataCount * 1, buf.readableBytes());\n         }\n\n         pos += dataVarLen;\n         obj.data = new byte[dataCount];\n\n         for (int i = 0; i < dataCount; i++) {\n            obj.data[i] = buf.getByte(pos + i * 1);\n         }\n\n         pos += dataCount * 1;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 13;\n      if ((nullBits & 1) != 0) {\n         int arrLen = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + arrLen * 1;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 13) {\n         return ValidationResult.error(\"Buffer too small: expected at least 13 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 13;\n         if ((nullBits & 1) != 0) {\n            int dataCount = VarInt.peek(buffer, pos);\n            if (dataCount < 0) {\n               return ValidationResult.error(\"Invalid array count for Data\");\n            }\n\n            if (dataCount > 4096000) {\n               return ValidationResult.error(\"Data exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += dataCount * 1;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading Data\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerSetBlock",
        "packetId": 140,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "blockId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "filler",
            "type": "short",
            "nullable": false
          },
          {
            "name": "rotation",
            "type": "byte",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ServerSetBlock\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 140;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 19;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 19;\npublic static final int MAX_SIZE = 19;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n@Nonnull int blockId;\n@Nonnull short filler;\n@Nonnull byte rotation;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerSetBlock deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerSetBlock obj = new ServerSetBlock();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      obj.blockId = buf.getIntLE(offset + 12);\n      obj.filler = buf.getShortLE(offset + 16);\n      obj.rotation = buf.getByte(offset + 18);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 19;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 19 ? ValidationResult.error(\"Buffer too small: expected at least 19 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getShortLE, buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerSetBlocks",
        "packetId": 141,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "cmds",
            "type": "SetBlockCmd[]",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ServerSetBlocks\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 141;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 12;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 12;\npublic static final int MAX_SIZE = 36864017;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n@Nonnull SetBlockCmd[] cmds;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerSetBlocks deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerSetBlocks obj = new ServerSetBlocks();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      int pos = offset + 12;\n      int cmdsCount = VarInt.peek(buf, pos);\n      if (cmdsCount < 0) {\n         throw ProtocolException.negativeLength(\"Cmds\", cmdsCount);\n      } else if (cmdsCount > 4096000) {\n         throw ProtocolException.arrayTooLong(\"Cmds\", cmdsCount, 4096000);\n      } else {\n         int cmdsVarLen = VarInt.size(cmdsCount);\n         if ((long)(pos + cmdsVarLen) + (long)cmdsCount * 9L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Cmds\", pos + cmdsVarLen + cmdsCount * 9, buf.readableBytes());\n         } else {\n            pos += cmdsVarLen;\n            obj.cmds = new SetBlockCmd[cmdsCount];\n\n            for (int i = 0; i < cmdsCount; i++) {\n               obj.cmds[i] = SetBlockCmd.deserialize(buf, pos);\n               pos += SetBlockCmd.computeBytesConsumed(buf, pos);\n            }\n\n            return obj;\n         }\n      }\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static ServerSetBlocks deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerSetBlocks obj = new ServerSetBlocks();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      int pos = offset + 12;\n      int cmdsCount = VarInt.peek(buf, pos);\n      if (cmdsCount < 0) {\n         throw ProtocolException.negativeLength(\"Cmds\", cmdsCount);\n      } else if (cmdsCount > 4096000) {\n         throw ProtocolException.arrayTooLong(\"Cmds\", cmdsCount, 4096000);\n      } else {\n         int cmdsVarLen = VarInt.size(cmdsCount);\n         if ((long)(pos + cmdsVarLen) + (long)cmdsCount * 9L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Cmds\", pos + cmdsVarLen + cmdsCount * 9, buf.readableBytes());\n         } else {\n            pos += cmdsVarLen;\n            obj.cmds = new SetBlockCmd[cmdsCount];\n\n            for (int i = 0; i < cmdsCount; i++) {\n               obj.cmds[i] = SetBlockCmd.deserialize(buf, pos);\n               pos += SetBlockCmd.computeBytesConsumed(buf, pos);\n            }\n\n            return obj;\n         }\n      }\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int pos = offset + 12;\n      int arrLen = VarInt.peek(buf, pos);\n      pos += VarInt.length(buf, pos);\n\n      for (int i = 0; i < arrLen; i++) {\n         pos += SetBlockCmd.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 12) {\n         return ValidationResult.error(\"Buffer too small: expected at least 12 bytes\");\n      } else {\n         int pos = offset + 12;\n         int cmdsCount = VarInt.peek(buffer, pos);\n         if (cmdsCount < 0) {\n            return ValidationResult.error(\"Invalid array count for Cmds\");\n         } else if (cmdsCount > 4096000) {\n            return ValidationResult.error(\"Cmds exceeds max length 4096000\");\n         } else {\n            pos += VarInt.length(buffer, pos);\n            pos += cmdsCount * 9;\n            return pos > buffer.writerIndex() ? ValidationResult.error(\"Buffer overflow reading Cmds\") : ValidationResult.OK;\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, SetBlockCmd.deserialize, SetBlockCmd.computeBytesConsumed\n// Types referenced: SetBlockCmd\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerSetFluid",
        "packetId": 142,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "fluidId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "fluidLevel",
            "type": "byte",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ServerSetFluid\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 142;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 17;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 17;\npublic static final int MAX_SIZE = 17;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n@Nonnull int fluidId;\n@Nonnull byte fluidLevel;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerSetFluid deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerSetFluid obj = new ServerSetFluid();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      obj.fluidId = buf.getIntLE(offset + 12);\n      obj.fluidLevel = buf.getByte(offset + 16);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 17;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 17 ? ValidationResult.error(\"Buffer too small: expected at least 17 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerSetFluids",
        "packetId": 143,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "x",
            "type": "int",
            "nullable": false
          },
          {
            "name": "y",
            "type": "int",
            "nullable": false
          },
          {
            "name": "z",
            "type": "int",
            "nullable": false
          },
          {
            "name": "cmds",
            "type": "SetFluidCmd[]",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ServerSetFluids\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 143;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 12;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 12;\npublic static final int MAX_SIZE = 28672017;\n\n// === FIELDS ===\n@Nonnull int x;\n@Nonnull int y;\n@Nonnull int z;\n@Nonnull SetFluidCmd[] cmds;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerSetFluids deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerSetFluids obj = new ServerSetFluids();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      int pos = offset + 12;\n      int cmdsCount = VarInt.peek(buf, pos);\n      if (cmdsCount < 0) {\n         throw ProtocolException.negativeLength(\"Cmds\", cmdsCount);\n      } else if (cmdsCount > 4096000) {\n         throw ProtocolException.arrayTooLong(\"Cmds\", cmdsCount, 4096000);\n      } else {\n         int cmdsVarLen = VarInt.size(cmdsCount);\n         if ((long)(pos + cmdsVarLen) + (long)cmdsCount * 7L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Cmds\", pos + cmdsVarLen + cmdsCount * 7, buf.readableBytes());\n         } else {\n            pos += cmdsVarLen;\n            obj.cmds = new SetFluidCmd[cmdsCount];\n\n            for (int i = 0; i < cmdsCount; i++) {\n               obj.cmds[i] = SetFluidCmd.deserialize(buf, pos);\n               pos += SetFluidCmd.computeBytesConsumed(buf, pos);\n            }\n\n            return obj;\n         }\n      }\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static ServerSetFluids deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerSetFluids obj = new ServerSetFluids();\n      obj.x = buf.getIntLE(offset + 0);\n      obj.y = buf.getIntLE(offset + 4);\n      obj.z = buf.getIntLE(offset + 8);\n      int pos = offset + 12;\n      int cmdsCount = VarInt.peek(buf, pos);\n      if (cmdsCount < 0) {\n         throw ProtocolException.negativeLength(\"Cmds\", cmdsCount);\n      } else if (cmdsCount > 4096000) {\n         throw ProtocolException.arrayTooLong(\"Cmds\", cmdsCount, 4096000);\n      } else {\n         int cmdsVarLen = VarInt.size(cmdsCount);\n         if ((long)(pos + cmdsVarLen) + (long)cmdsCount * 7L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Cmds\", pos + cmdsVarLen + cmdsCount * 7, buf.readableBytes());\n         } else {\n            pos += cmdsVarLen;\n            obj.cmds = new SetFluidCmd[cmdsCount];\n\n            for (int i = 0; i < cmdsCount; i++) {\n               obj.cmds[i] = SetFluidCmd.deserialize(buf, pos);\n               pos += SetFluidCmd.computeBytesConsumed(buf, pos);\n            }\n\n            return obj;\n         }\n      }\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int pos = offset + 12;\n      int arrLen = VarInt.peek(buf, pos);\n      pos += VarInt.length(buf, pos);\n\n      for (int i = 0; i < arrLen; i++) {\n         pos += SetFluidCmd.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 12) {\n         return ValidationResult.error(\"Buffer too small: expected at least 12 bytes\");\n      } else {\n         int pos = offset + 12;\n         int cmdsCount = VarInt.peek(buffer, pos);\n         if (cmdsCount < 0) {\n            return ValidationResult.error(\"Invalid array count for Cmds\");\n         } else if (cmdsCount > 4096000) {\n            return ValidationResult.error(\"Cmds exceeds max length 4096000\");\n         } else {\n            pos += VarInt.length(buffer, pos);\n            pos += cmdsCount * 7;\n            return pos > buffer.writerIndex() ? ValidationResult.error(\"Buffer overflow reading Cmds\") : ValidationResult.OK;\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, SetFluidCmd.deserialize, SetFluidCmd.computeBytesConsumed\n// Types referenced: SetFluidCmd\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateBlockDamage",
        "packetId": 144,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "blockPosition",
            "type": "BlockPosition",
            "nullable": true
          },
          {
            "name": "damage",
            "type": "float",
            "nullable": false
          },
          {
            "name": "delta",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateBlockDamage\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 144;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 21;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 21;\npublic static final int MAX_SIZE = 21;\n\n// === FIELDS ===\n@Nullable BlockPosition blockPosition;\n@Nonnull float damage;\n@Nonnull float delta;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateBlockDamage deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockDamage obj = new UpdateBlockDamage();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.blockPosition = BlockPosition.deserialize(buf, offset + 1);\n      }\n\n      obj.damage = buf.getFloatLE(offset + 13);\n      obj.delta = buf.getFloatLE(offset + 17);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateBlockDamage deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateBlockDamage obj = new UpdateBlockDamage();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.blockPosition = BlockPosition.deserialize(buf, offset + 1);\n      }\n\n      obj.damage = buf.getFloatLE(offset + 13);\n      obj.delta = buf.getFloatLE(offset + 17);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 21;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 21 ? ValidationResult.error(\"Buffer too small: expected at least 21 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, BlockPosition.deserialize, buf.getFloatLE\n// Types referenced: BlockPosition\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateTimeSettings",
        "packetId": 145,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "daytimeDurationSeconds",
            "type": "int",
            "nullable": false
          },
          {
            "name": "nighttimeDurationSeconds",
            "type": "int",
            "nullable": false
          },
          {
            "name": "totalMoonPhases",
            "type": "byte",
            "nullable": false
          },
          {
            "name": "timePaused",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateTimeSettings\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 145;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 10;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 10;\npublic static final int MAX_SIZE = 10;\n\n// === FIELDS ===\n@Nonnull int daytimeDurationSeconds;\n@Nonnull int nighttimeDurationSeconds;\n@Nonnull byte totalMoonPhases;\n@Nonnull boolean timePaused;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateTimeSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateTimeSettings obj = new UpdateTimeSettings();\n      obj.daytimeDurationSeconds = buf.getIntLE(offset + 0);\n      obj.nighttimeDurationSeconds = buf.getIntLE(offset + 4);\n      obj.totalMoonPhases = buf.getByte(offset + 8);\n      obj.timePaused = buf.getByte(offset + 9) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 10;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 10 ? ValidationResult.error(\"Buffer too small: expected at least 10 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateTime",
        "packetId": 146,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "gameTime",
            "type": "InstantData",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateTime\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 146;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 13;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 13;\n\n// === FIELDS ===\n@Nullable InstantData gameTime;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateTime deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateTime obj = new UpdateTime();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.gameTime = InstantData.deserialize(buf, offset + 1);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateTime deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateTime obj = new UpdateTime();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.gameTime = InstantData.deserialize(buf, offset + 1);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 13;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 13 ? ValidationResult.error(\"Buffer too small: expected at least 13 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, InstantData.deserialize\n// Types referenced: InstantData\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateEditorTimeOverride",
        "packetId": 147,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "gameTime",
            "type": "InstantData",
            "nullable": true
          },
          {
            "name": "paused",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateEditorTimeOverride\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 147;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 14;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 14;\npublic static final int MAX_SIZE = 14;\n\n// === FIELDS ===\n@Nullable InstantData gameTime;\n@Nonnull boolean paused;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateEditorTimeOverride deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEditorTimeOverride obj = new UpdateEditorTimeOverride();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.gameTime = InstantData.deserialize(buf, offset + 1);\n      }\n\n      obj.paused = buf.getByte(offset + 13) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateEditorTimeOverride deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEditorTimeOverride obj = new UpdateEditorTimeOverride();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 1) != 0) {\n         obj.gameTime = InstantData.deserialize(buf, offset + 1);\n      }\n\n      obj.paused = buf.getByte(offset + 13) != 0;\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 14;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 14 ? ValidationResult.error(\"Buffer too small: expected at least 14 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, InstantData.deserialize\n// Types referenced: InstantData\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ClearEditorTimeOverride",
        "packetId": 148,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [],
        "deserializeContext": "// Packet: ClearEditorTimeOverride\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 148;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ClearEditorTimeOverride deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new ClearEditorTimeOverride();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateWeather",
        "packetId": 149,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "weatherIndex",
            "type": "int",
            "nullable": false
          },
          {
            "name": "transitionSeconds",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateWeather\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 149;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 8;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 8;\npublic static final int MAX_SIZE = 8;\n\n// === FIELDS ===\n@Nonnull int weatherIndex;\n@Nonnull float transitionSeconds;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateWeather deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateWeather obj = new UpdateWeather();\n      obj.weatherIndex = buf.getIntLE(offset + 0);\n      obj.transitionSeconds = buf.getFloatLE(offset + 4);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 8;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 8 ? ValidationResult.error(\"Buffer too small: expected at least 8 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getFloatLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateEditorWeatherOverride",
        "packetId": 150,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "weatherIndex",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateEditorWeatherOverride\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 150;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int weatherIndex;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateEditorWeatherOverride deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEditorWeatherOverride obj = new UpdateEditorWeatherOverride();\n      obj.weatherIndex = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateEnvironmentMusic",
        "packetId": 151,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "environmentIndex",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateEnvironmentMusic\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 151;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 4;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 4;\npublic static final int MAX_SIZE = 4;\n\n// === FIELDS ===\n@Nonnull int environmentIndex;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateEnvironmentMusic deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateEnvironmentMusic obj = new UpdateEnvironmentMusic();\n      obj.environmentIndex = buf.getIntLE(offset + 0);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 4;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 4 ? ValidationResult.error(\"Buffer too small: expected at least 4 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SpawnParticleSystem",
        "packetId": 152,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "particleSystemId",
            "type": "String",
            "nullable": true
          },
          {
            "name": "position",
            "type": "Position",
            "nullable": true
          },
          {
            "name": "rotation",
            "type": "Direction",
            "nullable": true
          },
          {
            "name": "scale",
            "type": "float",
            "nullable": false
          },
          {
            "name": "color",
            "type": "Color",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SpawnParticleSystem\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 152;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 44;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 44;\npublic static final int MAX_SIZE = 16384049;\n\n// === FIELDS ===\n@Nullable String particleSystemId;\n@Nullable Position position;\n@Nullable Direction rotation;\n@Nonnull float scale;\n@Nullable Color color;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SpawnParticleSystem deserialize(@Nonnull ByteBuf buf, int offset) {\n      SpawnParticleSystem obj = new SpawnParticleSystem();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 2) != 0) {\n         obj.position = Position.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         obj.rotation = Direction.deserialize(buf, offset + 25);\n      }\n\n      obj.scale = buf.getFloatLE(offset + 37);\n      if ((nullBits & 8) != 0) {\n         obj.color = Color.deserialize(buf, offset + 41);\n      }\n\n      int pos = offset + 44;\n      if ((nullBits & 1) != 0) {\n         int particleSystemIdLen = VarInt.peek(buf, pos);\n         if (particleSystemIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ParticleSystemId\", particleSystemIdLen);\n         }\n\n         if (particleSystemIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ParticleSystemId\", particleSystemIdLen, 4096000);\n         }\n\n         int particleSystemIdVarLen = VarInt.length(buf, pos);\n         obj.particleSystemId = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += particleSystemIdVarLen + particleSystemIdLen;\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SpawnParticleSystem deserialize(@Nonnull ByteBuf buf, int offset) {\n      SpawnParticleSystem obj = new SpawnParticleSystem();\n      byte nullBits = buf.getByte(offset);\n      if ((nullBits & 2) != 0) {\n         obj.position = Position.deserialize(buf, offset + 1);\n      }\n\n      if ((nullBits & 4) != 0) {\n         obj.rotation = Direction.deserialize(buf, offset + 25);\n      }\n\n      obj.scale = buf.getFloatLE(offset + 37);\n      if ((nullBits & 8) != 0) {\n         obj.color = Color.deserialize(buf, offset + 41);\n      }\n\n      int pos = offset + 44;\n      if ((nullBits & 1) != 0) {\n         int particleSystemIdLen = VarInt.peek(buf, pos);\n         if (particleSystemIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ParticleSystemId\", particleSystemIdLen);\n         }\n\n         if (particleSystemIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ParticleSystemId\", particleSystemIdLen, 4096000);\n         }\n\n         int particleSystemIdVarLen = VarInt.length(buf, pos);\n         obj.particleSystemId = PacketIO.readVarString(buf, pos, PacketIO.UTF8);\n         pos += particleSystemIdVarLen + particleSystemIdLen;\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 44;\n      if ((nullBits & 1) != 0) {\n         int sl = VarInt.peek(buf, pos);\n         pos += VarInt.length(buf, pos) + sl;\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 44) {\n         return ValidationResult.error(\"Buffer too small: expected at least 44 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 44;\n         if ((nullBits & 1) != 0) {\n            int particleSystemIdLen = VarInt.peek(buffer, pos);\n            if (particleSystemIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ParticleSystemId\");\n            }\n\n            if (particleSystemIdLen > 4096000) {\n               return ValidationResult.error(\"ParticleSystemId exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += particleSystemIdLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ParticleSystemId\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, Position.deserialize, Direction.deserialize, buf.getFloatLE, Color.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, VarInt.length, PacketIO.readVarString\n// Types referenced: Position, Direction, Color\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SpawnBlockParticleSystem",
        "packetId": 153,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "blockId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "particleType",
            "type": "BlockParticleEvent",
            "nullable": false
          },
          {
            "name": "position",
            "type": "Position",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SpawnBlockParticleSystem\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 153;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 30;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 30;\npublic static final int MAX_SIZE = 30;\n\n// === FIELDS ===\n@Nonnull int blockId;\n@Nonnull BlockParticleEvent particleType;\n@Nullable Position position;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SpawnBlockParticleSystem deserialize(@Nonnull ByteBuf buf, int offset) {\n      SpawnBlockParticleSystem obj = new SpawnBlockParticleSystem();\n      byte nullBits = buf.getByte(offset);\n      obj.blockId = buf.getIntLE(offset + 1);\n      obj.particleType = BlockParticleEvent.fromValue(buf.getByte(offset + 5));\n      if ((nullBits & 1) != 0) {\n         obj.position = Position.deserialize(buf, offset + 6);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SpawnBlockParticleSystem deserialize(@Nonnull ByteBuf buf, int offset) {\n      SpawnBlockParticleSystem obj = new SpawnBlockParticleSystem();\n      byte nullBits = buf.getByte(offset);\n      obj.blockId = buf.getIntLE(offset + 1);\n      obj.particleType = BlockParticleEvent.fromValue(buf.getByte(offset + 5));\n      if ((nullBits & 1) != 0) {\n         obj.position = Position.deserialize(buf, offset + 6);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 30;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 30 ? ValidationResult.error(\"Buffer too small: expected at least 30 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, BlockParticleEvent.fromValue, Position.deserialize\n// Types referenced: BlockParticleEvent, Position\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PlaySoundEvent2D",
        "packetId": 154,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "soundEventIndex",
            "type": "int",
            "nullable": false
          },
          {
            "name": "category",
            "type": "SoundCategory",
            "nullable": false
          },
          {
            "name": "volumeModifier",
            "type": "float",
            "nullable": false
          },
          {
            "name": "pitchModifier",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: PlaySoundEvent2D\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 154;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 13;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 13;\npublic static final int MAX_SIZE = 13;\n\n// === FIELDS ===\n@Nonnull int soundEventIndex;\n@Nonnull SoundCategory category;\n@Nonnull float volumeModifier;\n@Nonnull float pitchModifier;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PlaySoundEvent2D deserialize(@Nonnull ByteBuf buf, int offset) {\n      PlaySoundEvent2D obj = new PlaySoundEvent2D();\n      obj.soundEventIndex = buf.getIntLE(offset + 0);\n      obj.category = SoundCategory.fromValue(buf.getByte(offset + 4));\n      obj.volumeModifier = buf.getFloatLE(offset + 5);\n      obj.pitchModifier = buf.getFloatLE(offset + 9);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 13;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 13 ? ValidationResult.error(\"Buffer too small: expected at least 13 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, SoundCategory.fromValue, buf.getByte, buf.getFloatLE\n// Types referenced: SoundCategory\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PlaySoundEvent3D",
        "packetId": 155,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "soundEventIndex",
            "type": "int",
            "nullable": false
          },
          {
            "name": "category",
            "type": "SoundCategory",
            "nullable": false
          },
          {
            "name": "position",
            "type": "Position",
            "nullable": true
          },
          {
            "name": "volumeModifier",
            "type": "float",
            "nullable": false
          },
          {
            "name": "pitchModifier",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: PlaySoundEvent3D\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 155;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 38;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 38;\npublic static final int MAX_SIZE = 38;\n\n// === FIELDS ===\n@Nonnull int soundEventIndex;\n@Nonnull SoundCategory category;\n@Nullable Position position;\n@Nonnull float volumeModifier;\n@Nonnull float pitchModifier;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PlaySoundEvent3D deserialize(@Nonnull ByteBuf buf, int offset) {\n      PlaySoundEvent3D obj = new PlaySoundEvent3D();\n      byte nullBits = buf.getByte(offset);\n      obj.soundEventIndex = buf.getIntLE(offset + 1);\n      obj.category = SoundCategory.fromValue(buf.getByte(offset + 5));\n      if ((nullBits & 1) != 0) {\n         obj.position = Position.deserialize(buf, offset + 6);\n      }\n\n      obj.volumeModifier = buf.getFloatLE(offset + 30);\n      obj.pitchModifier = buf.getFloatLE(offset + 34);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static PlaySoundEvent3D deserialize(@Nonnull ByteBuf buf, int offset) {\n      PlaySoundEvent3D obj = new PlaySoundEvent3D();\n      byte nullBits = buf.getByte(offset);\n      obj.soundEventIndex = buf.getIntLE(offset + 1);\n      obj.category = SoundCategory.fromValue(buf.getByte(offset + 5));\n      if ((nullBits & 1) != 0) {\n         obj.position = Position.deserialize(buf, offset + 6);\n      }\n\n      obj.volumeModifier = buf.getFloatLE(offset + 30);\n      obj.pitchModifier = buf.getFloatLE(offset + 34);\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 38;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 38 ? ValidationResult.error(\"Buffer too small: expected at least 38 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, SoundCategory.fromValue, Position.deserialize, buf.getFloatLE\n// Types referenced: SoundCategory, Position\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PlaySoundEventEntity",
        "packetId": 156,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "soundEventIndex",
            "type": "int",
            "nullable": false
          },
          {
            "name": "networkId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "volumeModifier",
            "type": "float",
            "nullable": false
          },
          {
            "name": "pitchModifier",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: PlaySoundEventEntity\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 156;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 16;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 16;\npublic static final int MAX_SIZE = 16;\n\n// === FIELDS ===\n@Nonnull int soundEventIndex;\n@Nonnull int networkId;\n@Nonnull float volumeModifier;\n@Nonnull float pitchModifier;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PlaySoundEventEntity deserialize(@Nonnull ByteBuf buf, int offset) {\n      PlaySoundEventEntity obj = new PlaySoundEventEntity();\n      obj.soundEventIndex = buf.getIntLE(offset + 0);\n      obj.networkId = buf.getIntLE(offset + 4);\n      obj.volumeModifier = buf.getFloatLE(offset + 8);\n      obj.pitchModifier = buf.getFloatLE(offset + 12);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 16;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 16 ? ValidationResult.error(\"Buffer too small: expected at least 16 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getIntLE, buf.getFloatLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateSleepState",
        "packetId": 157,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "grayFade",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "sleepUi",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "clock",
            "type": "SleepClock",
            "nullable": true
          },
          {
            "name": "multiplayer",
            "type": "SleepMultiplayer",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: UpdateSleepState\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 157;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 36;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 36;\npublic static final int MAX_SIZE = 65536050;\n\n// === FIELDS ===\n@Nonnull boolean grayFade;\n@Nonnull boolean sleepUi;\n@Nullable SleepClock clock;\n@Nullable SleepMultiplayer multiplayer;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateSleepState deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateSleepState obj = new UpdateSleepState();\n      byte nullBits = buf.getByte(offset);\n      obj.grayFade = buf.getByte(offset + 1) != 0;\n      obj.sleepUi = buf.getByte(offset + 2) != 0;\n      if ((nullBits & 1) != 0) {\n         obj.clock = SleepClock.deserialize(buf, offset + 3);\n      }\n\n      int pos = offset + 36;\n      if ((nullBits & 2) != 0) {\n         obj.multiplayer = SleepMultiplayer.deserialize(buf, pos);\n         pos += SleepMultiplayer.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static UpdateSleepState deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateSleepState obj = new UpdateSleepState();\n      byte nullBits = buf.getByte(offset);\n      obj.grayFade = buf.getByte(offset + 1) != 0;\n      obj.sleepUi = buf.getByte(offset + 2) != 0;\n      if ((nullBits & 1) != 0) {\n         obj.clock = SleepClock.deserialize(buf, offset + 3);\n      }\n\n      int pos = offset + 36;\n      if ((nullBits & 2) != 0) {\n         obj.multiplayer = SleepMultiplayer.deserialize(buf, pos);\n         pos += SleepMultiplayer.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 36;\n      if ((nullBits & 2) != 0) {\n         pos += SleepMultiplayer.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 36) {\n         return ValidationResult.error(\"Buffer too small: expected at least 36 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 36;\n         if ((nullBits & 2) != 0) {\n            ValidationResult multiplayerResult = SleepMultiplayer.validateStructure(buffer, pos);\n            if (!multiplayerResult.isValid()) {\n               return ValidationResult.error(\"Invalid Multiplayer: \" + multiplayerResult.error());\n            }\n\n            pos += SleepMultiplayer.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, SleepClock.deserialize, SleepMultiplayer.deserialize, SleepMultiplayer.computeBytesConsumed\n// Types referenced: SleepClock, SleepMultiplayer\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SetPaused",
        "packetId": 158,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "paused",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SetPaused\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 158;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean paused;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SetPaused deserialize(@Nonnull ByteBuf buf, int offset) {\n      SetPaused obj = new SetPaused();\n      obj.paused = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "ServerSetPaused",
        "packetId": 159,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "paused",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: ServerSetPaused\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 159;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 1;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 1;\npublic static final int MAX_SIZE = 1;\n\n// === FIELDS ===\n@Nonnull boolean paused;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static ServerSetPaused deserialize(@Nonnull ByteBuf buf, int offset) {\n      ServerSetPaused obj = new ServerSetPaused();\n      obj.paused = buf.getByte(offset + 0) != 0;\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 1;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 1 ? ValidationResult.error(\"Buffer too small: expected at least 1 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdateSunSettings",
        "packetId": 360,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "heightPercentage",
            "type": "float",
            "nullable": false
          },
          {
            "name": "angleRadians",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdateSunSettings\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 360;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 8;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 8;\npublic static final int MAX_SIZE = 8;\n\n// === FIELDS ===\n@Nonnull float heightPercentage;\n@Nonnull float angleRadians;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdateSunSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdateSunSettings obj = new UpdateSunSettings();\n      obj.heightPercentage = buf.getFloatLE(offset + 0);\n      obj.angleRadians = buf.getFloatLE(offset + 4);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 8;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 8 ? ValidationResult.error(\"Buffer too small: expected at least 8 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getFloatLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "UpdatePostFxSettings",
        "packetId": 361,
        "package": "com.hypixel.hytale.protocol.packets.world",
        "fields": [
          {
            "name": "globalIntensity",
            "type": "float",
            "nullable": false
          },
          {
            "name": "power",
            "type": "float",
            "nullable": false
          },
          {
            "name": "sunshaftScale",
            "type": "float",
            "nullable": false
          },
          {
            "name": "sunIntensity",
            "type": "float",
            "nullable": false
          },
          {
            "name": "sunshaftIntensity",
            "type": "float",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: UpdatePostFxSettings\n// Package: com.hypixel.hytale.protocol.packets.world\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 361;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 20;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 20;\npublic static final int MAX_SIZE = 20;\n\n// === FIELDS ===\n@Nonnull float globalIntensity;\n@Nonnull float power;\n@Nonnull float sunshaftScale;\n@Nonnull float sunIntensity;\n@Nonnull float sunshaftIntensity;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static UpdatePostFxSettings deserialize(@Nonnull ByteBuf buf, int offset) {\n      UpdatePostFxSettings obj = new UpdatePostFxSettings();\n      obj.globalIntensity = buf.getFloatLE(offset + 0);\n      obj.power = buf.getFloatLE(offset + 4);\n      obj.sunshaftScale = buf.getFloatLE(offset + 8);\n      obj.sunIntensity = buf.getFloatLE(offset + 12);\n      obj.sunshaftIntensity = buf.getFloatLE(offset + 16);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 20;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 20 ? ValidationResult.error(\"Buffer too small: expected at least 20 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getFloatLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ],
    "interaction": [
      {
        "name": "SyncInteractionChain",
        "package": "com.hypixel.hytale.protocol.packets.interaction",
        "fields": [
          {
            "name": "activeHotbarSlot",
            "type": "int",
            "nullable": false
          },
          {
            "name": "activeUtilitySlot",
            "type": "int",
            "nullable": false
          },
          {
            "name": "activeToolsSlot",
            "type": "int",
            "nullable": false
          },
          {
            "name": "itemInHandId",
            "type": "String",
            "nullable": true
          },
          {
            "name": "utilityItemId",
            "type": "String",
            "nullable": true
          },
          {
            "name": "toolsItemId",
            "type": "String",
            "nullable": true
          },
          {
            "name": "initial",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "desync",
            "type": "boolean",
            "nullable": false
          },
          {
            "name": "overrideRootInteraction",
            "type": "int",
            "nullable": false
          },
          {
            "name": "interactionType",
            "type": "InteractionType",
            "nullable": false
          },
          {
            "name": "equipSlot",
            "type": "int",
            "nullable": false
          },
          {
            "name": "chainId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "forkedId",
            "type": "ForkedChainId",
            "nullable": true
          },
          {
            "name": "data",
            "type": "InteractionChainData",
            "nullable": true
          },
          {
            "name": "state",
            "type": "InteractionState",
            "nullable": false
          },
          {
            "name": "newForks",
            "type": "SyncInteractionChain[]",
            "nullable": true
          },
          {
            "name": "operationBaseIndex",
            "type": "int",
            "nullable": false
          },
          {
            "name": "interactionData",
            "type": "InteractionSyncData[]",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: SyncInteractionChain\n// Package: com.hypixel.hytale.protocol.packets.interaction\n\n// === CONSTANTS ===\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 33;\npublic static final int VARIABLE_FIELD_COUNT = 7;\npublic static final int VARIABLE_BLOCK_START = 61;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull int activeHotbarSlot;\n@Nonnull int activeUtilitySlot;\n@Nonnull int activeToolsSlot;\n@Nullable String itemInHandId;\n@Nullable String utilityItemId;\n@Nullable String toolsItemId;\n@Nonnull boolean initial;\n@Nonnull boolean desync;\n@Nonnull int overrideRootInteraction;\n@Nonnull InteractionType interactionType;\n@Nonnull int equipSlot;\n@Nonnull int chainId;\n@Nullable ForkedChainId forkedId;\n@Nullable InteractionChainData data;\n@Nonnull InteractionState state;\n@Nullable SyncInteractionChain[] newForks;\n@Nonnull int operationBaseIndex;\n@Nullable InteractionSyncData[] interactionData;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SyncInteractionChain deserialize(@Nonnull ByteBuf buf, int offset) {\n      SyncInteractionChain obj = new SyncInteractionChain();\n      byte nullBits = buf.getByte(offset);\n      obj.activeHotbarSlot = buf.getIntLE(offset + 1);\n      obj.activeUtilitySlot = buf.getIntLE(offset + 5);\n      obj.activeToolsSlot = buf.getIntLE(offset + 9);\n      obj.initial = buf.getByte(offset + 13) != 0;\n      obj.desync = buf.getByte(offset + 14) != 0;\n      obj.overrideRootInteraction = buf.getIntLE(offset + 15);\n      obj.interactionType = InteractionType.fromValue(buf.getByte(offset + 19));\n      obj.equipSlot = buf.getIntLE(offset + 20);\n      obj.chainId = buf.getIntLE(offset + 24);\n      obj.state = InteractionState.fromValue(buf.getByte(offset + 28));\n      obj.operationBaseIndex = buf.getIntLE(offset + 29);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 61 + buf.getIntLE(offset + 33);\n         int itemInHandIdLen = VarInt.peek(buf, varPos0);\n         if (itemInHandIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ItemInHandId\", itemInHandIdLen);\n         }\n\n         if (itemInHandIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ItemInHandId\", itemInHandIdLen, 4096000);\n         }\n\n         obj.itemInHandId = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 61 + buf.getIntLE(offset + 37);\n         int utilityItemIdLen = VarInt.peek(buf, varPos1);\n         if (utilityItemIdLen < 0) {\n            throw ProtocolException.negativeLength(\"UtilityItemId\", utilityItemIdLen);\n         }\n\n         if (utilityItemIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"UtilityItemId\", utilityItemIdLen, 4096000);\n         }\n\n         obj.utilityItemId = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 61 + buf.getIntLE(offset + 41);\n         int toolsItemIdLen = VarInt.peek(buf, varPos2);\n         if (toolsItemIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ToolsItemId\", toolsItemIdLen);\n         }\n\n         if (toolsItemIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ToolsItemId\", toolsItemIdLen, 4096000);\n         }\n\n         obj.toolsItemId = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 61 + buf.getIntLE(offset + 45);\n         obj.forkedId = ForkedChainId.deserialize(buf, varPos3);\n      }\n\n      if ((nullBits & 16) != 0) {\n         int varPos4 = offset + 61 + buf.getIntLE(offset + 49);\n         obj.data = InteractionChainData.deserialize(buf, varPos4);\n      }\n\n      if ((nullBits & 32) != 0) {\n         int varPos5 = offset + 61 + buf.getIntLE(offset + 53);\n         int newForksCount = VarInt.peek(buf, varPos5);\n         if (newForksCount < 0) {\n            throw ProtocolException.negativeLength(\"NewForks\", newForksCount);\n         }\n\n         if (newForksCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"NewForks\", newForksCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos5);\n         if ((long)(varPos5 + varIntLen) + (long)newForksCount * 33L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"NewForks\", varPos5 + varIntLen + newForksCount * 33, buf.readableBytes());\n         }\n\n         obj.newForks = new SyncInteractionChain[newForksCount];\n         int elemPos = varPos5 + varIntLen;\n\n         for (int i = 0; i < newForksCount; i++) {\n            obj.newForks[i] = deserialize(buf, elemPos);\n            elemPos += computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 64) != 0) {\n         int varPos6 = offset + 61 + buf.getIntLE(offset + 57);\n         int interactionDataCount = VarInt.peek(buf, varPos6);\n         if (interactionDataCount < 0) {\n            throw ProtocolException.negativeLength(\"InteractionData\", interactionDataCount);\n         }\n\n         if (interactionDataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"InteractionData\", interactionDataCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos6);\n         int interactionDataBitfieldSize = (interactionDataCount + 7) / 8;\n         byte[] interactionDataBitfield = PacketIO.readBytes(buf, varPos6 + varIntLen, interactionDataBitfieldSize);\n         obj.interactionData = new InteractionSyncData[interactionDataCount];\n         int elemPos = varPos6 + varIntLen + interactionDataBitfieldSize;\n\n         for (int i = 0; i < interactionDataCount; i++) {\n            if ((interactionDataBitfield[i / 8] & 1 << i % 8) != 0) {\n               obj.interactionData[i] = InteractionSyncData.deserialize(buf, elemPos);\n               elemPos += InteractionSyncData.computeBytesConsumed(buf, elemPos);\n            }\n         }\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SyncInteractionChain deserialize(@Nonnull ByteBuf buf, int offset) {\n      SyncInteractionChain obj = new SyncInteractionChain();\n      byte nullBits = buf.getByte(offset);\n      obj.activeHotbarSlot = buf.getIntLE(offset + 1);\n      obj.activeUtilitySlot = buf.getIntLE(offset + 5);\n      obj.activeToolsSlot = buf.getIntLE(offset + 9);\n      obj.initial = buf.getByte(offset + 13) != 0;\n      obj.desync = buf.getByte(offset + 14) != 0;\n      obj.overrideRootInteraction = buf.getIntLE(offset + 15);\n      obj.interactionType = InteractionType.fromValue(buf.getByte(offset + 19));\n      obj.equipSlot = buf.getIntLE(offset + 20);\n      obj.chainId = buf.getIntLE(offset + 24);\n      obj.state = InteractionState.fromValue(buf.getByte(offset + 28));\n      obj.operationBaseIndex = buf.getIntLE(offset + 29);\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 61 + buf.getIntLE(offset + 33);\n         int itemInHandIdLen = VarInt.peek(buf, varPos0);\n         if (itemInHandIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ItemInHandId\", itemInHandIdLen);\n         }\n\n         if (itemInHandIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ItemInHandId\", itemInHandIdLen, 4096000);\n         }\n\n         obj.itemInHandId = PacketIO.readVarString(buf, varPos0, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 61 + buf.getIntLE(offset + 37);\n         int utilityItemIdLen = VarInt.peek(buf, varPos1);\n         if (utilityItemIdLen < 0) {\n            throw ProtocolException.negativeLength(\"UtilityItemId\", utilityItemIdLen);\n         }\n\n         if (utilityItemIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"UtilityItemId\", utilityItemIdLen, 4096000);\n         }\n\n         obj.utilityItemId = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 4) != 0) {\n         int varPos2 = offset + 61 + buf.getIntLE(offset + 41);\n         int toolsItemIdLen = VarInt.peek(buf, varPos2);\n         if (toolsItemIdLen < 0) {\n            throw ProtocolException.negativeLength(\"ToolsItemId\", toolsItemIdLen);\n         }\n\n         if (toolsItemIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"ToolsItemId\", toolsItemIdLen, 4096000);\n         }\n\n         obj.toolsItemId = PacketIO.readVarString(buf, varPos2, PacketIO.UTF8);\n      }\n\n      if ((nullBits & 8) != 0) {\n         int varPos3 = offset + 61 + buf.getIntLE(offset + 45);\n         obj.forkedId = ForkedChainId.deserialize(buf, varPos3);\n      }\n\n      if ((nullBits & 16) != 0) {\n         int varPos4 = offset + 61 + buf.getIntLE(offset + 49);\n         obj.data = InteractionChainData.deserialize(buf, varPos4);\n      }\n\n      if ((nullBits & 32) != 0) {\n         int varPos5 = offset + 61 + buf.getIntLE(offset + 53);\n         int newForksCount = VarInt.peek(buf, varPos5);\n         if (newForksCount < 0) {\n            throw ProtocolException.negativeLength(\"NewForks\", newForksCount);\n         }\n\n         if (newForksCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"NewForks\", newForksCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos5);\n         if ((long)(varPos5 + varIntLen) + (long)newForksCount * 33L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"NewForks\", varPos5 + varIntLen + newForksCount * 33, buf.readableBytes());\n         }\n\n         obj.newForks = new SyncInteractionChain[newForksCount];\n         int elemPos = varPos5 + varIntLen;\n\n         for (int i = 0; i < newForksCount; i++) {\n            obj.newForks[i] = deserialize(buf, elemPos);\n            elemPos += computeBytesConsumed(buf, elemPos);\n         }\n      }\n\n      if ((nullBits & 64) != 0) {\n         int varPos6 = offset + 61 + buf.getIntLE(offset + 57);\n         int interactionDataCount = VarInt.peek(buf, varPos6);\n         if (interactionDataCount < 0) {\n            throw ProtocolException.negativeLength(\"InteractionData\", interactionDataCount);\n         }\n\n         if (interactionDataCount > 4096000) {\n            throw ProtocolException.arrayTooLong(\"InteractionData\", interactionDataCount, 4096000);\n         }\n\n         int varIntLen = VarInt.length(buf, varPos6);\n         int interactionDataBitfieldSize = (interactionDataCount + 7) / 8;\n         byte[] interactionDataBitfield = PacketIO.readBytes(buf, varPos6 + varIntLen, interactionDataBitfieldSize);\n         obj.interactionData = new InteractionSyncData[interactionDataCount];\n         int elemPos = varPos6 + varIntLen + interactionDataBitfieldSize;\n\n         for (int i = 0; i < interactionDataCount; i++) {\n            if ((interactionDataBitfield[i / 8] & 1 << i % 8) != 0) {\n               obj.interactionData[i] = InteractionSyncData.deserialize(buf, elemPos);\n               elemPos += InteractionSyncData.computeBytesConsumed(buf, elemPos);\n            }\n         }\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 61;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 33);\n         int pos0 = offset + 61 + fieldOffset0;\n         int sl = VarInt.peek(buf, pos0);\n         pos0 += VarInt.length(buf, pos0) + sl;\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 37);\n         int pos1 = offset + 61 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      if ((nullBits & 4) != 0) {\n         int fieldOffset2 = buf.getIntLE(offset + 41);\n         int pos2 = offset + 61 + fieldOffset2;\n         int sl = VarInt.peek(buf, pos2);\n         pos2 += VarInt.length(buf, pos2) + sl;\n         if (pos2 - offset > maxEnd) {\n            maxEnd = pos2 - offset;\n         }\n      }\n\n      if ((nullBits & 8) != 0) {\n         int fieldOffset3 = buf.getIntLE(offset + 45);\n         int pos3 = offset + 61 + fieldOffset3;\n         pos3 += ForkedChainId.computeBytesConsumed(buf, pos3);\n         if (pos3 - offset > maxEnd) {\n            maxEnd = pos3 - offset;\n         }\n      }\n\n      if ((nullBits & 16) != 0) {\n         int fieldOffset4 = buf.getIntLE(offset + 49);\n         int pos4 = offset + 61 + fieldOffset4;\n         pos4 += InteractionChainData.computeBytesConsumed(buf, pos4);\n         if (pos4 - offset > maxEnd) {\n            maxEnd = pos4 - offset;\n         }\n      }\n\n      if ((nullBits & 32) != 0) {\n         int fieldOffset5 = buf.getIntLE(offset + 53);\n         int pos5 = offset + 61 + fieldOffset5;\n         int arrLen = VarInt.peek(buf, pos5);\n         pos5 += VarInt.length(buf, pos5);\n\n         for (int i = 0; i < arrLen; i++) {\n            pos5 += computeBytesConsumed(buf, pos5);\n         }\n\n         if (pos5 - offset > maxEnd) {\n            maxEnd = pos5 - offset;\n         }\n      }\n\n      if ((nullBits & 64) != 0) {\n         int fieldOffset6 = buf.getIntLE(offset + 57);\n         int pos6 = offset + 61 + fieldOffset6;\n         int arrLen = VarInt.peek(buf, pos6);\n         pos6 += VarInt.length(buf, pos6);\n         int bitfieldSize = (arrLen + 7) / 8;\n         byte[] bitfield = PacketIO.readBytes(buf, pos6, bitfieldSize);\n         pos6 += bitfieldSize;\n\n         for (int i = 0; i < arrLen; i++) {\n            if ((bitfield[i / 8] & 1 << i % 8) != 0) {\n               pos6 += InteractionSyncData.computeBytesConsumed(buf, pos6);\n            }\n         }\n\n         if (pos6 - offset > maxEnd) {\n            maxEnd = pos6 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 61) {\n         return ValidationResult.error(\"Buffer too small: expected at least 61 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int itemInHandIdOffset = buffer.getIntLE(offset + 33);\n            if (itemInHandIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ItemInHandId\");\n            }\n\n            int pos = offset + 61 + itemInHandIdOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ItemInHandId\");\n            }\n\n            int itemInHandIdLen = VarInt.peek(buffer, pos);\n            if (itemInHandIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ItemInHandId\");\n            }\n\n            if (itemInHandIdLen > 4096000) {\n               return ValidationResult.error(\"ItemInHandId exceeds max length 4096000\");\n            }\n\n            pos += VarInt.length(buffer, pos);\n            pos += itemInHandIdLen;\n            if (pos > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ItemInHandId\");\n            }\n         }\n\n         if ((nullBits & 2) != 0) {\n            int utilityItemIdOffset = buffer.getIntLE(offset + 37);\n            if (utilityItemIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for UtilityItemId\");\n            }\n\n            int posx = offset + 61 + utilityItemIdOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for UtilityItemId\");\n            }\n\n            int utilityItemIdLen = VarInt.peek(buffer, posx);\n            if (utilityItemIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for UtilityItemId\");\n            }\n\n            if (utilityItemIdLen > 4096000) {\n               return ValidationResult.error(\"UtilityItemId exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += utilityItemIdLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading UtilityItemId\");\n            }\n         }\n\n         if ((nullBits & 4) != 0) {\n            int toolsItemIdOffset = buffer.getIntLE(offset + 41);\n            if (toolsItemIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ToolsItemId\");\n            }\n\n            int posxx = offset + 61 + toolsItemIdOffset;\n            if (posxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ToolsItemId\");\n            }\n\n            int toolsItemIdLen = VarInt.peek(buffer, posxx);\n            if (toolsItemIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for ToolsItemId\");\n            }\n\n            if (toolsItemIdLen > 4096000) {\n               return ValidationResult.error(\"ToolsItemId exceeds max length 4096000\");\n            }\n\n            posxx += VarInt.length(buffer, posxx);\n            posxx += toolsItemIdLen;\n            if (posxx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading ToolsItemId\");\n            }\n         }\n\n         if ((nullBits & 8) != 0) {\n            int forkedIdOffset = buffer.getIntLE(offset + 45);\n            if (forkedIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ForkedId\");\n            }\n\n            int posxxx = offset + 61 + forkedIdOffset;\n            if (posxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ForkedId\");\n            }\n\n            ValidationResult forkedIdResult = ForkedChainId.validateStructure(buffer, posxxx);\n            if (!forkedIdResult.isValid()) {\n               return ValidationResult.error(\"Invalid ForkedId: \" + forkedIdResult.error());\n            }\n\n            posxxx += ForkedChainId.computeBytesConsumed(buffer, posxxx);\n         }\n\n         if ((nullBits & 16) != 0) {\n            int dataOffset = buffer.getIntLE(offset + 49);\n            if (dataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for Data\");\n            }\n\n            int posxxxx = offset + 61 + dataOffset;\n            if (posxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for Data\");\n            }\n\n            ValidationResult dataResult = InteractionChainData.validateStructure(buffer, posxxxx);\n            if (!dataResult.isValid()) {\n               return ValidationResult.error(\"Invalid Data: \" + dataResult.error());\n            }\n\n            posxxxx += InteractionChainData.computeBytesConsumed(buffer, posxxxx);\n         }\n\n         if ((nullBits & 32) != 0) {\n            int newForksOffset = buffer.getIntLE(offset + 53);\n            if (newForksOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for NewForks\");\n            }\n\n            int posxxxxx = offset + 61 + newForksOffset;\n            if (posxxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for NewForks\");\n            }\n\n            int newForksCount = VarInt.peek(buffer, posxxxxx);\n            if (newForksCount < 0) {\n               return ValidationResult.error(\"Invalid array count for NewForks\");\n            }\n\n            if (newForksCount > 4096000) {\n               return ValidationResult.error(\"NewForks exceeds max length 4096000\");\n            }\n\n            posxxxxx += VarInt.length(buffer, posxxxxx);\n\n            for (int i = 0; i < newForksCount; i++) {\n               ValidationResult structResult = validateStructure(buffer, posxxxxx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid SyncInteractionChain in NewForks[\" + i + \"]: \" + structResult.error());\n               }\n\n               posxxxxx += computeBytesConsumed(buffer, posxxxxx);\n            }\n         }\n\n         if ((nullBits & 64) != 0) {\n            int interactionDataOffset = buffer.getIntLE(offset + 57);\n            if (interactionDataOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for InteractionData\");\n            }\n\n            int posxxxxxx = offset + 61 + interactionDataOffset;\n            if (posxxxxxx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for InteractionData\");\n            }\n\n            int interactionDataCount = VarInt.peek(buffer, posxxxxxx);\n            if (interactionDataCount < 0) {\n               return ValidationResult.error(\"Invalid array count for InteractionData\");\n            }\n\n            if (interactionDataCount > 4096000) {\n               return ValidationResult.error(\"InteractionData exceeds max length 4096000\");\n            }\n\n            posxxxxxx += VarInt.length(buffer, posxxxxxx);\n\n            for (int i = 0; i < interactionDataCount; i++) {\n               ValidationResult structResult = InteractionSyncData.validateStructure(buffer, posxxxxxx);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid InteractionSyncData in InteractionData[\" + i + \"]: \" + structResult.error());\n               }\n\n               posxxxxxx += InteractionSyncData.computeBytesConsumed(buffer, posxxxxxx);\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, InteractionType.fromValue, InteractionState.fromValue, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString, ForkedChainId.deserialize, InteractionChainData.deserialize, ProtocolException.arrayTooLong, VarInt.length, buf.readableBytes, ProtocolException.bufferTooSmall, PacketIO.readBytes, InteractionSyncData.deserialize, InteractionSyncData.computeBytesConsumed\n// Types referenced: InteractionType, InteractionState, ForkedChainId, InteractionChainData, InteractionSyncData\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "SyncInteractionChains",
        "packetId": 290,
        "package": "com.hypixel.hytale.protocol.packets.interaction",
        "fields": [
          {
            "name": "updates",
            "type": "SyncInteractionChain[]",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: SyncInteractionChains\n// Package: com.hypixel.hytale.protocol.packets.interaction\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 290;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 1677721600;\n\n// === FIELDS ===\n@Nonnull SyncInteractionChain[] updates;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static SyncInteractionChains deserialize(@Nonnull ByteBuf buf, int offset) {\n      SyncInteractionChains obj = new SyncInteractionChains();\n      int pos = offset + 0;\n      int updatesCount = VarInt.peek(buf, pos);\n      if (updatesCount < 0) {\n         throw ProtocolException.negativeLength(\"Updates\", updatesCount);\n      } else if (updatesCount > 4096000) {\n         throw ProtocolException.arrayTooLong(\"Updates\", updatesCount, 4096000);\n      } else {\n         int updatesVarLen = VarInt.size(updatesCount);\n         if ((long)(pos + updatesVarLen) + (long)updatesCount * 33L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Updates\", pos + updatesVarLen + updatesCount * 33, buf.readableBytes());\n         } else {\n            pos += updatesVarLen;\n            obj.updates = new SyncInteractionChain[updatesCount];\n\n            for (int i = 0; i < updatesCount; i++) {\n               obj.updates[i] = SyncInteractionChain.deserialize(buf, pos);\n               pos += SyncInteractionChain.computeBytesConsumed(buf, pos);\n            }\n\n            return obj;\n         }\n      }\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static SyncInteractionChains deserialize(@Nonnull ByteBuf buf, int offset) {\n      SyncInteractionChains obj = new SyncInteractionChains();\n      int pos = offset + 0;\n      int updatesCount = VarInt.peek(buf, pos);\n      if (updatesCount < 0) {\n         throw ProtocolException.negativeLength(\"Updates\", updatesCount);\n      } else if (updatesCount > 4096000) {\n         throw ProtocolException.arrayTooLong(\"Updates\", updatesCount, 4096000);\n      } else {\n         int updatesVarLen = VarInt.size(updatesCount);\n         if ((long)(pos + updatesVarLen) + (long)updatesCount * 33L > (long)buf.readableBytes()) {\n            throw ProtocolException.bufferTooSmall(\"Updates\", pos + updatesVarLen + updatesCount * 33, buf.readableBytes());\n         } else {\n            pos += updatesVarLen;\n            obj.updates = new SyncInteractionChain[updatesCount];\n\n            for (int i = 0; i < updatesCount; i++) {\n               obj.updates[i] = SyncInteractionChain.deserialize(buf, pos);\n               pos += SyncInteractionChain.computeBytesConsumed(buf, pos);\n            }\n\n            return obj;\n         }\n      }\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      int pos = offset + 0;\n      int arrLen = VarInt.peek(buf, pos);\n      pos += VarInt.length(buf, pos);\n\n      for (int i = 0; i < arrLen; i++) {\n         pos += SyncInteractionChain.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 0) {\n         return ValidationResult.error(\"Buffer too small: expected at least 0 bytes\");\n      } else {\n         int pos = offset + 0;\n         int updatesCount = VarInt.peek(buffer, pos);\n         if (updatesCount < 0) {\n            return ValidationResult.error(\"Invalid array count for Updates\");\n         } else if (updatesCount > 4096000) {\n            return ValidationResult.error(\"Updates exceeds max length 4096000\");\n         } else {\n            pos += VarInt.length(buffer, pos);\n\n            for (int i = 0; i < updatesCount; i++) {\n               ValidationResult structResult = SyncInteractionChain.validateStructure(buffer, pos);\n               if (!structResult.isValid()) {\n                  return ValidationResult.error(\"Invalid SyncInteractionChain in Updates[\" + i + \"]: \" + structResult.error());\n               }\n\n               pos += SyncInteractionChain.computeBytesConsumed(buffer, pos);\n            }\n\n            return ValidationResult.OK;\n         }\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: VarInt.peek, ProtocolException.negativeLength, ProtocolException.arrayTooLong, VarInt.size, buf.readableBytes, ProtocolException.bufferTooSmall, SyncInteractionChain.deserialize, SyncInteractionChain.computeBytesConsumed\n// Types referenced: SyncInteractionChain\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "CancelInteractionChain",
        "packetId": 291,
        "package": "com.hypixel.hytale.protocol.packets.interaction",
        "fields": [
          {
            "name": "chainId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "forkedId",
            "type": "ForkedChainId",
            "nullable": true
          }
        ],
        "deserializeContext": "// Packet: CancelInteractionChain\n// Package: com.hypixel.hytale.protocol.packets.interaction\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 291;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 5;\npublic static final int VARIABLE_FIELD_COUNT = 1;\npublic static final int VARIABLE_BLOCK_START = 5;\npublic static final int MAX_SIZE = 1038;\n\n// === FIELDS ===\n@Nonnull int chainId;\n@Nullable ForkedChainId forkedId;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static CancelInteractionChain deserialize(@Nonnull ByteBuf buf, int offset) {\n      CancelInteractionChain obj = new CancelInteractionChain();\n      byte nullBits = buf.getByte(offset);\n      obj.chainId = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.forkedId = ForkedChainId.deserialize(buf, pos);\n         pos += ForkedChainId.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static CancelInteractionChain deserialize(@Nonnull ByteBuf buf, int offset) {\n      CancelInteractionChain obj = new CancelInteractionChain();\n      byte nullBits = buf.getByte(offset);\n      obj.chainId = buf.getIntLE(offset + 1);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         obj.forkedId = ForkedChainId.deserialize(buf, pos);\n         pos += ForkedChainId.computeBytesConsumed(buf, pos);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int pos = offset + 5;\n      if ((nullBits & 1) != 0) {\n         pos += ForkedChainId.computeBytesConsumed(buf, pos);\n      }\n\n      return pos - offset;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 5) {\n         return ValidationResult.error(\"Buffer too small: expected at least 5 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         int pos = offset + 5;\n         if ((nullBits & 1) != 0) {\n            ValidationResult forkedIdResult = ForkedChainId.validateStructure(buffer, pos);\n            if (!forkedIdResult.isValid()) {\n               return ValidationResult.error(\"Invalid ForkedId: \" + forkedIdResult.error());\n            }\n\n            pos += ForkedChainId.computeBytesConsumed(buffer, pos);\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, ForkedChainId.deserialize, ForkedChainId.computeBytesConsumed\n// Types referenced: ForkedChainId\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "PlayInteractionFor",
        "packetId": 292,
        "package": "com.hypixel.hytale.protocol.packets.interaction",
        "fields": [
          {
            "name": "entityId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "chainId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "forkedId",
            "type": "ForkedChainId",
            "nullable": true
          },
          {
            "name": "operationIndex",
            "type": "int",
            "nullable": false
          },
          {
            "name": "interactionId",
            "type": "int",
            "nullable": false
          },
          {
            "name": "interactedItemId",
            "type": "String",
            "nullable": true
          },
          {
            "name": "interactionType",
            "type": "InteractionType",
            "nullable": false
          },
          {
            "name": "cancel",
            "type": "boolean",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: PlayInteractionFor\n// Package: com.hypixel.hytale.protocol.packets.interaction\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 292;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 1;\npublic static final int FIXED_BLOCK_SIZE = 19;\npublic static final int VARIABLE_FIELD_COUNT = 2;\npublic static final int VARIABLE_BLOCK_START = 27;\npublic static final int MAX_SIZE = 16385065;\n\n// === FIELDS ===\n@Nonnull int entityId;\n@Nonnull int chainId;\n@Nullable ForkedChainId forkedId;\n@Nonnull int operationIndex;\n@Nonnull int interactionId;\n@Nullable String interactedItemId;\n@Nonnull InteractionType interactionType;\n@Nonnull boolean cancel;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static PlayInteractionFor deserialize(@Nonnull ByteBuf buf, int offset) {\n      PlayInteractionFor obj = new PlayInteractionFor();\n      byte nullBits = buf.getByte(offset);\n      obj.entityId = buf.getIntLE(offset + 1);\n      obj.chainId = buf.getIntLE(offset + 5);\n      obj.operationIndex = buf.getIntLE(offset + 9);\n      obj.interactionId = buf.getIntLE(offset + 13);\n      obj.interactionType = InteractionType.fromValue(buf.getByte(offset + 17));\n      obj.cancel = buf.getByte(offset + 18) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 27 + buf.getIntLE(offset + 19);\n         obj.forkedId = ForkedChainId.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 27 + buf.getIntLE(offset + 23);\n         int interactedItemIdLen = VarInt.peek(buf, varPos1);\n         if (interactedItemIdLen < 0) {\n            throw ProtocolException.negativeLength(\"InteractedItemId\", interactedItemIdLen);\n         }\n\n         if (interactedItemIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"InteractedItemId\", interactedItemIdLen, 4096000);\n         }\n\n         obj.interactedItemId = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\n@Nonnull\n   public static PlayInteractionFor deserialize(@Nonnull ByteBuf buf, int offset) {\n      PlayInteractionFor obj = new PlayInteractionFor();\n      byte nullBits = buf.getByte(offset);\n      obj.entityId = buf.getIntLE(offset + 1);\n      obj.chainId = buf.getIntLE(offset + 5);\n      obj.operationIndex = buf.getIntLE(offset + 9);\n      obj.interactionId = buf.getIntLE(offset + 13);\n      obj.interactionType = InteractionType.fromValue(buf.getByte(offset + 17));\n      obj.cancel = buf.getByte(offset + 18) != 0;\n      if ((nullBits & 1) != 0) {\n         int varPos0 = offset + 27 + buf.getIntLE(offset + 19);\n         obj.forkedId = ForkedChainId.deserialize(buf, varPos0);\n      }\n\n      if ((nullBits & 2) != 0) {\n         int varPos1 = offset + 27 + buf.getIntLE(offset + 23);\n         int interactedItemIdLen = VarInt.peek(buf, varPos1);\n         if (interactedItemIdLen < 0) {\n            throw ProtocolException.negativeLength(\"InteractedItemId\", interactedItemIdLen);\n         }\n\n         if (interactedItemIdLen > 4096000) {\n            throw ProtocolException.stringTooLong(\"InteractedItemId\", interactedItemIdLen, 4096000);\n         }\n\n         obj.interactedItemId = PacketIO.readVarString(buf, varPos1, PacketIO.UTF8);\n      }\n\n      return obj;\n   }\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      byte nullBits = buf.getByte(offset);\n      int maxEnd = 27;\n      if ((nullBits & 1) != 0) {\n         int fieldOffset0 = buf.getIntLE(offset + 19);\n         int pos0 = offset + 27 + fieldOffset0;\n         pos0 += ForkedChainId.computeBytesConsumed(buf, pos0);\n         if (pos0 - offset > maxEnd) {\n            maxEnd = pos0 - offset;\n         }\n      }\n\n      if ((nullBits & 2) != 0) {\n         int fieldOffset1 = buf.getIntLE(offset + 23);\n         int pos1 = offset + 27 + fieldOffset1;\n         int sl = VarInt.peek(buf, pos1);\n         pos1 += VarInt.length(buf, pos1) + sl;\n         if (pos1 - offset > maxEnd) {\n            maxEnd = pos1 - offset;\n         }\n      }\n\n      return maxEnd;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      if (buffer.readableBytes() - offset < 27) {\n         return ValidationResult.error(\"Buffer too small: expected at least 27 bytes\");\n      } else {\n         byte nullBits = buffer.getByte(offset);\n         if ((nullBits & 1) != 0) {\n            int forkedIdOffset = buffer.getIntLE(offset + 19);\n            if (forkedIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for ForkedId\");\n            }\n\n            int pos = offset + 27 + forkedIdOffset;\n            if (pos >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for ForkedId\");\n            }\n\n            ValidationResult forkedIdResult = ForkedChainId.validateStructure(buffer, pos);\n            if (!forkedIdResult.isValid()) {\n               return ValidationResult.error(\"Invalid ForkedId: \" + forkedIdResult.error());\n            }\n\n            pos += ForkedChainId.computeBytesConsumed(buffer, pos);\n         }\n\n         if ((nullBits & 2) != 0) {\n            int interactedItemIdOffset = buffer.getIntLE(offset + 23);\n            if (interactedItemIdOffset < 0) {\n               return ValidationResult.error(\"Invalid offset for InteractedItemId\");\n            }\n\n            int posx = offset + 27 + interactedItemIdOffset;\n            if (posx >= buffer.writerIndex()) {\n               return ValidationResult.error(\"Offset out of bounds for InteractedItemId\");\n            }\n\n            int interactedItemIdLen = VarInt.peek(buffer, posx);\n            if (interactedItemIdLen < 0) {\n               return ValidationResult.error(\"Invalid string length for InteractedItemId\");\n            }\n\n            if (interactedItemIdLen > 4096000) {\n               return ValidationResult.error(\"InteractedItemId exceeds max length 4096000\");\n            }\n\n            posx += VarInt.length(buffer, posx);\n            posx += interactedItemIdLen;\n            if (posx > buffer.writerIndex()) {\n               return ValidationResult.error(\"Buffer overflow reading InteractedItemId\");\n            }\n         }\n\n         return ValidationResult.OK;\n      }\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getByte, buf.getIntLE, InteractionType.fromValue, ForkedChainId.deserialize, VarInt.peek, ProtocolException.negativeLength, ProtocolException.stringTooLong, PacketIO.readVarString\n// Types referenced: InteractionType, ForkedChainId\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "MountNPC",
        "packetId": 293,
        "package": "com.hypixel.hytale.protocol.packets.interaction",
        "fields": [
          {
            "name": "anchorX",
            "type": "float",
            "nullable": false
          },
          {
            "name": "anchorY",
            "type": "float",
            "nullable": false
          },
          {
            "name": "anchorZ",
            "type": "float",
            "nullable": false
          },
          {
            "name": "entityId",
            "type": "int",
            "nullable": false
          }
        ],
        "deserializeContext": "// Packet: MountNPC\n// Package: com.hypixel.hytale.protocol.packets.interaction\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 293;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 16;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 16;\npublic static final int MAX_SIZE = 16;\n\n// === FIELDS ===\n@Nonnull float anchorX;\n@Nonnull float anchorY;\n@Nonnull float anchorZ;\n@Nonnull int entityId;\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static MountNPC deserialize(@Nonnull ByteBuf buf, int offset) {\n      MountNPC obj = new MountNPC();\n      obj.anchorX = buf.getFloatLE(offset + 0);\n      obj.anchorY = buf.getFloatLE(offset + 4);\n      obj.anchorZ = buf.getFloatLE(offset + 8);\n      obj.entityId = buf.getIntLE(offset + 12);\n      return obj;\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 16;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 16 ? ValidationResult.error(\"Buffer too small: expected at least 16 bytes\") : ValidationResult.OK;\n   }\n\n// === EXTERNAL DEPENDENCIES ===\n// Methods used: buf.getFloatLE, buf.getIntLE\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      },
      {
        "name": "DismountNPC",
        "packetId": 294,
        "package": "com.hypixel.hytale.protocol.packets.interaction",
        "fields": [],
        "deserializeContext": "// Packet: DismountNPC\n// Package: com.hypixel.hytale.protocol.packets.interaction\n\n// === CONSTANTS ===\npublic static final int PACKET_ID = 294;\npublic static final boolean IS_COMPRESSED = false;\npublic static final int NULLABLE_BIT_FIELD_SIZE = 0;\npublic static final int FIXED_BLOCK_SIZE = 0;\npublic static final int VARIABLE_FIELD_COUNT = 0;\npublic static final int VARIABLE_BLOCK_START = 0;\npublic static final int MAX_SIZE = 0;\n\n// === FIELDS ===\n\n// === DESERIALIZE METHOD ===\n@Nonnull\n   public static DismountNPC deserialize(@Nonnull ByteBuf buf, int offset) {\n      return new DismountNPC();\n   }\n\n// === STATIC HELPER METHODS (same class) ===\npublic static int computeBytesConsumed(@Nonnull ByteBuf buf, int offset) {\n      return 0;\n   }\npublic static ValidationResult validateStructure(@Nonnull ByteBuf buffer, int offset) {\n      return buffer.readableBytes() - offset < 0 ? ValidationResult.error(\"Buffer too small: expected at least 0 bytes\") : ValidationResult.OK;\n   }\n\n// === COMMON PACKETIO METHODS REFERENCE ===\n// PacketIO.readFixedAsciiString(buf, offset, length) - reads fixed-length ASCII string\n// PacketIO.readVarString(buf, pos, charset) - reads variable-length string with VarInt prefix\n// PacketIO.readVarAsciiString(buf, pos, maxLen) - reads variable ASCII string\n// PacketIO.readUUID(buf, offset) - reads 16-byte UUID\n// VarInt.peek(buf, pos) - reads VarInt value without advancing\n// VarInt.length(buf, pos) - gets byte length of VarInt at position\n// buf.getByte(offset) - reads 1 byte\n// buf.getIntLE(offset) - reads 4-byte little-endian int\n// buf.getLongLE(offset) - reads 8-byte little-endian long\n// buf.getShortLE(offset) - reads 2-byte little-endian short"
      }
    ]
  },
  "enums": {
    "ParticleScaleRatioConstraint": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "OneToOne",
          "value": 0
        },
        {
          "name": "Preserved",
          "value": 1
        },
        {
          "name": "None",
          "value": 2
        }
      ]
    },
    "VariantRotation": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Wall",
          "value": 1
        },
        {
          "name": "UpDown",
          "value": 2
        },
        {
          "name": "Pipe",
          "value": 3
        },
        {
          "name": "DoublePipe",
          "value": 4
        },
        {
          "name": "NESW",
          "value": 5
        },
        {
          "name": "UpDownNESW",
          "value": 6
        },
        {
          "name": "All",
          "value": 7
        }
      ]
    },
    "RotationMode": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Velocity",
          "value": 1
        },
        {
          "name": "VelocityDamped",
          "value": 2
        },
        {
          "name": "VelocityRoll",
          "value": 3
        }
      ]
    },
    "ClientCameraView": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "FirstPerson",
          "value": 0
        },
        {
          "name": "ThirdPerson",
          "value": 1
        },
        {
          "name": "Custom",
          "value": 2
        }
      ]
    },
    "WaitForDataFrom": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Client",
          "value": 0
        },
        {
          "name": "Server",
          "value": 1
        },
        {
          "name": "None",
          "value": 2
        }
      ]
    },
    "InventoryActionType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "TakeAll",
          "value": 0
        },
        {
          "name": "PutAll",
          "value": 1
        },
        {
          "name": "QuickStack",
          "value": 2
        },
        {
          "name": "Sort",
          "value": 3
        }
      ]
    },
    "ItemSoundEvent": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Drag",
          "value": 0
        },
        {
          "name": "Drop",
          "value": 1
        }
      ]
    },
    "ItemArmorSlot": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Head",
          "value": 0
        },
        {
          "name": "Chest",
          "value": 1
        },
        {
          "name": "Hands",
          "value": 2
        },
        {
          "name": "Legs",
          "value": 3
        }
      ]
    },
    "PositionType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "AttachedToPlusOffset",
          "value": 0
        },
        {
          "name": "Custom",
          "value": 1
        }
      ]
    },
    "Phobia": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Arachnophobia",
          "value": 1
        }
      ]
    },
    "BlockFace": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Up",
          "value": 1
        },
        {
          "name": "Down",
          "value": 2
        },
        {
          "name": "North",
          "value": 3
        },
        {
          "name": "South",
          "value": 4
        },
        {
          "name": "East",
          "value": 5
        },
        {
          "name": "West",
          "value": 6
        }
      ]
    },
    "ValueType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Percent",
          "value": 0
        },
        {
          "name": "Absolute",
          "value": 1
        }
      ]
    },
    "Cosmetic": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Haircut",
          "value": 0
        },
        {
          "name": "FacialHair",
          "value": 1
        },
        {
          "name": "Undertop",
          "value": 2
        },
        {
          "name": "Overtop",
          "value": 3
        },
        {
          "name": "Pants",
          "value": 4
        },
        {
          "name": "Overpants",
          "value": 5
        },
        {
          "name": "Shoes",
          "value": 6
        },
        {
          "name": "Gloves",
          "value": 7
        },
        {
          "name": "Cape",
          "value": 8
        },
        {
          "name": "HeadAccessory",
          "value": 9
        },
        {
          "name": "FaceAccessory",
          "value": 10
        },
        {
          "name": "EarAccessory",
          "value": 11
        },
        {
          "name": "Ear",
          "value": 12
        }
      ]
    },
    "ComponentUpdateType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Nameplate",
          "value": 0
        },
        {
          "name": "UIComponents",
          "value": 1
        },
        {
          "name": "CombatText",
          "value": 2
        },
        {
          "name": "Model",
          "value": 3
        },
        {
          "name": "PlayerSkin",
          "value": 4
        },
        {
          "name": "Item",
          "value": 5
        },
        {
          "name": "Block",
          "value": 6
        },
        {
          "name": "Equipment",
          "value": 7
        },
        {
          "name": "EntityStats",
          "value": 8
        },
        {
          "name": "Transform",
          "value": 9
        },
        {
          "name": "MovementStates",
          "value": 10
        },
        {
          "name": "EntityEffects",
          "value": 11
        },
        {
          "name": "Interactions",
          "value": 12
        },
        {
          "name": "DynamicLight",
          "value": 13
        },
        {
          "name": "Interactable",
          "value": 14
        },
        {
          "name": "Intangible",
          "value": 15
        },
        {
          "name": "Invulnerable",
          "value": 16
        },
        {
          "name": "RespondToHit",
          "value": 17
        },
        {
          "name": "HitboxCollision",
          "value": 18
        },
        {
          "name": "Repulsion",
          "value": 19
        },
        {
          "name": "Prediction",
          "value": 20
        },
        {
          "name": "Audio",
          "value": 21
        },
        {
          "name": "Mounted",
          "value": 22
        },
        {
          "name": "NewSpawn",
          "value": 23
        },
        {
          "name": "ActiveAnimations",
          "value": 24
        }
      ]
    },
    "MouseInputTargetType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Any",
          "value": 0
        },
        {
          "name": "Block",
          "value": 1
        },
        {
          "name": "Entity",
          "value": 2
        },
        {
          "name": "None",
          "value": 3
        }
      ]
    },
    "CollisionType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Hard",
          "value": 0
        },
        {
          "name": "Soft",
          "value": 1
        }
      ]
    },
    "ItemReticleClientEvent": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "OnHit",
          "value": 0
        },
        {
          "name": "Wielding",
          "value": 1
        },
        {
          "name": "OnMovementLeft",
          "value": 2
        },
        {
          "name": "OnMovementRight",
          "value": 3
        },
        {
          "name": "OnMovementBack",
          "value": 4
        }
      ]
    },
    "ChangeStatBehaviour": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Add",
          "value": 0
        },
        {
          "name": "Set",
          "value": 1
        }
      ]
    },
    "AmbienceTransitionSpeed": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Default",
          "value": 0
        },
        {
          "name": "Fast",
          "value": 1
        },
        {
          "name": "Instant",
          "value": 2
        }
      ]
    },
    "GameMode": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Adventure",
          "value": 0
        },
        {
          "name": "Creative",
          "value": 1
        }
      ]
    },
    "MouseButtonState": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Pressed",
          "value": 0
        },
        {
          "name": "Released",
          "value": 1
        }
      ]
    },
    "AmbienceFXAltitude": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Normal",
          "value": 0
        },
        {
          "name": "Lowest",
          "value": 1
        },
        {
          "name": "Highest",
          "value": 2
        },
        {
          "name": "Random",
          "value": 3
        }
      ]
    },
    "PositionDistanceOffsetType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "DistanceOffset",
          "value": 0
        },
        {
          "name": "DistanceOffsetRaycast",
          "value": 1
        },
        {
          "name": "None",
          "value": 2
        }
      ]
    },
    "BlockSupportsRequiredForType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Any",
          "value": 0
        },
        {
          "name": "All",
          "value": 1
        }
      ]
    },
    "RaycastMode": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "FollowMotion",
          "value": 0
        },
        {
          "name": "FollowLook",
          "value": 1
        }
      ]
    },
    "ModifierTarget": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Min",
          "value": 0
        },
        {
          "name": "Max",
          "value": 1
        }
      ]
    },
    "Match": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "All",
          "value": 0
        },
        {
          "name": "None",
          "value": 1
        }
      ]
    },
    "ConnectedBlockRuleSetType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Stair",
          "value": 0
        },
        {
          "name": "Roof",
          "value": 1
        }
      ]
    },
    "SoundCategory": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Music",
          "value": 0
        },
        {
          "name": "Ambient",
          "value": 1
        },
        {
          "name": "SFX",
          "value": 2
        },
        {
          "name": "UI",
          "value": 3
        }
      ]
    },
    "ShadingMode": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Standard",
          "value": 0
        },
        {
          "name": "Flat",
          "value": 1
        },
        {
          "name": "Fullbright",
          "value": 2
        },
        {
          "name": "Reflective",
          "value": 3
        }
      ]
    },
    "FXRenderMode": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "BlendLinear",
          "value": 0
        },
        {
          "name": "BlendAdd",
          "value": 1
        },
        {
          "name": "Erosion",
          "value": 2
        },
        {
          "name": "Distortion",
          "value": 3
        }
      ]
    },
    "PhysicsType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Standard",
          "value": 0
        }
      ]
    },
    "PrioritySlot": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Default",
          "value": 0
        },
        {
          "name": "MainHand",
          "value": 1
        },
        {
          "name": "OffHand",
          "value": 2
        }
      ]
    },
    "HorizontalSelectorDirection": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "ToLeft",
          "value": 0
        },
        {
          "name": "ToRight",
          "value": 1
        }
      ]
    },
    "BlockSoundEvent": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Walk",
          "value": 0
        },
        {
          "name": "Land",
          "value": 1
        },
        {
          "name": "MoveIn",
          "value": 2
        },
        {
          "name": "MoveOut",
          "value": 3
        },
        {
          "name": "Hit",
          "value": 4
        },
        {
          "name": "Break",
          "value": 5
        },
        {
          "name": "Build",
          "value": 6
        },
        {
          "name": "Clone",
          "value": 7
        },
        {
          "name": "Harvest",
          "value": 8
        }
      ]
    },
    "RotationType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "AttachedToPlusOffset",
          "value": 0
        },
        {
          "name": "Custom",
          "value": 1
        }
      ]
    },
    "RandomRotation": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "YawPitchRollStep1",
          "value": 1
        },
        {
          "name": "YawStep1",
          "value": 2
        },
        {
          "name": "YawStep1XZ",
          "value": 3
        },
        {
          "name": "YawStep90",
          "value": 4
        }
      ]
    },
    "DrawType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Empty",
          "value": 0
        },
        {
          "name": "GizmoCube",
          "value": 1
        },
        {
          "name": "Cube",
          "value": 2
        },
        {
          "name": "Model",
          "value": 3
        },
        {
          "name": "CubeWithModel",
          "value": 4
        }
      ]
    },
    "BlockNeighbor": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Up",
          "value": 0
        },
        {
          "name": "Down",
          "value": 1
        },
        {
          "name": "North",
          "value": 2
        },
        {
          "name": "East",
          "value": 3
        },
        {
          "name": "South",
          "value": 4
        },
        {
          "name": "West",
          "value": 5
        },
        {
          "name": "UpNorth",
          "value": 6
        },
        {
          "name": "UpSouth",
          "value": 7
        },
        {
          "name": "UpEast",
          "value": 8
        },
        {
          "name": "UpWest",
          "value": 9
        },
        {
          "name": "DownNorth",
          "value": 10
        },
        {
          "name": "DownSouth",
          "value": 11
        },
        {
          "name": "DownEast",
          "value": 12
        },
        {
          "name": "DownWest",
          "value": 13
        },
        {
          "name": "NorthEast",
          "value": 14
        },
        {
          "name": "SouthEast",
          "value": 15
        },
        {
          "name": "SouthWest",
          "value": 16
        },
        {
          "name": "NorthWest",
          "value": 17
        },
        {
          "name": "UpNorthEast",
          "value": 18
        },
        {
          "name": "UpSouthEast",
          "value": 19
        },
        {
          "name": "UpSouthWest",
          "value": 20
        },
        {
          "name": "UpNorthWest",
          "value": 21
        },
        {
          "name": "DownNorthEast",
          "value": 22
        },
        {
          "name": "DownSouthEast",
          "value": 23
        },
        {
          "name": "DownSouthWest",
          "value": 24
        },
        {
          "name": "DownNorthWest",
          "value": 25
        }
      ]
    },
    "CombatTextEntityUIAnimationEventType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Scale",
          "value": 0
        },
        {
          "name": "Position",
          "value": 1
        },
        {
          "name": "Opacity",
          "value": 2
        }
      ]
    },
    "MovementDirection": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Forward",
          "value": 1
        },
        {
          "name": "Back",
          "value": 2
        },
        {
          "name": "Left",
          "value": 3
        },
        {
          "name": "Right",
          "value": 4
        },
        {
          "name": "ForwardLeft",
          "value": 5
        },
        {
          "name": "ForwardRight",
          "value": 6
        },
        {
          "name": "BackLeft",
          "value": 7
        },
        {
          "name": "BackRight",
          "value": 8
        }
      ]
    },
    "MouseButtonType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Left",
          "value": 0
        },
        {
          "name": "Middle",
          "value": 1
        },
        {
          "name": "Right",
          "value": 2
        },
        {
          "name": "X1",
          "value": 3
        },
        {
          "name": "X2",
          "value": 4
        }
      ]
    },
    "ApplyForceState": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Waiting",
          "value": 0
        },
        {
          "name": "Ground",
          "value": 1
        },
        {
          "name": "Collision",
          "value": 2
        },
        {
          "name": "Timer",
          "value": 3
        }
      ]
    },
    "BlockPreviewVisibility": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "AlwaysVisible",
          "value": 0
        },
        {
          "name": "AlwaysHidden",
          "value": 1
        },
        {
          "name": "Default",
          "value": 2
        }
      ]
    },
    "Rotation": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Ninety",
          "value": 1
        },
        {
          "name": "OneEighty",
          "value": 2
        },
        {
          "name": "TwoSeventy",
          "value": 3
        }
      ]
    },
    "BlockMaterial": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Empty",
          "value": 0
        },
        {
          "name": "Solid",
          "value": 1
        }
      ]
    },
    "ShaderType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Wind",
          "value": 1
        },
        {
          "name": "WindAttached",
          "value": 2
        },
        {
          "name": "WindRandom",
          "value": 3
        },
        {
          "name": "WindFractal",
          "value": 4
        },
        {
          "name": "Ice",
          "value": 5
        },
        {
          "name": "Water",
          "value": 6
        },
        {
          "name": "Lava",
          "value": 7
        },
        {
          "name": "Slime",
          "value": 8
        },
        {
          "name": "Ripple",
          "value": 9
        }
      ]
    },
    "InteractionState": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Finished",
          "value": 0
        },
        {
          "name": "Skip",
          "value": 1
        },
        {
          "name": "ItemChanged",
          "value": 2
        },
        {
          "name": "Failed",
          "value": 3
        },
        {
          "name": "NotFinished",
          "value": 4
        }
      ]
    },
    "EntityStatOp": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Init",
          "value": 0
        },
        {
          "name": "Remove",
          "value": 1
        },
        {
          "name": "PutModifier",
          "value": 2
        },
        {
          "name": "RemoveModifier",
          "value": 3
        },
        {
          "name": "Add",
          "value": 4
        },
        {
          "name": "Set",
          "value": 5
        },
        {
          "name": "Minimize",
          "value": 6
        },
        {
          "name": "Maximize",
          "value": 7
        },
        {
          "name": "Reset",
          "value": 8
        }
      ]
    },
    "OverlapBehavior": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Extend",
          "value": 0
        },
        {
          "name": "Overwrite",
          "value": 1
        },
        {
          "name": "Ignore",
          "value": 2
        }
      ]
    },
    "VelocityThresholdStyle": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Linear",
          "value": 0
        },
        {
          "name": "Exp",
          "value": 1
        }
      ]
    },
    "EasingType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Linear",
          "value": 0
        },
        {
          "name": "QuadIn",
          "value": 1
        },
        {
          "name": "QuadOut",
          "value": 2
        },
        {
          "name": "QuadInOut",
          "value": 3
        },
        {
          "name": "CubicIn",
          "value": 4
        },
        {
          "name": "CubicOut",
          "value": 5
        },
        {
          "name": "CubicInOut",
          "value": 6
        },
        {
          "name": "QuartIn",
          "value": 7
        },
        {
          "name": "QuartOut",
          "value": 8
        },
        {
          "name": "QuartInOut",
          "value": 9
        },
        {
          "name": "QuintIn",
          "value": 10
        },
        {
          "name": "QuintOut",
          "value": 11
        },
        {
          "name": "QuintInOut",
          "value": 12
        },
        {
          "name": "SineIn",
          "value": 13
        },
        {
          "name": "SineOut",
          "value": 14
        },
        {
          "name": "SineInOut",
          "value": 15
        },
        {
          "name": "ExpoIn",
          "value": 16
        },
        {
          "name": "ExpoOut",
          "value": 17
        },
        {
          "name": "ExpoInOut",
          "value": 18
        },
        {
          "name": "CircIn",
          "value": 19
        },
        {
          "name": "CircOut",
          "value": 20
        },
        {
          "name": "CircInOut",
          "value": 21
        },
        {
          "name": "ElasticIn",
          "value": 22
        },
        {
          "name": "ElasticOut",
          "value": 23
        },
        {
          "name": "ElasticInOut",
          "value": 24
        },
        {
          "name": "BackIn",
          "value": 25
        },
        {
          "name": "BackOut",
          "value": 26
        },
        {
          "name": "BackInOut",
          "value": 27
        },
        {
          "name": "BounceIn",
          "value": 28
        },
        {
          "name": "BounceOut",
          "value": 29
        },
        {
          "name": "BounceInOut",
          "value": 30
        }
      ]
    },
    "AnimationSlot": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Movement",
          "value": 0
        },
        {
          "name": "Status",
          "value": 1
        },
        {
          "name": "Action",
          "value": 2
        },
        {
          "name": "Face",
          "value": 3
        },
        {
          "name": "Emote",
          "value": 4
        }
      ]
    },
    "EffectOp": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Add",
          "value": 0
        },
        {
          "name": "Remove",
          "value": 1
        }
      ]
    },
    "MountController": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Minecart",
          "value": 0
        },
        {
          "name": "BlockMount",
          "value": 1
        }
      ]
    },
    "EmitShape": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Sphere",
          "value": 0
        },
        {
          "name": "Cube",
          "value": 1
        }
      ]
    },
    "DebugShape": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Sphere",
          "value": 0
        },
        {
          "name": "Cylinder",
          "value": 1
        },
        {
          "name": "Cone",
          "value": 2
        },
        {
          "name": "Cube",
          "value": 3
        },
        {
          "name": "Frustum",
          "value": 4
        }
      ]
    },
    "EntityPart": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Self",
          "value": 0
        },
        {
          "name": "Entity",
          "value": 1
        },
        {
          "name": "PrimaryItem",
          "value": 2
        },
        {
          "name": "SecondaryItem",
          "value": 3
        }
      ]
    },
    "ItemGridInfoDisplayMode": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Tooltip",
          "value": 0
        },
        {
          "name": "Adjacent",
          "value": 1
        },
        {
          "name": "None",
          "value": 2
        }
      ]
    },
    "CameraPerspectiveType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "First",
          "value": 0
        },
        {
          "name": "Third",
          "value": 1
        }
      ]
    },
    "ApplyLookType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "LocalPlayerLookOrientation",
          "value": 0
        },
        {
          "name": "Rotation",
          "value": 1
        }
      ]
    },
    "EntityStatResetBehavior": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "InitialValue",
          "value": 0
        },
        {
          "name": "MaxValue",
          "value": 1
        }
      ]
    },
    "FailOnType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Neither",
          "value": 0
        },
        {
          "name": "Entity",
          "value": 1
        },
        {
          "name": "Block",
          "value": 2
        },
        {
          "name": "Either",
          "value": 3
        }
      ]
    },
    "MouseInputType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "LookAtTarget",
          "value": 0
        },
        {
          "name": "LookAtTargetBlock",
          "value": 1
        },
        {
          "name": "LookAtTargetEntity",
          "value": 2
        },
        {
          "name": "LookAtPlane",
          "value": 3
        }
      ]
    },
    "NoiseType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Sin",
          "value": 0
        },
        {
          "name": "Cos",
          "value": 1
        },
        {
          "name": "Perlin_Linear",
          "value": 2
        },
        {
          "name": "Perlin_Hermite",
          "value": 3
        },
        {
          "name": "Perlin_Quintic",
          "value": 4
        },
        {
          "name": "Random",
          "value": 5
        }
      ]
    },
    "AccumulationMode": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Set",
          "value": 0
        },
        {
          "name": "Sum",
          "value": 1
        },
        {
          "name": "Average",
          "value": 2
        }
      ]
    },
    "Opacity": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Solid",
          "value": 0
        },
        {
          "name": "Semitransparent",
          "value": 1
        },
        {
          "name": "Cutout",
          "value": 2
        },
        {
          "name": "Transparent",
          "value": 3
        }
      ]
    },
    "UpdateType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Init",
          "value": 0
        },
        {
          "name": "AddOrUpdate",
          "value": 1
        },
        {
          "name": "Remove",
          "value": 2
        }
      ]
    },
    "ParticleUVOption": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "RandomFlipU",
          "value": 1
        },
        {
          "name": "RandomFlipV",
          "value": 2
        },
        {
          "name": "RandomFlipUV",
          "value": 3
        },
        {
          "name": "FlipU",
          "value": 4
        },
        {
          "name": "FlipV",
          "value": 5
        },
        {
          "name": "FlipUV",
          "value": 6
        }
      ]
    },
    "SupportMatch": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Ignored",
          "value": 0
        },
        {
          "name": "Required",
          "value": 1
        },
        {
          "name": "Disallowed",
          "value": 2
        }
      ]
    },
    "SoftParticle": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Enable",
          "value": 0
        },
        {
          "name": "Disable",
          "value": 1
        },
        {
          "name": "Require",
          "value": 2
        }
      ]
    },
    "UVMotionCurveType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Constant",
          "value": 0
        },
        {
          "name": "IncreaseLinear",
          "value": 1
        },
        {
          "name": "IncreaseQuartIn",
          "value": 2
        },
        {
          "name": "IncreaseQuartInOut",
          "value": 3
        },
        {
          "name": "IncreaseQuartOut",
          "value": 4
        },
        {
          "name": "DecreaseLinear",
          "value": 5
        },
        {
          "name": "DecreaseQuartIn",
          "value": 6
        },
        {
          "name": "DecreaseQuartInOut",
          "value": 7
        },
        {
          "name": "DecreaseQuartOut",
          "value": 8
        }
      ]
    },
    "CameraActionType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "ForcePerspective",
          "value": 0
        },
        {
          "name": "Orbit",
          "value": 1
        },
        {
          "name": "Transition",
          "value": 2
        }
      ]
    },
    "CanMoveType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "AttachedToLocalPlayer",
          "value": 0
        },
        {
          "name": "Always",
          "value": 1
        }
      ]
    },
    "ChangeVelocityType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Add",
          "value": 0
        },
        {
          "name": "Set",
          "value": 1
        }
      ]
    },
    "TagPatternType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Equals",
          "value": 0
        },
        {
          "name": "And",
          "value": 1
        },
        {
          "name": "Or",
          "value": 2
        },
        {
          "name": "Not",
          "value": 3
        }
      ]
    },
    "InteractionType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Primary",
          "value": 0
        },
        {
          "name": "Secondary",
          "value": 1
        },
        {
          "name": "Ability1",
          "value": 2
        },
        {
          "name": "Ability2",
          "value": 3
        },
        {
          "name": "Ability3",
          "value": 4
        },
        {
          "name": "Use",
          "value": 5
        },
        {
          "name": "Pick",
          "value": 6
        },
        {
          "name": "Pickup",
          "value": 7
        },
        {
          "name": "CollisionEnter",
          "value": 8
        },
        {
          "name": "CollisionLeave",
          "value": 9
        },
        {
          "name": "Collision",
          "value": 10
        },
        {
          "name": "EntityStatEffect",
          "value": 11
        },
        {
          "name": "SwapTo",
          "value": 12
        },
        {
          "name": "SwapFrom",
          "value": 13
        },
        {
          "name": "Death",
          "value": 14
        },
        {
          "name": "Wielding",
          "value": 15
        },
        {
          "name": "ProjectileSpawn",
          "value": 16
        },
        {
          "name": "ProjectileHit",
          "value": 17
        },
        {
          "name": "ProjectileMiss",
          "value": 18
        },
        {
          "name": "ProjectileBounce",
          "value": 19
        },
        {
          "name": "Held",
          "value": 20
        },
        {
          "name": "HeldOffhand",
          "value": 21
        },
        {
          "name": "Equipped",
          "value": 22
        },
        {
          "name": "Dodge",
          "value": 23
        },
        {
          "name": "GameModeSwap",
          "value": 24
        }
      ]
    },
    "ParticleCollisionAction": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Expire",
          "value": 0
        },
        {
          "name": "LastFrame",
          "value": 1
        },
        {
          "name": "Linger",
          "value": 2
        }
      ]
    },
    "CameraNode": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Head",
          "value": 1
        },
        {
          "name": "LShoulder",
          "value": 2
        },
        {
          "name": "RShoulder",
          "value": 3
        },
        {
          "name": "Belly",
          "value": 4
        }
      ]
    },
    "BlockPlacementRotationMode": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "FacingPlayer",
          "value": 0
        },
        {
          "name": "StairFacingPlayer",
          "value": 1
        },
        {
          "name": "BlockNormal",
          "value": 2
        },
        {
          "name": "Default",
          "value": 3
        }
      ]
    },
    "BenchType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Crafting",
          "value": 0
        },
        {
          "name": "Processing",
          "value": 1
        },
        {
          "name": "DiagramCrafting",
          "value": 2
        },
        {
          "name": "StructuralCrafting",
          "value": 3
        }
      ]
    },
    "BlockParticleEvent": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Walk",
          "value": 0
        },
        {
          "name": "Run",
          "value": 1
        },
        {
          "name": "Sprint",
          "value": 2
        },
        {
          "name": "SoftLand",
          "value": 3
        },
        {
          "name": "HardLand",
          "value": 4
        },
        {
          "name": "MoveOut",
          "value": 5
        },
        {
          "name": "Hit",
          "value": 6
        },
        {
          "name": "Break",
          "value": 7
        },
        {
          "name": "Build",
          "value": 8
        },
        {
          "name": "Physics",
          "value": 9
        }
      ]
    },
    "MovementForceRotationType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "AttachedToHead",
          "value": 0
        },
        {
          "name": "CameraRotation",
          "value": 1
        },
        {
          "name": "Custom",
          "value": 2
        }
      ]
    },
    "LoopOption": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "PlayOnce",
          "value": 0
        },
        {
          "name": "Loop",
          "value": 1
        },
        {
          "name": "LoopMirror",
          "value": 2
        }
      ]
    },
    "MaybeBool": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Null",
          "value": 0
        },
        {
          "name": "False",
          "value": 1
        },
        {
          "name": "True",
          "value": 2
        }
      ]
    },
    "SortType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Name",
          "value": 0
        },
        {
          "name": "Type",
          "value": 1
        },
        {
          "name": "Rarity",
          "value": 2
        }
      ]
    },
    "EntityMatcherType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Server",
          "value": 0
        },
        {
          "name": "VulnerableMatcher",
          "value": 1
        },
        {
          "name": "Player",
          "value": 2
        }
      ]
    },
    "EffectDirection": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "BottomUp",
          "value": 1
        },
        {
          "name": "TopDown",
          "value": 2
        },
        {
          "name": "ToCenter",
          "value": 3
        },
        {
          "name": "FromCenter",
          "value": 4
        }
      ]
    },
    "ApplyMovementType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "CharacterController",
          "value": 0
        },
        {
          "name": "Position",
          "value": 1
        }
      ]
    },
    "AttachedToType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "LocalPlayer",
          "value": 0
        },
        {
          "name": "EntityId",
          "value": 1
        },
        {
          "name": "None",
          "value": 2
        }
      ]
    },
    "SmartMoveType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "EquipOrMergeStack",
          "value": 0
        },
        {
          "name": "PutInHotbarOrWindow",
          "value": 1
        },
        {
          "name": "PutInHotbarOrBackpack",
          "value": 2
        }
      ]
    },
    "PickupLocation": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Hotbar",
          "value": 0
        },
        {
          "name": "Storage",
          "value": 1
        }
      ]
    },
    "ParticleRotationInfluence": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Billboard",
          "value": 1
        },
        {
          "name": "BillboardY",
          "value": 2
        },
        {
          "name": "BillboardVelocity",
          "value": 3
        },
        {
          "name": "Velocity",
          "value": 4
        }
      ]
    },
    "ClickType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Left",
          "value": 1
        },
        {
          "name": "Right",
          "value": 2
        },
        {
          "name": "Middle",
          "value": 3
        }
      ]
    },
    "MovementType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Idle",
          "value": 1
        },
        {
          "name": "Crouching",
          "value": 2
        },
        {
          "name": "Walking",
          "value": 3
        },
        {
          "name": "Running",
          "value": 4
        },
        {
          "name": "Sprinting",
          "value": 5
        },
        {
          "name": "Climbing",
          "value": 6
        },
        {
          "name": "Swimming",
          "value": 7
        },
        {
          "name": "Flying",
          "value": 8
        },
        {
          "name": "Sliding",
          "value": 9
        },
        {
          "name": "Rolling",
          "value": 10
        },
        {
          "name": "Mounting",
          "value": 11
        },
        {
          "name": "SprintMounting",
          "value": 12
        }
      ]
    },
    "BlockMountType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Seat",
          "value": 0
        },
        {
          "name": "Bed",
          "value": 1
        }
      ]
    },
    "ParticleCollisionBlockType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Air",
          "value": 1
        },
        {
          "name": "Solid",
          "value": 2
        },
        {
          "name": "All",
          "value": 3
        }
      ]
    },
    "AmbienceFXSoundPlay3D": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Random",
          "value": 0
        },
        {
          "name": "LocationName",
          "value": 1
        },
        {
          "name": "No",
          "value": 2
        }
      ]
    },
    "CalculationType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Additive",
          "value": 0
        },
        {
          "name": "Multiplicative",
          "value": 1
        }
      ]
    },
    "FluidFog": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Color",
          "value": 0
        },
        {
          "name": "ColorLight",
          "value": 1
        },
        {
          "name": "EnvironmentTint",
          "value": 2
        }
      ]
    },
    "CurveType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Linear",
          "value": 0
        },
        {
          "name": "QuartIn",
          "value": 1
        },
        {
          "name": "QuartOut",
          "value": 2
        },
        {
          "name": "QuartInOut",
          "value": 3
        }
      ]
    },
    "InteractionTarget": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "User",
          "value": 0
        },
        {
          "name": "Owner",
          "value": 1
        },
        {
          "name": "Target",
          "value": 2
        }
      ]
    },
    "SwitchTo": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "Disappear",
          "value": 0
        },
        {
          "name": "PostColor",
          "value": 1
        },
        {
          "name": "Distortion",
          "value": 2
        },
        {
          "name": "Transparency",
          "value": 3
        }
      ]
    },
    "EntityUIType": {
      "package": "com.hypixel.hytale.protocol",
      "values": [
        {
          "name": "EntityStat",
          "value": 0
        },
        {
          "name": "CombatText",
          "value": 1
        }
      ]
    },
    "AssetEditorFileTree": {
      "package": "com.hypixel.hytale.protocol.packets.asseteditor",
      "values": [
        {
          "name": "Server",
          "value": 0
        },
        {
          "name": "Common",
          "value": 1
        }
      ]
    },
    "JsonUpdateType": {
      "package": "com.hypixel.hytale.protocol.packets.asseteditor",
      "values": [
        {
          "name": "SetProperty",
          "value": 0
        },
        {
          "name": "InsertProperty",
          "value": 1
        },
        {
          "name": "RemoveProperty",
          "value": 2
        }
      ]
    },
    "AssetEditorEditorType": {
      "package": "com.hypixel.hytale.protocol.packets.asseteditor",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Text",
          "value": 1
        },
        {
          "name": "JsonSource",
          "value": 2
        },
        {
          "name": "JsonConfig",
          "value": 3
        },
        {
          "name": "Model",
          "value": 4
        },
        {
          "name": "Texture",
          "value": 5
        },
        {
          "name": "Animation",
          "value": 6
        }
      ]
    },
    "WriteUpdateType": {
      "package": "com.hypixel.hytale.protocol.packets.asseteditor",
      "values": [
        {
          "name": "Add",
          "value": 0
        },
        {
          "name": "Update",
          "value": 1
        },
        {
          "name": "Remove",
          "value": 2
        }
      ]
    },
    "AssetEditorPopupNotificationType": {
      "package": "com.hypixel.hytale.protocol.packets.asseteditor",
      "values": [
        {
          "name": "Info",
          "value": 0
        },
        {
          "name": "Success",
          "value": 1
        },
        {
          "name": "Error",
          "value": 2
        },
        {
          "name": "Warning",
          "value": 3
        }
      ]
    },
    "Access": {
      "package": "com.hypixel.hytale.protocol.packets.serveraccess",
      "values": [
        {
          "name": "Private",
          "value": 0
        },
        {
          "name": "LAN",
          "value": 1
        },
        {
          "name": "Friend",
          "value": 2
        },
        {
          "name": "Open",
          "value": 3
        }
      ]
    },
    "SceneUpdateType": {
      "package": "com.hypixel.hytale.protocol.packets.machinima",
      "values": [
        {
          "name": "Update",
          "value": 0
        },
        {
          "name": "Play",
          "value": 1
        },
        {
          "name": "Stop",
          "value": 2
        },
        {
          "name": "Frame",
          "value": 3
        },
        {
          "name": "Save",
          "value": 4
        }
      ]
    },
    "ClientFeature": {
      "package": "com.hypixel.hytale.protocol.packets.setup",
      "values": [
        {
          "name": "SplitVelocity",
          "value": 0
        },
        {
          "name": "Mantling",
          "value": 1
        },
        {
          "name": "SprintForce",
          "value": 2
        },
        {
          "name": "CrouchSlide",
          "value": 3
        },
        {
          "name": "SafetyRoll",
          "value": 4
        },
        {
          "name": "DisplayHealthBars",
          "value": 5
        },
        {
          "name": "DisplayCombatText",
          "value": 6
        }
      ]
    },
    "BuilderToolArgGroup": {
      "package": "com.hypixel.hytale.protocol.packets.buildertools",
      "values": [
        {
          "name": "Tool",
          "value": 0
        },
        {
          "name": "Brush",
          "value": 1
        }
      ]
    },
    "BuilderToolAction": {
      "package": "com.hypixel.hytale.protocol.packets.buildertools",
      "values": [
        {
          "name": "SelectionPosition1",
          "value": 0
        },
        {
          "name": "SelectionPosition2",
          "value": 1
        },
        {
          "name": "SelectionCopy",
          "value": 2
        },
        {
          "name": "HistoryUndo",
          "value": 3
        },
        {
          "name": "HistoryRedo",
          "value": 4
        },
        {
          "name": "ActivateToolMode",
          "value": 5
        },
        {
          "name": "DeactivateToolMode",
          "value": 6
        }
      ]
    },
    "Axis": {
      "package": "com.hypixel.hytale.protocol.packets.buildertools",
      "values": [
        {
          "name": "X",
          "value": 0
        },
        {
          "name": "Y",
          "value": 1
        },
        {
          "name": "Z",
          "value": 2
        }
      ]
    },
    "BrushAxis": {
      "package": "com.hypixel.hytale.protocol.packets.buildertools",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Auto",
          "value": 1
        },
        {
          "name": "X",
          "value": 2
        },
        {
          "name": "Y",
          "value": 3
        },
        {
          "name": "Z",
          "value": 4
        }
      ]
    },
    "BrushShape": {
      "package": "com.hypixel.hytale.protocol.packets.buildertools",
      "values": [
        {
          "name": "Cube",
          "value": 0
        },
        {
          "name": "Sphere",
          "value": 1
        },
        {
          "name": "Cylinder",
          "value": 2
        },
        {
          "name": "Cone",
          "value": 3
        },
        {
          "name": "InvertedCone",
          "value": 4
        },
        {
          "name": "Pyramid",
          "value": 5
        },
        {
          "name": "InvertedPyramid",
          "value": 6
        },
        {
          "name": "Dome",
          "value": 7
        },
        {
          "name": "InvertedDome",
          "value": 8
        },
        {
          "name": "Diamond",
          "value": 9
        },
        {
          "name": "Torus",
          "value": 10
        }
      ]
    },
    "BrushOrigin": {
      "package": "com.hypixel.hytale.protocol.packets.buildertools",
      "values": [
        {
          "name": "Center",
          "value": 0
        },
        {
          "name": "Bottom",
          "value": 1
        },
        {
          "name": "Top",
          "value": 2
        }
      ]
    },
    "BuilderToolArgType": {
      "package": "com.hypixel.hytale.protocol.packets.buildertools",
      "values": [
        {
          "name": "Bool",
          "value": 0
        },
        {
          "name": "Float",
          "value": 1
        },
        {
          "name": "Int",
          "value": 2
        },
        {
          "name": "String",
          "value": 3
        },
        {
          "name": "Block",
          "value": 4
        },
        {
          "name": "Mask",
          "value": 5
        },
        {
          "name": "BrushShape",
          "value": 6
        },
        {
          "name": "BrushOrigin",
          "value": 7
        },
        {
          "name": "BrushAxis",
          "value": 8
        },
        {
          "name": "Rotation",
          "value": 9
        },
        {
          "name": "Option",
          "value": 10
        }
      ]
    },
    "EntityToolAction": {
      "package": "com.hypixel.hytale.protocol.packets.buildertools",
      "values": [
        {
          "name": "Remove",
          "value": 0
        },
        {
          "name": "Clone",
          "value": 1
        },
        {
          "name": "Freeze",
          "value": 2
        }
      ]
    },
    "DisconnectType": {
      "package": "com.hypixel.hytale.protocol.packets.connection",
      "values": [
        {
          "name": "Disconnect",
          "value": 0
        },
        {
          "name": "Crash",
          "value": 1
        }
      ]
    },
    "ClientType": {
      "package": "com.hypixel.hytale.protocol.packets.connection",
      "values": [
        {
          "name": "Game",
          "value": 0
        },
        {
          "name": "Editor",
          "value": 1
        }
      ]
    },
    "PongType": {
      "package": "com.hypixel.hytale.protocol.packets.connection",
      "values": [
        {
          "name": "Raw",
          "value": 0
        },
        {
          "name": "Direct",
          "value": 1
        },
        {
          "name": "Tick",
          "value": 2
        }
      ]
    },
    "NotificationStyle": {
      "package": "com.hypixel.hytale.protocol.packets.interface_",
      "values": [
        {
          "name": "Default",
          "value": 0
        },
        {
          "name": "Danger",
          "value": 1
        },
        {
          "name": "Warning",
          "value": 2
        },
        {
          "name": "Success",
          "value": 3
        }
      ]
    },
    "ChatType": {
      "package": "com.hypixel.hytale.protocol.packets.interface_",
      "values": [
        {
          "name": "Chat",
          "value": 0
        }
      ]
    },
    "CustomPageEventType": {
      "package": "com.hypixel.hytale.protocol.packets.interface_",
      "values": [
        {
          "name": "Acknowledge",
          "value": 0
        },
        {
          "name": "Data",
          "value": 1
        },
        {
          "name": "Dismiss",
          "value": 2
        }
      ]
    },
    "ChatTagType": {
      "package": "com.hypixel.hytale.protocol.packets.interface_",
      "values": [
        {
          "name": "Item",
          "value": 0
        }
      ]
    },
    "CustomUICommandType": {
      "package": "com.hypixel.hytale.protocol.packets.interface_",
      "values": [
        {
          "name": "Append",
          "value": 0
        },
        {
          "name": "AppendInline",
          "value": 1
        },
        {
          "name": "InsertBefore",
          "value": 2
        },
        {
          "name": "InsertBeforeInline",
          "value": 3
        },
        {
          "name": "Remove",
          "value": 4
        },
        {
          "name": "Set",
          "value": 5
        },
        {
          "name": "Clear",
          "value": 6
        }
      ]
    },
    "CustomPageLifetime": {
      "package": "com.hypixel.hytale.protocol.packets.interface_",
      "values": [
        {
          "name": "CantClose",
          "value": 0
        },
        {
          "name": "CanDismiss",
          "value": 1
        },
        {
          "name": "CanDismissOrCloseThroughInteraction",
          "value": 2
        }
      ]
    },
    "HudComponent": {
      "package": "com.hypixel.hytale.protocol.packets.interface_",
      "values": [
        {
          "name": "Hotbar",
          "value": 0
        },
        {
          "name": "StatusIcons",
          "value": 1
        },
        {
          "name": "Reticle",
          "value": 2
        },
        {
          "name": "Chat",
          "value": 3
        },
        {
          "name": "Requests",
          "value": 4
        },
        {
          "name": "Notifications",
          "value": 5
        },
        {
          "name": "KillFeed",
          "value": 6
        },
        {
          "name": "InputBindings",
          "value": 7
        },
        {
          "name": "PlayerList",
          "value": 8
        },
        {
          "name": "EventTitle",
          "value": 9
        },
        {
          "name": "Compass",
          "value": 10
        },
        {
          "name": "ObjectivePanel",
          "value": 11
        },
        {
          "name": "PortalPanel",
          "value": 12
        },
        {
          "name": "BuilderToolsLegend",
          "value": 13
        },
        {
          "name": "Speedometer",
          "value": 14
        },
        {
          "name": "UtilitySlotSelector",
          "value": 15
        },
        {
          "name": "BlockVariantSelector",
          "value": 16
        },
        {
          "name": "BuilderToolsMaterialSlotSelector",
          "value": 17
        },
        {
          "name": "Stamina",
          "value": 18
        },
        {
          "name": "AmmoIndicator",
          "value": 19
        },
        {
          "name": "Health",
          "value": 20
        },
        {
          "name": "Mana",
          "value": 21
        },
        {
          "name": "Oxygen",
          "value": 22
        },
        {
          "name": "Sleep",
          "value": 23
        }
      ]
    },
    "CustomUIEventBindingType": {
      "package": "com.hypixel.hytale.protocol.packets.interface_",
      "values": [
        {
          "name": "Activating",
          "value": 0
        },
        {
          "name": "RightClicking",
          "value": 1
        },
        {
          "name": "DoubleClicking",
          "value": 2
        },
        {
          "name": "MouseEntered",
          "value": 3
        },
        {
          "name": "MouseExited",
          "value": 4
        },
        {
          "name": "ValueChanged",
          "value": 5
        },
        {
          "name": "ElementReordered",
          "value": 6
        },
        {
          "name": "Validating",
          "value": 7
        },
        {
          "name": "Dismissing",
          "value": 8
        },
        {
          "name": "FocusGained",
          "value": 9
        },
        {
          "name": "FocusLost",
          "value": 10
        },
        {
          "name": "KeyDown",
          "value": 11
        },
        {
          "name": "MouseButtonReleased",
          "value": 12
        },
        {
          "name": "SlotClicking",
          "value": 13
        },
        {
          "name": "SlotDoubleClicking",
          "value": 14
        },
        {
          "name": "SlotMouseEntered",
          "value": 15
        },
        {
          "name": "SlotMouseExited",
          "value": 16
        },
        {
          "name": "DragCancelled",
          "value": 17
        },
        {
          "name": "Dropped",
          "value": 18
        },
        {
          "name": "SlotMouseDragCompleted",
          "value": 19
        },
        {
          "name": "SlotMouseDragExited",
          "value": 20
        },
        {
          "name": "SlotClickReleaseWhileDragging",
          "value": 21
        },
        {
          "name": "SlotClickPressWhileDragging",
          "value": 22
        },
        {
          "name": "SelectedTabChanged",
          "value": 23
        }
      ]
    },
    "Page": {
      "package": "com.hypixel.hytale.protocol.packets.interface_",
      "values": [
        {
          "name": "None",
          "value": 0
        },
        {
          "name": "Bench",
          "value": 1
        },
        {
          "name": "Inventory",
          "value": 2
        },
        {
          "name": "ToolsSettings",
          "value": 3
        },
        {
          "name": "Map",
          "value": 4
        },
        {
          "name": "MachinimaEditor",
          "value": 5
        },
        {
          "name": "ContentCreation",
          "value": 6
        },
        {
          "name": "Custom",
          "value": 7
        }
      ]
    },
    "WindowType": {
      "package": "com.hypixel.hytale.protocol.packets.window",
      "values": [
        {
          "name": "Container",
          "value": 0
        },
        {
          "name": "PocketCrafting",
          "value": 1
        },
        {
          "name": "BasicCrafting",
          "value": 2
        },
        {
          "name": "DiagramCrafting",
          "value": 3
        },
        {
          "name": "StructuralCrafting",
          "value": 4
        },
        {
          "name": "Processing",
          "value": 5
        },
        {
          "name": "Memories",
          "value": 6
        }
      ]
    },
    "PaletteType": {
      "package": "com.hypixel.hytale.protocol.packets.world",
      "values": [
        {
          "name": "Empty",
          "value": 0
        },
        {
          "name": "HalfByte",
          "value": 1
        },
        {
          "name": "Byte",
          "value": 2
        },
        {
          "name": "Short",
          "value": 3
        }
      ]
    },
    "RotationAxis": {
      "package": "com.hypixel.hytale.protocol.packets.world",
      "values": [
        {
          "name": "X",
          "value": 0
        },
        {
          "name": "Y",
          "value": 1
        },
        {
          "name": "Z",
          "value": 2
        }
      ]
    },
    "RotationDirection": {
      "package": "com.hypixel.hytale.protocol.packets.world",
      "values": [
        {
          "name": "Positive",
          "value": 0
        },
        {
          "name": "Negative",
          "value": 1
        }
      ]
    }
  }
}